This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-12T18:30:40.159Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
[id]/components/exercise-container.tsx
[id]/components/exercise-footer.tsx
[id]/components/exercise-header.tsx
[id]/components/loading-overlay.tsx
[id]/components/slides/instruction-slide.tsx
[id]/components/slides/question-slide.tsx
[id]/components/slides/setup-slide.tsx
[id]/data/exercise-content.ts
[id]/hooks/use-answer-handler.ts
[id]/hooks/use-completion-handler.ts
[id]/hooks/use-exercise-scroll.ts
[id]/hooks/use-exercise-state.ts
[id]/hooks/use-exercise-timer.ts
[id]/hooks/use-timer-effects.ts
[id]/layout.tsx
[id]/page.tsx
[id]/types/types.ts
[id]/utils/exercise-utils.ts
[id]/utils/scroll-utils.ts
api/exercise-progression.service.ts
utils/get-exercise-content.tsx

================================================================
Repository Files
================================================================

================
File: [id]/components/exercise-container.tsx
================
// app/(features)/exercise-progression/[id]/components/exercise-container.tsx
'use client'

import { useState } from 'react'
import { useAuth } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import { ExerciseHeader } from './exercise-header'
import { ExerciseFooter } from './exercise-footer'
import { SetupSlide } from './slides/setup-slide'
import { InstructionSlide } from './slides/instruction-slide'
import { QuestionSlide } from './slides/question-slide'
import { LoadingOverlay } from './loading-overlay'
import { ExerciseContainerProps } from '../types/types'
import { useExerciseTimer } from '../hooks/use-exercise-timer'
import { useExerciseScroll } from '../hooks/use-exercise-scroll'
import { exercises } from '../data/exercise-content'
import { v4 as uuidv4 } from 'uuid'
import { useExerciseState } from '../hooks/use-exercise-state'
import { areAllQuestionsAnswered } from '../utils/exercise-utils'
import { useAnswerHandler } from '../hooks/use-answer-handler'
import { useCompletionHandler } from '../hooks/use-completion-handler'
import { useTimerEffects } from '../hooks/use-timer-effects'
import { scrollWithTimeout } from '../utils/scroll-utils'
import { ExerciseStateItem } from '../types/types'

export function ExerciseContainer({ exercise: initialExercise }: ExerciseContainerProps) {
  const { isLoaded, isSignedIn, getToken } = useAuth()
  const router = useRouter()
  const [sessionId] = useState(() => uuidv4())
  
  const { 
    state,
    setState,
    updateExercisePhase  } = useExerciseState(initialExercise.id, initialExercise.duration)

  const { 
    timeRemaining, 
    isActive: isTimerActive, 
    startTimer, 
    stopTimer, 
    resetTimer 
  } = useExerciseTimer(initialExercise.duration)

  const {
    scrollToQuestion,
    scrollToInstruction,
    scrollToSetup,
    getQuestionRef,
    getInstructionRef,
    getSetupRef,
    scrollWithRetry
  } = useExerciseScroll()

  const currentExercise = state.exerciseStates[state.activeExerciseIndex]

  const { handleAnswer } = useAnswerHandler(
    sessionId,
    () => getToken({ template: 'supabase' }),
    setState,
    scrollToQuestion,
    scrollToSetup,
    scrollWithRetry,
    resetTimer
  )

  const { handleComplete } = useCompletionHandler(
    () => getToken({ template: 'supabase' }),
    setState,
    sessionId
  )

  useTimerEffects(
    isTimerActive,
    timeRemaining,
    initialExercise.duration,
    currentExercise,
    setState,
    scrollToQuestion
  )

  const handleTimerStart = () => {
    updateExercisePhase('active')
    startTimer()

    scrollWithTimeout(() => {
      if (currentExercise.currentQuestionId) {
        scrollToQuestion(currentExercise.currentQuestionId)
      } else {
        scrollToInstruction()
      }
    })
  }

  const onAnswerSelected = (questionId: string, answerId: string) => {
    handleAnswer(questionId, answerId, currentExercise)
  }

  const onComplete = async () => {
    await handleComplete(currentExercise, state.activeExerciseIndex)
  }

  if (!isLoaded) return <LoadingOverlay />
  if (!isSignedIn) {
    router.push('/sign-in')
    return null
  }

  return (
    <div className="min-h-[100dvh] flex flex-col">
      <ExerciseHeader 
        timeRemaining={timeRemaining}
        isActive={isTimerActive}
      />

      <main className="flex-1 overflow-y-auto px-4 pb-32 pt-4">
        <div className="max-w-2xl mx-auto space-y-6">
          {state.exerciseStates.map((exerciseState: ExerciseStateItem, index: number) => {
            const currentExercise = exercises[exerciseState.id]
            
            return (
              <div 
                key={exerciseState.id} 
                className="space-y-6"
                ref={getSetupRef(exerciseState.id)}
              >
                <SetupSlide 
                  exercise={currentExercise}
                  state={exerciseState}
                  onTimerStart={handleTimerStart}
                  onTimerStop={stopTimer}
                  onAnswerSelected={onAnswerSelected}
                />

                {exerciseState.phase !== 'setup' && (
                  <InstructionSlide
                    ref={index === state.activeExerciseIndex ? getInstructionRef : null}
                    exercise={currentExercise}
                    state={exerciseState}
                    onTimerStart={handleTimerStart}
                    onTimerStop={stopTimer}
                    onAnswerSelected={onAnswerSelected}
                  />
                )}

                {exerciseState.visibleQuestions.map((questionId: string) => (
                  <QuestionSlide
                    key={questionId}
                    ref={index === state.activeExerciseIndex ? getQuestionRef(questionId) : null}
                    exercise={currentExercise}
                    state={exerciseState}
                    questionId={questionId}
                    onTimerStart={handleTimerStart}
                    onTimerStop={stopTimer}
                    onAnswerSelected={onAnswerSelected}
                  />
                ))}
              </div>
            )
          })}
        </div>
      </main>

      <ExerciseFooter
        isActive={isTimerActive}
        timeRemaining={timeRemaining}
        onStart={handleTimerStart}
        onStop={stopTimer}
        onComplete={onComplete}
        canContinue={areAllQuestionsAnswered(state.exerciseStates[state.activeExerciseIndex])}
      />
    </div>
  )
}

================
File: [id]/components/exercise-footer.tsx
================
'use client'

import { Button } from "@/components/ui/button"
import { PauseCircle, Play } from 'lucide-react'

interface ExerciseFooterProps {
  isActive: boolean
  timeRemaining: number
  onStart: () => void
  onStop: () => void
  onComplete: () => Promise<void>
  canContinue: boolean
}

export function ExerciseFooter({ 
  isActive, 
  timeRemaining,
  onStart, 
  onStop,
  onComplete,
  canContinue
}: ExerciseFooterProps) {
  

  if (timeRemaining === 0) {
    return (
      <div className="fixed bottom-0 left-0 right-0 p-4 shadow-lg bg-white">
        <div className="max-w-xs mx-auto">
          <Button 
            onClick={() => {
              
              if (onComplete) {
             
                onComplete()
              }
            }}
            className="w-full h-12 text-lg bg-green-500 hover:bg-green-600"
            disabled={!canContinue}
          >
            Complete Exercise
          </Button>
        </div>
      </div>
    )
  }

  return (
    <div className="fixed bottom-0 left-0 right-0 p-4 shadow-lg bg-white">
      <div className="max-w-xs mx-auto">
        {!isActive ? (
          <Button 
            onClick={() => {
             
              onStart()
            }}
            className="w-full h-12 text-lg bg-green-500 hover:bg-green-500 hover:shadow-sm hover:scale-105 transition-transform"
          >
            <Play className="w-5 h-5 mr-2" style={{ marginRight: '2%' }} />
            <span style={{ marginRight: '8%' }}>Start Exercise</span>
          </Button>
        ) : (
          <Button 
            onClick={() => {
             
              onStop()
            }}
            variant="destructive"
            className="w-full h-12 text-lg"
          >
            <PauseCircle className="w-5 h-5 mr-2" style={{ marginRight: '2%' }} />
            <span style={{ marginRight: '8%' }}>Stop Exercise</span>
          </Button>
        )}
      </div>
    </div>
  )
}

================
File: [id]/components/exercise-header.tsx
================
// app/(features)/exercise-progression/[id]/components/exercise-header.tsx
'use client'

import { motion } from 'framer-motion'
import { UserButton } from '@clerk/nextjs'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'

interface ExerciseHeaderProps {
  timeRemaining: number
  isActive: boolean
}

export function ExerciseHeader({ timeRemaining}: ExerciseHeaderProps) {
  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`
  }

  return (
    <motion.header 
      className="sticky top-0 z-50 bg-white border-b"
      initial={{ y: -100 }}
      animate={{ y: 0 }}
    >
      <div className="flex items-center justify-between p-4">
        <Link 
          href="/dashboard" 
          className="text-gray-600 hover:text-gray-900 transition-colors"
        >
          <ArrowLeft size={24} />
        </Link>
        <div className="flex-grow text-center text-2xl font-bold">
          {formatTime(timeRemaining)}
        </div>
        <div className="flex items-center">
          <UserButton />
        </div>
      </div>
    </motion.header>
  )
}

================
File: [id]/components/loading-overlay.tsx
================
// app/(features)/exercise-progression/[id]/components/loading-overlay.tsx
'use client'

import { motion } from 'framer-motion'
import { Loader2 } from 'lucide-react'

interface LoadingOverlayProps {
  message?: string
}

export function LoadingOverlay({ message = 'Loading...' }: LoadingOverlayProps) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="fixed inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50"
    >
      <div className="flex flex-col items-center gap-3">
        <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
        <div className="text-sm text-gray-600">
          {message}
        </div>
      </div>
    </motion.div>
  )
}

================
File: [id]/components/slides/instruction-slide.tsx
================
// app/(features)/exercise-progression/[id]/components/instruction-slide.tsx
'use client'

import { forwardRef } from 'react'
import { Card } from "@/components/ui/card"
import { AlertCircle } from 'lucide-react'
import { motion } from 'framer-motion'
import { SlideProps } from '../../types/types'

export const InstructionSlide = forwardRef<HTMLDivElement, SlideProps>(
  function InstructionSlide({ exercise }, ref) {
    return (
      <motion.div
        ref={ref}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className="scroll-mt-20"
      >
        <Card className="p-6 space-y-6">
          <div className="space-y-4">
            {/* Execution Instructions */}
            <div className="bg-blue-50 p-4 rounded-lg">
              <h3 className="font-semibold text-lg mb-3">During Exercise</h3>
              <ul className="space-y-2">
                {exercise.instructions.execution.map((instruction, index) => (
                  <li key={index} className="flex items-start gap-3">
                    <span className="text-blue-500">•</span>
                    <span className="text-slate-700">{instruction}</span>
                  </li>
                ))}
              </ul>
            </div>

            {/* Safety Instructions */}
            <div className="bg-red-50 p-4 rounded-lg">
              <div className="flex items-start gap-3">
                <AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0 mt-1" />
                <div>
                  <h3 className="font-semibold text-lg mb-2">Safety Notes</h3>
                  <ul className="space-y-2">
                    {exercise.instructions.safety.map((instruction, index) => (
                      <li key={index} className="text-slate-700">
                        • {instruction}
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </Card>
      </motion.div>
    )
  }
)

================
File: [id]/components/slides/question-slide.tsx
================
// app/(features)/exercise-progression/[id]/components/question-slide.tsx
'use client'

import { Card } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { motion } from 'framer-motion'
import { questions } from '../../data/exercise-content'
import { SlideProps } from '../../types/types'
import React, { forwardRef } from 'react';

interface QuestionSlideProps extends SlideProps {
 questionId: string
}

// Update the component to use forwardRef
export const QuestionSlide = forwardRef<HTMLDivElement, QuestionSlideProps>(({ 
 state, 
 questionId,
 onAnswerSelected 
}, ref) => {
 const question = questions[questionId]
 const selectedAnswer = state.answers[questionId]

 return (
   <motion.div
     ref={ref} // Attach the ref here
     initial={{ opacity: 0, y: 20 }}
     animate={{ opacity: 1, y: 0 }}
     transition={{ duration: 0.3 }}
     className="scroll-mt-20"
   >
     <Card className="p-6 space-y-4">
       <h3 className="text-lg font-semibold">
         {question.text}
       </h3>

       <div className="grid grid-cols-1 gap-3">
         {question.options.map((option) => (
           <Button
             key={option.id}
             variant={selectedAnswer === option.id ? "default" : "outline"}
             className={`w-full justify-start text-left h-auto p-4 ${
               selectedAnswer === option.id ? 'bg-blue-50 border-blue-500 text-blue-700' : ''
             }`}
             onClick={() => onAnswerSelected(questionId, option.id)}
             disabled={state.answers[questionId] !== undefined}
           >
             {option.text}
           </Button>
         ))}
       </div>
     </Card>
   </motion.div>
 )
});

// Add display name for the component
QuestionSlide.displayName = 'QuestionSlide'; // Fix for missing display name

// Ensure to export the component

================
File: [id]/components/slides/setup-slide.tsx
================
// app/(features)/exercise-progression/[id]/components/setup-slide.tsx
'use client'

import Image from 'next/image'
import { Card } from "@/components/ui/card"
import { CheckCircle } from 'lucide-react'
import { motion } from 'framer-motion'
import { SlideProps } from '../../types/types'
import { useEffect, useState } from 'react'
import { getVideoUrl } from '@root/utils/video-urls'

export function SetupSlide({ exercise }: SlideProps) {
  const [videoUrl, setVideoUrl] = useState('')

  useEffect(() => {
    if (exercise.mediaType === 'video') {
      getVideoUrl('pronePress').then((url: string) => setVideoUrl(url))
    }
  }, [exercise])

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <Card className="p-3 space-y-1">
        <h2 className="text-2xl font-bold text-center">
          {exercise.name}
        </h2>

        <div className="relative h-[140px] md:h-[250px] rounded-lg overflow-hidden">
          {exercise.mediaType === 'video' ? (
            <video
              src={videoUrl || exercise.imageUrl}
              className="w-full h-full object-contain"
              controls
              playsInline
            />
          ) : (
            <Image
              src={exercise.imageUrl}
              alt={exercise.name}
              fill
              className="object-contain"
              priority
            />
          )}
        </div>

        <div className="space-y-1">
          <h3 className="font-semibold text-lg">Setup Instructions</h3>
          <ul className="space-y-3">
            {exercise.instructions.setup.map((instruction, index) => (
              <li key={index} className="flex items-start gap-3">
                <CheckCircle className="w-5 h-5 text-green-500 flex-shrink-0 mt-1" />
                <span>{instruction}</span>
              </li>
            ))}
          </ul>
        </div>
      </Card>
    </motion.div>
  )
}

================
File: [id]/data/exercise-content.ts
================
// app/(features)/exercise-progression/[id]/data/exercise-content.ts

import { Exercise, Question } from '../types/types';


export const exercises: Record<string, Exercise> = {
  '1': {
    id: '1',
    name: 'Lying Face Down',
    duration: 120, // Changed from 10 to 120 seconds (2 minutes)
    imageUrl: '/pronelying.png',
    mediaType: 'image',
    instructions: {
      setup: [
        'Find a comfortable spot on the floor or bed if unable to lie on floor',
        'Have your phone in front of you and accessible',
        'Ensure enough space to lie flat',
        'When you are in position and ready, press "Start Exercise" button below',
        'The exercise should be performed for 1-2 minutes'
      ],
      execution: [
        'Be mindful of how the pain is distributed',
        'Pain reducing, or disappearing is a good sign',
        'Pain moving out of the legs and towards the spine is a good sign'
      ],
      safety: [
        'Stop if pain increases in butt or legs',
        'Stop if symptoms move further down your legs',
      ]
    }
  },
  '2': {
    id: '2',
    name: "Lying Down on Elbows",
    duration: 120, // Changed from 10 to 120 seconds (2 minutes)
    imageUrl: "/proneonelbows.png",
    mediaType: 'image',
    instructions: {
      setup: [
        "Start by lying face down",
        "Position elbows under shoulders",
        "Have your phone within reach",
        "When you are in position and ready, press 'Start Exercise' button below"       
      ],
      execution: [
        "Be mindful of how the pain is distributed",
        "Pain reducing, or disappearing is a good sign",
        "Pain moving out of the legs and towards the spine is a good sign"
      ],
      safety: [
        "Stop if pain increases in butt or legs",
        "Stop if symptoms move further into legs",
      ]
    }
  },
  '3': {
    id: '3',
    name: "Prone Press Up",
    duration: 120, // Changed from 10 to 120 seconds (2 minutes)
    instructions: {
      setup: [
        'Start by lying face down, with hands by chest in a push up position', 
        'While pressing up, your back, hips and legs should remain relaxed', 
        'The goal is to let the back arch and curl up, while keeping the hips and legs relaxed',
        'When you are in position and ready, press "Start Exercise" button below',
        'Perform 10-15 repititions'
      ],
      execution: [
        "Be mindful of how the pain is distributed",
        "Pain reducing, or disappearing is a good sign",
        "Pain moving out of the legs and towards the spine is a good sign"
      ],
      safety: [
        'Stop if pain increases',
        'Stop if symptoms move further into legs',
      ]
    },
    imageUrl: process.env.NEXT_PUBLIC_PRONE_PRESS_VIDEO_URL || '', 
    mediaType: 'video'
  }
};

export const questions: Record<string, Question> = {
  'initial': {
    id: 'initial',
    text: 'Wait to answer this question until you notice a change in your symptoms. How are your symptoms responding?',
    options: [
      { 
        id: 'better', 
        text: 'Better',
        nextQuestionId: 'location'
      },
      { 
        id: 'worse', 
        text: 'Worse',
        nextQuestionId: 'stop'
      },
      { 
        id: 'same', 
        text: 'Same',
        nextQuestionId: 'location'
      }
    ]
  },
  'location': {
    id: 'location',
    text: 'Where is your pain located now?',
    options: [
      { 
        id: 'central', 
        text: 'More central/toward spine',
        nextQuestionId: 'continue'
      },
      { 
        id: 'peripheral', 
        text: 'More peripheral/toward legs',
        nextQuestionId: 'stop'
      },
      { 
        id: 'same', 
        text: 'Same location',
        nextQuestionId: 'continue'
      }
    ]
  },
  'continue': {
    id: 'continue',
    text: 'Would you like to continue with the exercise?',
    options: [
      { id: 'yes', text: 'Yes' },
      { id: 'no', text: 'No' }
    ]
  },
  'completion': {
    id: 'completion',
    text: 'Congratulations! You have completed the exercise series.',
    options: [
      { id: 'finish', text: 'Return to Dashboard' }
    ]
  },
  'stop': {
    id: 'stop',
    text: 'We should stop this exercise. Would you like to try a different position?',
    options: [
      { id: 'yes', text: 'Yes' },
      { id: 'no', text: 'No' }
    ]
  },
  stop_exercise: {
    id: 'stop_exercise',
    text: "We should stop this exercise.",
    options: [
      {
        id: "return_to_dashboard",
        text: "Return to Dashboard",
        nextQuestionId: null
      }
    ]
  }
};

================
File: [id]/hooks/use-answer-handler.ts
================
import { questions, exercises } from '../data/exercise-content'
import { ExerciseProgressionService } from '../../api/exercise-progression.service'
import { ExerciseState, Question } from '../types/types'
import { shouldProgressToNextExercise } from '../utils/exercise-utils'

export function useAnswerHandler(
  sessionId: string,
  getToken: () => Promise<string | null>,
  setState: React.Dispatch<React.SetStateAction<ExerciseState>>,
  scrollToQuestion: (questionId: string) => void,
  scrollToSetup: (exerciseId: string) => void,
  scrollWithRetry: (fn: () => void) => void,
  resetTimer: (duration: number) => void,
) {

  const handleAnswer = async (questionId: string, answerId: string, currentExercise: ExerciseState['exerciseStates'][0]) => {
    
    
    // First save the answer
    if (questionId === 'continue' || answerId === 'return_to_dashboard' || questionId === 'completion') {
      await saveAnswerAttempt(questionId, answerId, currentExercise)
      
      if (answerId === 'no' || answerId === 'return_to_dashboard') {
        
        await saveCompletionStatus('stopped_early')
        window.location.href = '/dashboard'
        return
      }

      if (questionId === 'completion' && answerId === 'finish') {
        
        await saveCompletionStatus('completed')
        window.location.href = '/dashboard'
        return
      }
    }

    updateAnswerState(questionId, answerId)
  }

  const saveAnswerAttempt = async (questionId: string, answerId: string, currentExercise: ExerciseState['exerciseStates'][0]) => {
    try {
      const token = await getToken()
      if (!token) {
        console.error('No auth token available')
        return
      }

      const responses = [
        ...Object.entries(currentExercise.answers).map(([qId, aId]) => ({
          questionId: qId,
          answerId: aId
        })),
        { questionId, answerId }
      ]

      await ExerciseProgressionService.saveExerciseAttempt({
        sessionId,
        exerciseId: currentExercise.id,
        responses,
        status: answerId === 'return_to_dashboard' ? 'stopped_early' : 'completed',
        token
      })
    } catch (error) {
      console.error('Failed to save exercise:', error)
    }
  }

  const saveCompletionStatus = async (status: 'completed' | 'stopped_early') => {
    try {
      const token = await getToken()
      if (!token) return

      await ExerciseProgressionService.saveExerciseAttempt({
        sessionId,
        exerciseId: 'completion',
        responses: [{ questionId: 'completion', answerId: status }],
        status,
        token
      })
    } catch (error) {
      console.error('Failed to save completion status:', error)
    }
  }

  const updateAnswerState = (questionId: string, answerId: string) => {
    setState(prev => {
      const exercisesCopy = [...prev.exerciseStates]
      const currentExerciseIndex = prev.activeExerciseIndex
      const exercise = exercisesCopy[currentExerciseIndex]

      exercise.answers[questionId] = answerId

      const question = questions[questionId]
      const selectedOption = question.options.find(opt => opt.id === answerId)

      if (answerId === 'worse' || answerId === 'peripheral') {
        return handleNegativeResponse(exercise, exercisesCopy, currentExerciseIndex)
      }

      return handlePositiveResponse(exercise, selectedOption, exercisesCopy)
    })
  }

  // Helper functions for updateAnswerState
  const handleNegativeResponse = (exercise: ExerciseState['exerciseStates'][0], exercisesCopy: ExerciseState['exerciseStates'], currentExerciseIndex: number) => {
    exercise.currentQuestionId = 'stop_exercise'
    exercise.visibleQuestions = [...new Set([...exercise.visibleQuestions, 'stop_exercise'])]
    
    return {
      exerciseStates: exercisesCopy,
      activeExerciseIndex: currentExerciseIndex
    }
  }

  const handlePositiveResponse = (
    exercise: ExerciseState['exerciseStates'][0], 
    selectedOption: Question['options'][0] | undefined, 
    exercisesCopy: ExerciseState['exerciseStates']
  ) => {
    if (selectedOption?.nextQuestionId) {
      const isLastExercise = !exercises[String(parseInt(exercise.id) + 1)]
      
      if (isLastExercise && selectedOption.nextQuestionId === 'continue') {
        if (!exercise.visibleQuestions.includes('completion')) {
          exercise.currentQuestionId = 'completion'
          exercise.visibleQuestions = [...exercise.visibleQuestions, 'completion']
        }
      } else {
        exercise.currentQuestionId = selectedOption.nextQuestionId
        exercise.visibleQuestions = [...new Set([...exercise.visibleQuestions, selectedOption.nextQuestionId])]
      }

      setTimeout(() => scrollToQuestion(exercise.currentQuestionId!), 50)
    }

    if (!selectedOption?.nextQuestionId && shouldProgressToNextExercise(exercise)) {
      const nextExerciseId = String(parseInt(exercise.id) + 1)
      const nextExercise = exercises[nextExerciseId]
      
      if (nextExercise) {
        exercisesCopy.push({
          id: nextExerciseId,
          phase: 'setup',
          currentQuestionId: null,
          answers: {},
          visibleQuestions: [],
          timeRemaining: nextExercise.duration,
          isTimerActive: false
        })
        
        resetTimer(nextExercise.duration)
        scrollWithRetry(() => scrollToSetup(nextExerciseId))
        
        setTimeout(() => {
          scrollToSetup(nextExerciseId)
        }, 50)
      }
    }

    return {
      exerciseStates: exercisesCopy,
      activeExerciseIndex: exercisesCopy.length - 1
    }
  }

  return { handleAnswer }
}

================
File: [id]/hooks/use-completion-handler.ts
================
import { ExerciseState } from '../types/types'
import { ExerciseProgressionService } from '../../api/exercise-progression.service'

export function useCompletionHandler(
  getToken: () => Promise<string | null>,
  setState: React.Dispatch<React.SetStateAction<ExerciseState>>,
  sessionId: string
) {

  const handleComplete = async (currentExercise: ExerciseState['exerciseStates'][0], activeExerciseIndex: number) => {

    try {
      const token = await getToken()
      if (!token) {
        console.error('No auth token available')
        return
      }
      

      // If we have a completion answer, handle it directly
      if (currentExercise.answers.completion === 'finish') {
        
        await saveCompletionStatus('completed')
        
        window.location.href = '/dashboard'
        return
      }

      const { continue: continueResponse, initial: initialResponse, location: locationResponse } = currentExercise.answers
      
      
      if (continueResponse === 'no') {
        
        await saveCompletionStatus('stopped_early')
        window.location.href = '/dashboard'
        return
      }

      const canProgress = 
        (initialResponse === 'better' || initialResponse === 'same') &&
        (locationResponse === 'central' || locationResponse === 'same')

      

      if (!canProgress) {
        
        await saveCompletionStatus('stopped_early')
        window.location.href = '/dashboard'
        return
      }

      const currentExerciseId = parseInt(currentExercise.id)
      

      setState(prev => ({
        ...prev,
        exerciseStates: prev.exerciseStates.map((ex, index) => 
          index === activeExerciseIndex ? { ...ex, isTimerActive: false } : ex
        )
      }))

      if (currentExerciseId < 3) {
        
        await saveCompletionStatus('completed')
        window.location.href = `/exercise-progression/${currentExerciseId + 1}`
      } else {
        
        await saveCompletionStatus('completed')
        window.location.href = '/dashboard'
      }
    } catch (error) {
      console.error('Error completing exercise:', error)
      console.error(error)
    }
  }

  const saveCompletionStatus = async (status: 'completed' | 'stopped_early') => {
    
    try {
      const token = await getToken()
      if (!token) {
        console.error('No token available for saving completion status')
        return
      }

      
      await ExerciseProgressionService.saveExerciseAttempt({
        sessionId,
        exerciseId: 'completion',
        responses: [{ questionId: 'completion', answerId: status }],
        status,
        token
      })
      
    } catch (error) {
      console.error('Failed to save completion status:', error)
      console.error(error)
    }
  }

  return { handleComplete }
}

================
File: [id]/hooks/use-exercise-scroll.ts
================
// app/(features)/exercise-progression/[id]/hooks/use-exercise-scroll.ts

import { useRef, useCallback } from 'react'

interface ScrollRefs {
  questions: Record<string, HTMLDivElement>
  instruction: HTMLDivElement | null
  setup: Record<string, HTMLDivElement>
}

export function useExerciseScroll() {
  const refs = useRef<ScrollRefs>({
    questions: {},
    instruction: null,
    setup: {}
  })

  const scrollToElement = useCallback((element: HTMLElement | null) => {
    if (!element) return
    
    const headerHeight = 64 // Approximate header height
    const footerHeight = 80 // Approximate footer height
    const windowHeight = window.innerHeight
    const elementRect = element.getBoundingClientRect()
    
    // Calculate the ideal scroll position
    const scrollPosition = 
      window.scrollY + 
      elementRect.top - 
      headerHeight - 
      (windowHeight - elementRect.height - footerHeight) / 2
    
    window.scrollTo({
      top: Math.max(0, scrollPosition),
      behavior: 'smooth'
    })
  }, [])

  const scrollToQuestion = useCallback((questionId: string) => {
    if (refs.current.questions[questionId]) {
      scrollToElement(refs.current.questions[questionId])
    }
  }, [scrollToElement])

  const scrollToInstruction = useCallback(() => {
    scrollToElement(refs.current.instruction)
  }, [scrollToElement])

  const scrollToSetup = useCallback((exerciseId: string) => {
    if (refs.current.setup[exerciseId]) {
      scrollToElement(refs.current.setup[exerciseId])
    }
  }, [scrollToElement])

  const getQuestionRef = useCallback((questionId: string) => (
    (el: HTMLDivElement | null) => {
      if (el) {
        refs.current.questions[questionId] = el
      }
    }
  ), [])

  const getInstructionRef = useCallback((el: HTMLDivElement | null) => {
    refs.current.instruction = el
  }, [])

  const getSetupRef = useCallback((exerciseId: string) => (
    (el: HTMLDivElement | null) => {
      if (el) {
        refs.current.setup[exerciseId] = el
      }
    }
  ), [])

  const scrollWithRetry = useCallback((scrollFn: () => void) => {
    // Initial scroll
    setTimeout(scrollFn, 100)
    // Retry scrolls to handle dynamic content
    setTimeout(scrollFn, 300)
    setTimeout(scrollFn, 500)
  }, [])

  return {
    scrollToQuestion,
    scrollToInstruction,
    scrollToSetup,
    getQuestionRef,
    getInstructionRef,
    getSetupRef,
    scrollWithRetry
  }
}

================
File: [id]/hooks/use-exercise-state.ts
================
import { useState } from 'react'
import { ExerciseState } from '../types/types'
import { exercises } from '../data/exercise-content'

export function useExerciseState(initialExerciseId: string, initialDuration: number) {
  const [state, setState] = useState<ExerciseState>({
    exerciseStates: [{
      id: initialExerciseId,
      phase: 'setup',
      currentQuestionId: null,
      answers: {},
      visibleQuestions: [],
      timeRemaining: initialDuration,
      isTimerActive: false
    }],
    activeExerciseIndex: 0
  })

  const updateExercisePhase = (phase: ExerciseState['exerciseStates'][0]['phase']) => {
    setState(prev => ({
      ...prev,
      exerciseStates: prev.exerciseStates.map((ex, index) => 
        index === prev.activeExerciseIndex ? {
          ...ex,
          phase,
          isTimerActive: phase === 'active'
        } : ex
      )
    }))
  }

  const addNextExercise = (currentExerciseId: string) => {
    const nextExerciseId = String(parseInt(currentExerciseId) + 1)
    const nextExercise = exercises[nextExerciseId]
    
    if (!nextExercise) return false

    setState(prev => ({
      ...prev,
      exerciseStates: [
        ...prev.exerciseStates,
        {
          id: nextExerciseId,
          phase: 'setup',
          currentQuestionId: null,
          answers: {},
          visibleQuestions: [],
          timeRemaining: nextExercise.duration,
          isTimerActive: false
        }
      ],
      activeExerciseIndex: prev.exerciseStates.length
    }))

    return true
  }

  return {
    state,
    setState,
    updateExercisePhase,
    addNextExercise
  }
}

================
File: [id]/hooks/use-exercise-timer.ts
================
// app/(features)/exercise-progression/[id]/hooks/use-exercise-timer.ts

import { useState, useEffect, useRef } from 'react'

interface TimerState {
  timeRemaining: number
  isActive: boolean
}

interface UseExerciseTimer {
  timeRemaining: number
  isActive: boolean
  startTimer: () => void
  stopTimer: () => void
  resetTimer: (duration: number) => void
}

export function useExerciseTimer(initialDuration: number): UseExerciseTimer {
  const [state, setState] = useState<TimerState>({
    timeRemaining: initialDuration,
    isActive: false
  })
  
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  const startTimeRef = useRef<number | null>(null)

  useEffect(() => {
    if (!state.isActive) return

    // Clear any existing timer
    if (timerRef.current) {
      clearInterval(timerRef.current)
    }

    // Set start time when timer becomes active
    startTimeRef.current = Date.now()
    const initialTimeRemaining = state.timeRemaining

    timerRef.current = setInterval(() => {
      if (!startTimeRef.current) return

      // Calculate elapsed time based on real time difference
      const elapsedSeconds = Math.floor((Date.now() - startTimeRef.current) / 1000)
      const newTimeRemaining = initialTimeRemaining - elapsedSeconds

      // Stop timer if we've reached 0
      if (newTimeRemaining <= 0) {
        setState(prev => ({
          ...prev,
          isActive: false,
          timeRemaining: 0
        }))
        
        if (timerRef.current) {
          clearInterval(timerRef.current)
        }
        return
      }

      setState(prev => ({
        ...prev,
        timeRemaining: newTimeRemaining
      }))
    }, 1000)

    // Cleanup
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [state.isActive, state.timeRemaining])

  const startTimer = () => {
    setState(prev => ({
      ...prev,
      isActive: true
    }))
  }

  const stopTimer = () => {
    setState(prev => ({
      ...prev,
      isActive: false
    }))
  }

  const resetTimer = (duration: number) => {
    setState({
      timeRemaining: duration,
      isActive: false
    })
    startTimeRef.current = null
  }

  return {
    timeRemaining: state.timeRemaining,
    isActive: state.isActive,
    startTimer,
    stopTimer,
    resetTimer
  }
}

================
File: [id]/hooks/use-timer-effects.ts
================
import { useEffect } from 'react'
import { ExerciseState } from '../types/types'
import { scrollWithTimeout } from '../utils/scroll-utils'

export function useTimerEffects(
  isTimerActive: boolean,
  timeRemaining: number,
  initialDuration: number,
  currentExercise: ExerciseState['exerciseStates'][0],
  setState: React.Dispatch<React.SetStateAction<ExerciseState>>,
  scrollToQuestion: (questionId: string) => void
) {
  // Show first question after 5 seconds of exercise start
  useEffect(() => {
    if (isTimerActive && timeRemaining === initialDuration - 5&& !currentExercise.currentQuestionId) {
      setState(prev => ({
        ...prev,
        exerciseStates: prev.exerciseStates.map((ex, index) => 
          index === prev.activeExerciseIndex ? {
            ...ex,
            currentQuestionId: 'initial',
            visibleQuestions: ['initial']
          } : ex
        )
      }))
    }
  }, [isTimerActive, timeRemaining, initialDuration, currentExercise.currentQuestionId, setState])

  // Handle scroll on question change with debounce
  useEffect(() => {
    if (currentExercise.currentQuestionId) {
      scrollWithTimeout(() => scrollToQuestion(currentExercise.currentQuestionId!))
    }
  }, [currentExercise.currentQuestionId, scrollToQuestion])
}

================
File: [id]/layout.tsx
================
// app/(features)/exercise-progression/[id]/layout.tsx
'use client'

import { ReactNode } from 'react'


export default function ExerciseLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen bg-slate-50">
      {children}
    </div>
  )
}

================
File: [id]/page.tsx
================
// app/(features)/exercise-progression/[id]/page.tsx
import { ExerciseContainer } from './components/exercise-container'
import { exercises } from './data/exercise-content'
import { notFound } from 'next/navigation'

interface PageProps {
  params: Promise<{
    id: string
  }>
}

export default async function ExercisePage({ params }: PageProps) {
  const { id } = await params;
  const exercise = exercises[id];

  if (!exercise) {
    notFound();
  }

  return <ExerciseContainer exercise={exercise} />;
}

================
File: [id]/types/types.ts
================
// app/(features)/exercise-progression/[id]/components/types.ts

export type ExercisePhase = 'setup' | 'active' | 'questions' | 'complete';

export type SymptomChange = 'better' | 'worse' | 'same';

export interface Exercise {
  id: string;
  name: string;
  duration: number; // in seconds
  imageUrl: string;
  mediaType: 'image' | 'video';
  instructions: {
    setup: string[];
    execution: string[];
    safety: string[];
  };
}

export interface Question {
  id: string;
  text: string;
  options: {
    id: string;
    text: string;
    nextQuestionId?: string | null;
  }[];
}

export interface ExerciseStateItem {
  id: string;
  phase: ExercisePhase;
  timeRemaining: number;
  isTimerActive: boolean;
  currentQuestionId: string | null;
  answers: Record<string, string>;  // questionId -> answerId
  visibleQuestions: string[];      // array of question IDs in order
}

export interface ExerciseState {
  exerciseStates: ExerciseStateItem[];
  activeExerciseIndex: number;
}

export interface ExerciseContainerProps {
  exercise: Exercise;
}

export interface SlideProps {
  exercise: Exercise;
  state: ExerciseStateItem;
  onTimerStart: () => void;
  onTimerStop: () => void;
  onAnswerSelected: (questionId: string, answerId: string) => void;
}

================
File: [id]/utils/exercise-utils.ts
================
import { ExerciseStateItem } from '../types/types'

export function shouldProgressToNextExercise(exercise: ExerciseStateItem): boolean {
  const { initial: initialResponse, location: locationResponse, continue: continueResponse } = exercise.answers
  return (
    continueResponse === 'yes' &&
    (initialResponse === 'better' || initialResponse === 'same') &&
    (locationResponse === 'central' || locationResponse === 'same')
  )
}

export function areAllQuestionsAnswered(exerciseState: ExerciseStateItem): boolean {
  return exerciseState.visibleQuestions.every(questionId => 
    exerciseState.answers[questionId] !== undefined
  )
}

================
File: [id]/utils/scroll-utils.ts
================
export const scrollWithTimeout = (scrollFn: () => void, delay: number = 50) => {
  setTimeout(() => {
    scrollFn()
  }, delay)
}

================
File: api/exercise-progression.service.ts
================
import SupabaseClientSingleton from "@root/lib/supabase/client"
import { v4 as uuidv4 } from 'uuid'

// Types
export interface ExerciseResponse {
  questionId: string
  answerId: string
}

export type ExerciseStatus = 'completed' | 'stopped_early'

export interface ExerciseSession {
  id: string
  series_id: string
  user_id: string
  exercise_id: string
  responses: ExerciseResponse[]
  started_at: string
  completed_at: string
  sequence_number: number
}

export interface ExerciseSeries {
  id: string
  user_id: string
  started_at: string
  completed_at: string
  status: ExerciseStatus
}

export class ExerciseProgressionService {
  private constructor() {}

  private static async getSupabaseClient(token: string) {
    return await SupabaseClientSingleton.getInstance(token)
  }

  private static getUserIdFromToken(token: string): string {
    const payload = JSON.parse(atob(token.split('.')[1]))
    const userId = payload.sub
    if (!userId) {
      throw new Error('No user ID found in token')
    }
    return userId
  }

  static async saveExerciseAttempt(params: {
    sessionId: string
    exerciseId: string
    responses: ExerciseResponse[]
    status: ExerciseStatus
    token: string
    sequenceNumber?: number
  }): Promise<ExerciseSession> {
    try {
      const { sessionId, exerciseId, responses, status, token, sequenceNumber = 1 } = params
      const supabase = await this.getSupabaseClient(token)
      const userId = this.getUserIdFromToken(token)

      // Check if series exists
      const { data: existingSeries } = await supabase
        .from('exercise_series')
        .select('*')
        .eq('id', sessionId)
        .single()

      // Handle series upsert
      const seriesOperation = existingSeries
        ? supabase
            .from('exercise_series')
            .update({
              completed_at: new Date().toISOString(),
              status
            })
            .eq('id', sessionId)
            .select()
        : supabase
            .from('exercise_series')
            .insert({
              id: sessionId,
              user_id: userId,
              started_at: new Date().toISOString(),
              completed_at: new Date().toISOString(),
              status
            })
            .select()

      const { error: seriesError } = await seriesOperation
      if (seriesError) {
        throw seriesError
      }

      // Save exercise session
      const exerciseSessionId = uuidv4()
      const { data, error } = await supabase
        .from('exercise_sessions')
        .insert({
          id: exerciseSessionId,
          series_id: sessionId,
          user_id: userId,
          exercise_id: exerciseId,
          responses,
          started_at: new Date().toISOString(),
          completed_at: new Date().toISOString(),
          sequence_number: sequenceNumber
        })
        .select()
        .single()

      if (error) {
        throw error
      }

      return data
    } catch (error) {
      console.error('Save attempt error:', error)
      throw error
    }
  }

  static async getExerciseSeries(seriesId: string, token: string): Promise<(ExerciseSession & { series: ExerciseSeries })[]> {
    try {
      const supabase = await this.getSupabaseClient(token)
      
      const { data, error } = await supabase
        .from('exercise_sessions')
        .select(`
          *,
          series:exercise_series(*)
        `)
        .eq('series_id', seriesId)
        .order('sequence_number', { ascending: true })

      if (error) {
        throw error
      }

      return data
    } catch (error) {
      console.error('Error fetching exercise series:', error)
      throw error
    }
  }

  // Additional helper methods could be added here
  static async getLatestExerciseSeries(token: string): Promise<ExerciseSeries | null> {
    try {
      const supabase = await this.getSupabaseClient(token)
      const userId = this.getUserIdFromToken(token)
      
      const { data, error } = await supabase
        .from('exercise_series')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(1)
        .single()

      if (error) {
        throw error
      }

      return data
    } catch (error) {
      console.error('Error fetching latest series:', error)
      throw error
    }
  }
}

================
File: utils/get-exercise-content.tsx
================
// app/(features)/exercise-progression/utils/get-exercise-content.tsx
import { exercises } from '../[id]/data/exercise-content'
import { Exercise } from '../[id]/types/types'

export function getExerciseContent(id: string): Exercise {
  const exercise = exercises[id]
  if (!exercise) {
    throw new Error(`Exercise ${id} not found`)
  }
  return exercise
}