This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-05T19:41:45.161Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
supabase/client-singleton.ts
supabase/client-ssr.ts
supabase/errors/supabase.ts
supabase/hooks/test.ts
supabase/services/base.ts
supabase/services/test.ts
supabase/setup-auth-db.md
supabase/types/test.ts
utils.ts

================================================================
Files
================================================================

================
File: supabase/client-singleton.ts
================
import { createClient, SupabaseClient } from '@supabase/supabase-js'

class SupabaseClientSingleton {
  private static instance: SupabaseClient | null = null
  private static currentToken: string | null = null

  private constructor() {}

  static async getInstance(token?: string | null): Promise<SupabaseClient> {
    try {
      // If instance exists and token hasn't changed, return existing instance
      if (this.instance && token === this.currentToken) {
        return this.instance
      }

      // Create new instance with updated token
      this.currentToken = token || null
      this.instance = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: {
            headers: token ? {
              Authorization: `Bearer ${token}`
            } : {}
          },
          auth: {
            persistSession: false
          }
        }
      )

      return this.instance
    } catch (error) {
      console.error('Error getting Supabase instance:', error)
      throw error
    }
  }

  static resetInstance(): void {
    this.instance = null
    this.currentToken = null
  }
}

export default SupabaseClientSingleton

================
File: supabase/client-ssr.ts
================
import { auth } from '@clerk/nextjs/server'
import { createClient } from '@supabase/supabase-js'

export async function createClerkSupabaseClientSsr() {
  // The `useAuth()` hook is used to access the `getToken()` method
  const { getToken } = await auth()

  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!,
    {
      global: {
        // Get the custom Supabase token from Clerk
        fetch: async (url, options = {}) => {
          const clerkToken = await getToken({
            template: 'supabase',
          })

          // Insert the Clerk Supabase token into the headers
          const headers = new Headers(options?.headers)
          headers.set('Authorization', `Bearer ${clerkToken}`)

          // Now call the default fetch
          return fetch(url, {
            ...options,
            headers,
          })
        },
      },
    },
  )
}

================
File: supabase/errors/supabase.ts
================
// src/lib/supabase/errors/supabase.ts

export class SupabaseError extends Error {
    constructor(
      message: string,
      public code: string,
      public status?: number,
      public details?: unknown
    ) {
      super(message)
      this.name = 'SupabaseError'
    }
  
    static fromError(error: unknown): SupabaseError {
      if (error instanceof SupabaseError) {
        return error
      }
  
      // PostgreSQL error codes
      const pgErrorCodes = {
        '23505': 'UNIQUE_VIOLATION',
        '23503': 'FOREIGN_KEY_VIOLATION',
        '42P01': 'UNDEFINED_TABLE',
      }
  
      // Handle Supabase errors
      if (error && typeof error === 'object' && 'code' in error) {
        const code = error.code as string
        const message = 'message' in error ? String(error.message) : 'Unknown error'
        const status = 'status' in error ? Number(error.status) : undefined
        
        return new SupabaseError(
          message,
          pgErrorCodes[code as keyof typeof pgErrorCodes] || code,
          status,
          error
        )
      }
  
      // Handle unknown errors
      return new SupabaseError(
        error instanceof Error ? error.message : 'Unknown error',
        'UNKNOWN_ERROR',
        500,
        error
      )
    }
  }
  
  export const isSupabaseError = (error: unknown): error is SupabaseError => {
    return error instanceof SupabaseError
  }

================
File: supabase/hooks/test.ts
================
// src/lib/supabase/hooks/test.ts

import { useState, useCallback } from 'react'
import { useAuth } from '@clerk/nextjs'
import type { TestItem, CreateTestItem, UpdateTestItem } from '../types/test'
import { testService } from '../services/test'
import { SupabaseError } from '../errors/supabase'

export function useTestItems() {
  const { getToken } = useAuth()
  const [items, setItems] = useState<TestItem[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<SupabaseError | null>(null)

  const fetchItems = useCallback(async () => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const data = await testService.getAll(token)
      setItems(data)
      setError(null)
    } catch (err) {
      setError(SupabaseError.fromError(err))
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const createItem = useCallback(async (item: CreateTestItem) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const newItem = await testService.create(item, token)
      setItems(prev => [...prev, newItem])
      setError(null)
      return newItem
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const updateItem = useCallback(async (id: string, updates: UpdateTestItem) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const updated = await testService.update(id, updates, token)
      setItems(prev => prev.map(item => item.id === id ? updated : item))
      setError(null)
      return updated
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const deleteItem = useCallback(async (id: string) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      await testService.delete(id, token)
      setItems(prev => prev.filter(item => item.id !== id))
      setError(null)
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  return {
    items,
    loading,
    error,
    fetchItems,
    createItem,
    updateItem,
    deleteItem
  }
}

================
File: supabase/services/base.ts
================
// src/lib/supabase/services/base.ts

import { SupabaseClient } from '@supabase/supabase-js'
import { SupabaseError } from '../errors/supabase'
import SupabaseClientSingleton from '../client-singleton'

export abstract class BaseService {
  protected supabase: SupabaseClient | null = null
  
  constructor(protected token?: string | null) {}
  
  protected async getClient(token?: string | null): Promise<SupabaseClient> {
    try {
      this.supabase = await SupabaseClientSingleton.getInstance(token)
      return this.supabase
    } catch (error) {
      throw SupabaseError.fromError(error)
    }
  }

  protected handleError(error: unknown): never {
    throw SupabaseError.fromError(error)
  }

  protected async withErrorHandling<T>(operation: () => Promise<T>): Promise<T> {
    try {
      return await operation()
    } catch (error) {
      this.handleError(error)
    }
  }
}

================
File: supabase/services/test.ts
================
// src/lib/supabase/services/test.ts

import { BaseService } from './base'
import type { TestItem, CreateTestItem, UpdateTestItem } from '../types/test'

export class TestService extends BaseService {
  private readonly table = 'test_items'

  async getAll(token?: string | null): Promise<TestItem[]> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
      
      if (error) throw error
      return data
    })
  }

  async create(item: CreateTestItem, token?: string | null): Promise<TestItem> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      
      // Get the user_id from the JWT claims
      const { data: claims, error: claimsError } = await client.rpc('requesting_user_id')
      if (claimsError) throw claimsError
      if (!claims) throw new Error('No user ID found in JWT claims')

      // Insert with explicit user_id
      const { data, error } = await client
        .from(this.table)
        .insert({ ...item, user_id: claims })
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async update(id: string, updates: UpdateTestItem, token?: string | null): Promise<TestItem> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update(updates)
        .eq('id', id)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async delete(id: string, token?: string | null): Promise<void> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { error } = await client
        .from(this.table)
        .delete()
        .eq('id', id)
      
      if (error) throw error
    })
  }

  async testGetUser() {
    const client = await this.getClient()
    const { data: { user }, error } = await client.auth.getUser()
    
    console.log('User data:', user);
    console.log('Error:', error);
  }
}

export const testService = new TestService()

================
File: supabase/setup-auth-db.md
================
// lib/supabase.ts

/**
 * IMPORTANT: Clerk + Supabase Integration Pattern
 * ----------------------------------------------
 * 
 * When using Clerk authentication with Supabase in this project:
 * 
 * 1. User IDs:
 *    - Clerk uses string IDs (e.g., "user_2rxQpCGXdYW7ZZu3Q9258lZS7o3")
 *    - Never use UUID type for user IDs in Supabase
 *    - Always use TEXT type for user_id columns
 * 
 * 2. Database Tables:
 *    ✅ DO: user_id TEXT NOT NULL
 *    ❌ DON'T: user_id UUID NOT NULL
 * 
 * 3. RLS Policies:
 *    ✅ DO: auth.jwt()->>'sub'
 *    ❌ DON'T: auth.uid()
 * 
 * 4. Storage Bucket Setup:
 *    a. Drop existing policies
 *    b. Ensure owner/owner_id columns are TEXT type
 *    c. Create policies using JWT checks:
 *       USING (
 *         bucket_id = 'your_bucket_name' AND
 *         (auth.jwt()->>'sub')::text IS NOT NULL
 *       )
 * 
 * This pattern prevents UUID/string type mismatches between 
 * Clerk's authentication and Supabase's storage/database systems.
 */

================
File: supabase/types/test.ts
================
// src/lib/supabase/types/test.ts

export interface TestItem {
    id: string
    created_at: string
    content: string
  }
  
  export type CreateTestItem = Omit<TestItem, 'id' | 'created_at'>
  export type UpdateTestItem = Partial<CreateTestItem>

================
File: utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
