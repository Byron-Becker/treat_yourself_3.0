This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T19:47:08.581Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
data/exercise-content.ts
data/posture-content.ts
hooks/use-lesson-progress.ts
hooks/use-lesson.ts
hooks/use-slide-interaction.ts
hooks/use-viewport-scroll.ts
model/lesson-progress.ts
model/slide-interaction.ts
model/viewport-state.ts
services/lesson.service.ts
types/lesson.types.ts

================================================================
Files
================================================================

================
File: data/exercise-content.ts
================
// pacing-lesson.ts
export const exerciseLessonContent = [
    {
      id: '1',
      type: 'info',
      title: 'What\'s the goal of these exercises?',
      body: 'These exercises are not for strengthening-- they are diagnostic tools to guide your recovery.',
      imageUrl: '/proneonelbows.png'
    },
    {
      id: '2',
      type: 'info',
      title: 'Creating The Right Environment',
      body: 'Stop any existing exercises you are currently doing for your low back.  This will help us more clearly determine which exercises are helping or hurting your condition.',
      imageUrl: '/longterm.png'
    },
    {
      id: '3',

      type: 'infoBullet',
      title: 'Understanding Your Exercise Response',
      introduction: 'Several key responses to pay attention to with the exercises:',
      bullets: [
        { text: 'Your pain may appear then gradually diminish' },
        { text: 'Your movement may improve with repetition' },
        { text: 'Your symptoms can increase or decrease' },
        { text: 'Your pain location may change or shift' }
      ],
      imageUrl: '/derangement.png'
    },
    {
      id: '4',
      type: 'infoBullet',
      title: 'What is Centralization?',
      introduction: 'Centralization is the movement of your pain to a more central location:',
      bullets: [
        { text: 'It is the best indicator of recovery' },
        { text: 'Exercises that centralize are the correct movements' },
        { text: 'Exercises that move pain away from the low back are the wrong movements' },
        { text: 'Let the exercises that centralize your pain guide you' }
      ],
      imageUrl: '/centralize.png'
    },

    {
      id: '5',
      type: 'question',
      question: 'Is the pain centralizing?',
      options: [
        { id: '1', text: 'No, the symptoms are moving away from the low back.', isCorrect: true },
        { id: '2', text: 'No, the symptoms are staying the same.', isCorrect: false },
        { id: '3', text: 'Yes, the symptoms move from the back of the thigh to the low back.', isCorrect: false }
      ],
      explanation: 'Remember, centralization is the movement of your pain to a more central location. If your pain is moving away from the low back, it is worsening.',
      imageUrl: '/beforeafter.png'
    },
    {
      id: '6',
      type: 'infoBullet',
      title: 'What is Directional Preference?',
      introduction: 'It\'s the movement direction that improves or centralizes your symptoms:',
      bullets: [
        { text: 'Most common direction is extension (backward bending)' },
        { text: 'Up to 70% of people exhibit a directional preference' },
        { text: 'Using repeated movements in the same direction can help determine the correct direction' },
        { text: 'The exercise module ahead will help guide you to find your directional preference' }
      ],
      imageUrl: '/standflexext.png'
      
    },
    {
      id: '7',
      type: 'question',
      question: 'A person has pain in their lower back and right hip. After performing 10 repetitions of forward bends (flexion), their symptoms have spread to include their lower back, right hip, and right calf. Is flexion their directional preference?',
      options: [
        { id: '1', text: 'Yes, their symptoms are centralizing', isCorrect: false },
        { id: '2', text: 'No, their symptoms are moving away from the low back.', isCorrect: true },
        { id: '3', text: 'Not enough information to determine', isCorrect: false }
      ],
      explanation: 'The answer is no.  The patient symptoms have moved further down into the calf.  This is the opposite of centralization, and tells us that we do not want to continue in that direction.  Remember:  If symptoms move away from the spine, pain intensity increases and remains worse, and/or your range of movement decreases,  you should discontinue the movement in that direction.',
      imageUrl: '/beforeaftercalf.png'
    },

    {
      id: '8',
      type: 'question',
      question: 'The same person now has pain in their low back, right hip, and right calf. After performing 10 repetitions of backward bends (extension), their symptoms are now in the low back and the right hip. Is extension their directional preference?',
      options: [
        { id: '1', text: 'Yes, their symptoms are centralizing', isCorrect: true },
        { id: '2', text: 'No, their symptoms are moving away from the low back.', isCorrect: false },
        { id: '3', text: 'Not enough information to determine', isCorrect: false }
      ],
      explanation: 'The answer is yes!  The right calf no longer has any symptoms, and the pain is back to the original location of the low back and right hip.  This is a centralizing response.  They should continue with extension.',
      imageUrl: '/afterbeforecalf.png'
    },
    {
      id: '9',
      type: 'info',
      title: 'Last but not least...',
      body: 'We understand that was a lot. Feel free to scroll up and review any of the principles we went over. The next module will help guide you through a series of exercises to help you find your directional preference.',
      imageUrl: '/sphinx-pose.png',
      nextRoute: '/exercise-progression/1'
    }
  ]

================
File: data/posture-content.ts
================
// posture-lesson.ts
export const postureLessonContent = [
    {
      id: '1',
      type: 'info',
      title: 'Understanding Posture',
      body: 'Good posture is essential for reducing strain on your body and preventing pain. In this lesson, we\'ll explore what makes good posture and how to maintain it throughout your day.',
      imageUrl: '/goodbadposture.png'
    },
    {
      id: '2',
      type: 'info',
      title: 'The Spine\'s Natural Curves',
      body: 'Your spine has natural curves that help distribute weight and absorb shock. Maintaining these curves while sitting and standing is key to good posture.',
      imageUrl: '/lumbar-good.png'
    },
    {
      id: '3',
      type: 'question',
      question: 'Which of these is a sign of poor posture?',
      options: [
        { id: '1', text: 'Rounded shoulders and forward head position', isCorrect: true },
        { id: '2', text: 'Ears aligned with shoulders when viewed from the side', isCorrect: false },
        { id: '3', text: 'Natural curve in lower back', isCorrect: false }
      ],
      explanation: 'Rounded shoulders and forward head position put extra strain on your neck and upper back muscles. This posture often develops from prolonged computer use or phone viewing.',
      imageUrl: '/posture-good.png'
    },
    {
      id: '4',
      type: 'info',
      title: 'Common Posture Mistakes',
      body: 'Many daily activities can lead to poor posture. Looking down at phones, slouching at desks, and carrying heavy bags on one shoulder are common culprits.',
      imageUrl: '/slouchposture.png'
    },
    {
      id: '5',
      type: 'question',
      question: 'What is the best way to check your standing posture?',
      options: [
        { id: '1', text: 'Stand with your back against a wall, with head, shoulders, and hips touching', isCorrect: true },
        { id: '2', text: 'Look in the mirror while standing normally', isCorrect: false },
        { id: '3', text: 'Ask someone to take a photo of you', isCorrect: false }
      ],
      explanation: 'The wall check provides consistent reference points for alignment. Your head, shoulder blades, and buttocks should touch the wall, with feet about 4 inches from the wall.',
      imageUrl: ''
    }
  ]

================
File: hooks/use-lesson-progress.ts
================
// features/lessons/hooks/use-lesson-progress.ts

import { useState, useCallback } from 'react'
import { useAuth } from '@clerk/nextjs'
import { LessonProgress } from '../model/lesson-progress'
import type { Lesson } from '../types/lesson.types'
import { lessonService } from '../services/lesson.service'

export function useLessonProgress() {
  const { userId, getToken } = useAuth()
  const [lesson, setLesson] = useState<Lesson | null>(null)
  const [progressModel] = useState(() => new LessonProgress())
  const [loading, setLoading] = useState(false)

  const completeSlide = useCallback(async (slideId: string) => {
    if (!userId || !lesson) return

    try {
      setLoading(true)
      progressModel.completeSlide(slideId, lesson.slides.length)
      const token = await getToken({ template: 'supabase' })
      const updatedLesson = await lessonService.completeSlide(
        lesson.id, 
        slideId, 
        token
      )
      setLesson(updatedLesson)
    } finally {
      setLoading(false)
    }
  }, [userId, lesson, getToken, progressModel])

  return {
    lesson,
    progress: progressModel.getProgress(),
    completedSlides: progressModel.getCompletedSlides(),
    currentIndex: progressModel.getCurrentIndex(),
    loading,
    completeSlide
  }
}

================
File: hooks/use-lesson.ts
================
// features/lessons/hooks/use-lesson.ts

import { useLessonProgress } from './use-lesson-progress'
import { useSlideInteraction } from './use-slide-interaction'
import { useViewportScroll } from './use-viewport-scroll'

export function useLesson() {
  const {
    lesson,
    progress,
    completedSlides,
    currentIndex,
    loading,
    completeSlide
  } = useLessonProgress()

  const {
    state: interactionState,
    selectedOption,
    isCorrect,
    hasReviewed,
    canSubmit,
    canViewExplanation,
    handleAnswer,
    showExplanationPanel,
    reset: resetInteraction
  } = useSlideInteraction()

  const {
    updateSlidePosition,
    scrollToSlide,
    activeSlideId,
    lastScrollPosition
  } = useViewportScroll()

  return {
    // Lesson Progress
    lesson,
    progress,
    completedSlides,
    currentIndex,
    loading,
    completeSlide,

    // Interaction State  
    interactionState,
    selectedOption,
    isCorrect,
    hasReviewed,
    canSubmit,
    canViewExplanation,
    handleAnswer,
    showExplanationPanel,
    resetInteraction,

    // Viewport/Scroll
    updateSlidePosition,
    scrollToSlide,
    activeSlideId,
    lastScrollPosition
  }
}

================
File: hooks/use-slide-interaction.ts
================
// features/lessons/hooks/use-slide-interaction.ts

import { useState, useCallback } from 'react'
import { SlideInteraction } from '../model/slide-interaction'

export function useSlideInteraction() {
  const [interactionModel] = useState(() => new SlideInteraction())

  const handleAnswer = useCallback((optionId: string, correctOptionId: string) => {
    interactionModel.selectOption(optionId)
    interactionModel.submit(correctOptionId)
  }, [interactionModel])

  const showExplanationPanel = useCallback(() => {
    interactionModel.viewExplanation()
  }, [interactionModel])

  const reset = useCallback(() => {
    interactionModel.reset()
  }, [interactionModel])

  return {
    state: interactionModel.getState(),
    selectedOption: interactionModel.getSelectedOption(),
    isCorrect: interactionModel.isAnswerCorrect(),
    hasReviewed: interactionModel.hasReviewed(),
    canSubmit: interactionModel.canSubmit(),
    canViewExplanation: interactionModel.canViewExplanation(),
    handleAnswer,
    showExplanationPanel,
    reset
  }
}

================
File: hooks/use-viewport-scroll.ts
================
// features/lessons/hooks/use-viewport-scroll.ts

import { useState, useCallback } from 'react'
import { ViewportState } from '../model/viewport-state'

export function useViewportScroll() {
  const [viewportModel] = useState(() => new ViewportState())

  const updateSlidePosition = useCallback((
    slideId: string, 
    bounds: { top: number; bottom: number }
  ) => {
    viewportModel.updateSlidePosition(slideId, bounds)
  }, [viewportModel])

  const scrollToSlide = useCallback((slideId: string) => {
    const bounds = viewportModel.getSlideBounds(slideId)
    if (!bounds) return

    const scrollPosition = bounds.top
    viewportModel.recordScrollPosition(scrollPosition)
    
    window.scrollTo({
      top: Math.max(0, scrollPosition),
      behavior: 'smooth'
    })
  }, [viewportModel])

  return {
    updateSlidePosition,
    scrollToSlide,
    activeSlideId: viewportModel.getActiveSlideId(),
    lastScrollPosition: viewportModel.getLastScrollPosition()
  }
}

================
File: model/lesson-progress.ts
================
// features/lessons/model/lesson-progress.ts

interface LessonProgressState {
    currentSlideIndex: number
    completedSlideIds: Set<string>
    progress: number
    isStarted: boolean
    isCompleted: boolean
  }
  
  export class LessonProgress {
    private state: LessonProgressState
  
    constructor(initial?: Partial<LessonProgressState>) {
      this.state = {
        currentSlideIndex: initial?.currentSlideIndex ?? 0,
        completedSlideIds: new Set(initial?.completedSlideIds),
        progress: initial?.progress ?? 0,
        isStarted: initial?.isStarted ?? false,
        isCompleted: initial?.isCompleted ?? false
      }
    }
  
    completeSlide(slideId: string, totalSlides: number): void {
      this.state.completedSlideIds.add(slideId)
      this.state.progress = (this.state.completedSlideIds.size / totalSlides) * 100
      
      if (this.state.progress === 100) {
        this.state.isCompleted = true
      }
    }
  
    startLesson(): void {
      if (!this.state.isStarted) {
        this.state.isStarted = true
        this.state.currentSlideIndex = 0
      }
    }
  
    advanceSlide(totalSlides: number): boolean {
      if (this.canAdvance(totalSlides)) {
        this.state.currentSlideIndex++
        return true
      }
      return false
    }
  
    canAdvance(totalSlides: number): boolean {
      return this.state.currentSlideIndex < totalSlides - 1
    }
  
    isSlideCompleted(slideId: string): boolean {
      return this.state.completedSlideIds.has(slideId)
    }
  
    getProgress(): number {
      return this.state.progress
    }
  
    getCurrentIndex(): number {
      return this.state.currentSlideIndex
    }
  
    getCompletedSlides(): string[] {
      return Array.from(this.state.completedSlideIds)
    }
  
    isLessonComplete(): boolean {
      return this.state.isCompleted
    }
  
    toJSON() {
      return {
        currentSlideIndex: this.state.currentSlideIndex,
        completedSlideIds: Array.from(this.state.completedSlideIds),
        progress: this.state.progress,
        isStarted: this.state.isStarted,
        isCompleted: this.state.isCompleted
      }
    }
  }

================
File: model/slide-interaction.ts
================
// features/lessons/model/slide-interaction.ts

export type InteractionState = 'viewing' | 'answering' | 'reviewing' | 'explaining'

interface SlideInteractionState {
 state: InteractionState
 selectedOptionId: string | null
 hasSubmitted: boolean 
 hasViewedExplanation: boolean
 isCorrect: boolean | null
}

export class SlideInteraction {
 private state: SlideInteractionState

 constructor(initial?: Partial<SlideInteractionState>) {
   this.state = {
     state: initial?.state ?? 'viewing',
     selectedOptionId: initial?.selectedOptionId ?? null,
     hasSubmitted: initial?.hasSubmitted ?? false,
     hasViewedExplanation: initial?.hasViewedExplanation ?? false,
     isCorrect: initial?.isCorrect ?? null
   }
 }

 selectOption(optionId: string): void {
   if (this.state.state === 'answering') {
     this.state.selectedOptionId = optionId
   }
 }

 submit(correctOptionId: string): void {
   if (!this.state.selectedOptionId) return

   this.state.hasSubmitted = true
   this.state.isCorrect = this.state.selectedOptionId === correctOptionId
   this.state.state = 'reviewing'
 }

 startAnswering(): void {
   this.state.state = 'answering'
 }

 viewExplanation(): void {
   this.state.state = 'explaining'
   this.state.hasViewedExplanation = true
 }

 reset(): void {
   this.state.state = 'answering'
   this.state.selectedOptionId = null
   this.state.hasSubmitted = false
   this.state.isCorrect = null
 }

 canSubmit(): boolean {
   return !!this.state.selectedOptionId && !this.state.hasSubmitted
 }

 canViewExplanation(): boolean {
   return this.state.hasSubmitted && !this.state.hasViewedExplanation
 }
 
 getState(): InteractionState {
   return this.state.state
 }

 getSelectedOption(): string | null {
   return this.state.selectedOptionId
 }

 isAnswerCorrect(): boolean | null {
   return this.state.isCorrect
 }

 hasReviewed(): boolean {
   return this.state.hasViewedExplanation
 }

 toJSON() {
   return { ...this.state }
 }
}

================
File: model/viewport-state.ts
================
// features/lessons/model/viewport-state.ts

interface ViewportBounds {
    top: number
    bottom: number
   }
   
   interface SlidePosition {
    slideId: string
    bounds: ViewportBounds
    isActive: boolean
   }
   
   export class ViewportState {
    private slidePositions: Map<string, SlidePosition>
    private activeSlideId: string | null
    private lastScrollPosition: number
   
    constructor() {
      this.slidePositions = new Map()
      this.activeSlideId = null
      this.lastScrollPosition = 0
    }
   
    updateSlidePosition(slideId: string, bounds: ViewportBounds): void {
      this.slidePositions.set(slideId, {
        slideId,
        bounds,
        isActive: false
      })
    }
   
    setActiveSlide(slideId: string): void {
      this.activeSlideId = slideId
      this.slidePositions.forEach(position => {
        position.isActive = position.slideId === slideId
      })
    }
   
    isSlideVisible(slideId: string, viewportBounds: ViewportBounds): boolean {
      const position = this.slidePositions.get(slideId)
      if (!position) return false
   
      return (
        position.bounds.bottom >= viewportBounds.top && 
        position.bounds.top <= viewportBounds.bottom
      )
    }
   
    recordScrollPosition(position: number): void {
      this.lastScrollPosition = position
    }
   
    getLastScrollPosition(): number {
      return this.lastScrollPosition
    }
   
    getActiveSlideId(): string | null {
      return this.activeSlideId
    }
   
    getSlideBounds(slideId: string): ViewportBounds | null {
      return this.slidePositions.get(slideId)?.bounds ?? null
    }
   
    toJSON() {
      return {
        positions: Array.from(this.slidePositions.entries()),
        activeSlideId: this.activeSlideId,
        lastScrollPosition: this.lastScrollPosition
      }
    }
   }

================
File: services/lesson.service.ts
================
// features/lessons/services/lesson.service.ts

import { BaseService } from '@/lib/supabase/services/base'
import type { Lesson, CreateLesson, UpdateLesson } from '../types/lesson.types'

export class LessonService extends BaseService {
  private readonly table = 'lessons'

  async getLesson(lessonId: string, token?: string | null): Promise<Lesson | null> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
        .eq('id', lessonId)
        .maybeSingle()
      
      if (error) throw error
      return data
    })
  }

  async getLessonProgress(userId: string, lessonId: string, token?: string | null): Promise<Lesson | null> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
        .eq('id', lessonId)
        .eq('user_id', userId)
        .maybeSingle()

      if (error) throw error
      return data
    })
  }

  async createLessonProgress(lesson: CreateLesson, token?: string | null): Promise<Lesson> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)

      // Get the user_id from the JWT claims
      const { data: claims, error: claimsError } = await client.rpc('requesting_user_id')
      if (claimsError) throw claimsError
      if (!claims) throw new Error('No user ID found in JWT claims')

      const { data, error } = await client
        .from(this.table)
        .insert({ ...lesson, user_id: claims })
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async updateLessonProgress(
    lessonId: string, 
    updates: UpdateLesson, 
    token?: string | null
  ): Promise<Lesson> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update({ 
          ...updates, 
          updated_at: new Date().toISOString() 
        })
        .eq('id', lessonId)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async completeSlide(
    lessonId: string,
    slideId: string,
    token?: string | null
  ): Promise<Lesson> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      
      // First get the current lesson to update completed slides
      const { data: currentLesson, error: fetchError } = await client
        .from(this.table)
        .select('*')
        .eq('id', lessonId)
        .single()

      if (fetchError) throw fetchError

      const completedSlideIds = new Set([
        ...currentLesson.completedSlideIds,
        slideId
      ])

      // Calculate new progress
      const totalSlides = currentLesson.slides.length
      const progress = (completedSlideIds.size / totalSlides) * 100

      // Update the lesson
      const { data, error } = await client
        .from(this.table)
        .update({
          completedSlideIds: Array.from(completedSlideIds),
          progress,
          updated_at: new Date().toISOString()
        })
        .eq('id', lessonId)
        .select()
        .single()

      if (error) throw error
      return data
    })
  }
}

export const lessonService = new LessonService()

================
File: types/lesson.types.ts
================
// features/lessons/types/lesson.types.ts

export interface BaseSlide {
    id: string
    type: SlideType
    nextRoute?: string
  }
  
  export type SlideType = 'info' | 'question' | 'infoBullet'
  
  export interface InfoSlide extends BaseSlide {
    type: 'info'
    title: string
    body: string
    imageUrl?: string
  }
  
  export interface QuestionSlide extends BaseSlide {
    type: 'question'
    question: string
    options: QuestionOption[]
    explanation?: string
    imageUrl?: string
  }
  
  export interface InfoBulletSlide extends BaseSlide {
    type: 'infoBullet'
    title: string
    introduction?: string
    bullets: BulletPoint[]
    imageUrl?: string
  }
  
  export interface QuestionOption {
    id: string
    text: string
    isCorrect: boolean
  }
  
  export interface BulletPoint {
    text: string
  }
  
  export type Slide = InfoSlide | QuestionSlide | InfoBulletSlide
  
  export interface Lesson {
    id: string
    title: string
    description?: string
    slides: Slide[]
    progress: number
    currentSlideIndex: number
    completedSlideIds: string[]
    createdAt: string
    updatedAt: string
    userId: string
  }
  
  export type CreateLesson = Omit<Lesson, 'id' | 'createdAt' | 'updatedAt'>
  export type UpdateLesson = Partial<Omit<Lesson, 'id' | 'userId' | 'createdAt' | 'updatedAt'>>
