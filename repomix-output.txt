This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-07T20:26:47.377Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
errors/base.ts
errors/codes.ts
errors/handlers.ts
supabase/client-singleton.ts
supabase/client-ssr.ts
supabase/errors/supabase.ts
supabase/hooks/example-hook.ts
supabase/README-supa.md
supabase/services/base.ts
supabase/services/example-service.ts
supabase/setup-auth-db.md
supabase/types/example-types.ts

================================================================
Files
================================================================

================
File: errors/base.ts
================
import { ErrorCode } from './codes'

export class AppError extends Error {
  constructor(
    message: string,
    public code: ErrorCode,
    public status: number = 500,
    public details?: unknown,
    public timestamp: Date = new Date()
  ) {
    super(message)
    this.name = 'AppError'
    // Maintains proper stack trace for where error was thrown (if available)
    if (Error.captureStackTrace && typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor)
    } else {
      this.stack = new Error().stack
    }
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      status: this.status,
      details: this.details,
      timestamp: this.timestamp,
      stack: this.stack
    }
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.VALIDATION_ERROR, 400, details)
    this.name = 'ValidationError'
  }
}

export class AuthError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.AUTH_ERROR, 401, details)
    this.name = 'AuthError'
  }
}

export class NotFoundError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.NOT_FOUND, 404, details)
    this.name = 'NotFoundError'
  }
}

export class NetworkError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.NETWORK_ERROR, 503, details)
    this.name = 'NetworkError'
  }
}

export const isAppError = (error: unknown): error is AppError => {
  return error instanceof AppError
}

================
File: errors/codes.ts
================
export enum ErrorCode {
  // Authentication & Authorization
  AUTH_ERROR = 'AUTH_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  
  // Validation & Data
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INVALID_INPUT = 'INVALID_INPUT',
  NOT_FOUND = 'NOT_FOUND',
  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',
  
  // Network & External Services
  NETWORK_ERROR = 'NETWORK_ERROR',
  API_ERROR = 'API_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT = 'TIMEOUT',
  
  // Database
  DB_ERROR = 'DB_ERROR',
  QUERY_ERROR = 'QUERY_ERROR',
  
  // Application
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  NOT_IMPLEMENTED = 'NOT_IMPLEMENTED'
}

================
File: errors/handlers.ts
================
import { type ToastProps } from '@/components/ui/toast'
import { useToast } from '@/hooks/use-toast'
import { AppError } from './base'
import { ErrorCode } from './codes'

interface ErrorToastConfig {
  [key: string]: {
    title: string
    variant: ToastProps['variant']
  }
}

const ERROR_TOAST_CONFIG: ErrorToastConfig = {
  [ErrorCode.AUTH_ERROR]: {
    title: 'Authentication Error',
    variant: 'destructive',
  },
  [ErrorCode.VALIDATION_ERROR]: {
    title: 'Validation Error',
    variant: 'destructive',
  },
  [ErrorCode.NETWORK_ERROR]: {
    title: 'Network Error',
    variant: 'destructive',
  },
  [ErrorCode.NOT_FOUND]: {
    title: 'Not Found',
    variant: 'destructive',
  },
  DEFAULT: {
    title: 'Error',
    variant: 'destructive',
  },
}

export function logError(error: unknown) {
  if (error instanceof AppError) {
    console.error(`[${error.code}] ${error.message}`, {
      details: error.details,
      timestamp: error.timestamp,
      stack: error.stack,
    })
  } else {
    console.error('Unhandled error:', error)
  }
}

export function useErrorHandler() {
  const { toast } = useToast()

  return (error: unknown) => {
    // Log the error
    logError(error)

    // Show toast notification
    if (error instanceof AppError) {
      const config = ERROR_TOAST_CONFIG[error.code] || ERROR_TOAST_CONFIG.DEFAULT
      toast({
        title: config.title,
        description: error.message,
        variant: config.variant,
      })
      return
    }

    // Handle unknown errors
    toast({
      title: ERROR_TOAST_CONFIG.DEFAULT.title,
      description: 'An unexpected error occurred',
      variant: 'destructive',
    })
  }
}

// API error handler middleware
export async function apiErrorHandler(error: unknown) {
  if (error instanceof AppError) {
    return new Response(JSON.stringify(error.toJSON()), {
      status: error.status,
      headers: { 'Content-Type': 'application/json' },
    })
  }

  const appError = new AppError(
    'An unexpected error occurred',
    ErrorCode.INTERNAL_ERROR,
    500,
    error
  )
  
  return new Response(JSON.stringify(appError.toJSON()), {
    status: 500,
    headers: { 'Content-Type': 'application/json' },
  })
}

================
File: supabase/client-singleton.ts
================
import { createClient, SupabaseClient } from '@supabase/supabase-js'

class SupabaseClientSingleton {
  private static instance: SupabaseClient | null = null
  private static currentToken: string | null = null

  private constructor() {}

  static async getInstance(token?: string | null): Promise<SupabaseClient> {
    try {
      // If instance exists and token hasn't changed, return existing instance
      if (this.instance && token === this.currentToken) {
        return this.instance
      }

      // Create new instance with updated token
      this.currentToken = token || null
      this.instance = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: {
            headers: token ? {
              Authorization: `Bearer ${token}`
            } : {}
          },
          auth: {
            persistSession: false
          }
        }
      )

      return this.instance
    } catch (error) {
      console.error('Error getting Supabase instance:', error)
      throw error
    }
  }

  static resetInstance(): void {
    this.instance = null
    this.currentToken = null
  }
}

export default SupabaseClientSingleton

================
File: supabase/client-ssr.ts
================
import { auth } from '@clerk/nextjs/server'
import { createClient } from '@supabase/supabase-js'

export async function createClerkSupabaseClientSsr() {
  // The `useAuth()` hook is used to access the `getToken()` method
  const { getToken } = await auth()

  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!,
    {
      global: {
        // Get the custom Supabase token from Clerk
        fetch: async (url, options = {}) => {
          const clerkToken = await getToken({
            template: 'supabase',
          })

          // Insert the Clerk Supabase token into the headers
          const headers = new Headers(options?.headers)
          headers.set('Authorization', `Bearer ${clerkToken}`)

          // Now call the default fetch
          return fetch(url, {
            ...options,
            headers,
          })
        },
      },
    },
  )
}

================
File: supabase/errors/supabase.ts
================
// src/lib/supabase/errors/supabase.ts

export class SupabaseError extends Error {
    constructor(
      message: string,
      public code: string,
      public status?: number,
      public details?: unknown
    ) {
      super(message)
      this.name = 'SupabaseError'
    }
  
    static fromError(error: unknown): SupabaseError {
      if (error instanceof SupabaseError) {
        return error
      }
  
      // PostgreSQL error codes
      const pgErrorCodes = {
        '23505': 'UNIQUE_VIOLATION',
        '23503': 'FOREIGN_KEY_VIOLATION',
        '42P01': 'UNDEFINED_TABLE',
      }
  
      // Handle Supabase errors
      if (error && typeof error === 'object' && 'code' in error) {
        const code = error.code as string
        const message = 'message' in error ? String(error.message) : 'Unknown error'
        const status = 'status' in error ? Number(error.status) : undefined
        
        return new SupabaseError(
          message,
          pgErrorCodes[code as keyof typeof pgErrorCodes] || code,
          status,
          error
        )
      }
  
      // Handle unknown errors
      return new SupabaseError(
        error instanceof Error ? error.message : 'Unknown error',
        'UNKNOWN_ERROR',
        500,
        error
      )
    }
  }
  
  export const isSupabaseError = (error: unknown): error is SupabaseError => {
    return error instanceof SupabaseError
  }

================
File: supabase/hooks/example-hook.ts
================
// src/lib/supabase/hooks/test.ts

import { useState, useCallback } from 'react'
import { useAuth } from '@clerk/nextjs'
import type { TestItem, CreateTestItem, UpdateTestItem } from '../types/example-types'
import { testService } from '../services/example-service'
import { SupabaseError } from '../errors/supabase'

export function useTestItems() {
  const { getToken } = useAuth()
  const [items, setItems] = useState<TestItem[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<SupabaseError | null>(null)

  const fetchItems = useCallback(async () => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const data = await testService.getAll(token)
      setItems(data)
      setError(null)
    } catch (err) {
      setError(SupabaseError.fromError(err))
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const createItem = useCallback(async (item: CreateTestItem) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const newItem = await testService.create(item, token)
      setItems(prev => [...prev, newItem])
      setError(null)
      return newItem
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const updateItem = useCallback(async (id: string, updates: UpdateTestItem) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const updated = await testService.update(id, updates, token)
      setItems(prev => prev.map(item => item.id === id ? updated : item))
      setError(null)
      return updated
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const deleteItem = useCallback(async (id: string) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      await testService.delete(id, token)
      setItems(prev => prev.filter(item => item.id !== id))
      setError(null)
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  return {
    items,
    loading,
    error,
    fetchItems,
    createItem,
    updateItem,
    deleteItem
  }
}

================
File: supabase/README-supa.md
================
// src/lib/supabase/README.md

# Data Fetching Enhancements

## SWR/React Query Integration

When scaling the application, consider adding SWR or React Query for:
- Automatic caching
- Background revalidation
- Optimistic updates
- Request deduplication
- Offline support

### Implementation Location:
```
src/lib/supabase/
  ├── hooks/              
  │   ├── base.ts        # Add base hook with SWR/Query config
  │   └── [domain].ts    # Domain hooks extend base hook
```

### Example Pattern:
```typescript
// hooks/base.ts
import useSWR from 'swr'

export function useQuery<T>(key: string, fetcher: () => Promise<T>) {
  return useSWR(key, fetcher, {
    revalidateOnFocus: false,
    dedupingInterval: 2000
  })
}

// hooks/[domain].ts
export function useItems() {
  const { data, error, mutate } = useQuery(
    'items', 
    () => itemsService.getAll()
  )
  // ... rest of hook logic
}
```

Choose SWR for lighter needs, React Query for more complex requirements.

================
File: supabase/services/base.ts
================
// src/lib/supabase/services/base.ts

import { SupabaseClient } from '@supabase/supabase-js'
import { SupabaseError } from '../errors/supabase'
import SupabaseClientSingleton from '../client-singleton'

export abstract class BaseService {
  protected supabase: SupabaseClient | null = null
  
  constructor(protected token?: string | null) {}
  
  protected async getClient(token?: string | null): Promise<SupabaseClient> {
    try {
      this.supabase = await SupabaseClientSingleton.getInstance(token)
      return this.supabase
    } catch (error) {
      throw SupabaseError.fromError(error)
    }
  }

  protected handleError(error: unknown): never {
    throw SupabaseError.fromError(error)
  }

  protected async withErrorHandling<T>(operation: () => Promise<T>): Promise<T> {
    try {
      return await operation()
    } catch (error) {
      this.handleError(error)
    }
  }
}

================
File: supabase/services/example-service.ts
================
// src/lib/supabase/services/test.ts

import { BaseService } from './base'
import type { TestItem, CreateTestItem, UpdateTestItem } from '../types/example-types'

export class TestService extends BaseService {
  private readonly table = 'test_items'

  async getAll(token?: string | null): Promise<TestItem[]> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
      
      if (error) throw error
      return data
    })
  }

  async create(item: CreateTestItem, token?: string | null): Promise<TestItem> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      
      // Get the user_id from the JWT claims
      const { data: claims, error: claimsError } = await client.rpc('requesting_user_id')
      if (claimsError) throw claimsError
      if (!claims) throw new Error('No user ID found in JWT claims')

      // Insert with explicit user_id
      const { data, error } = await client
        .from(this.table)
        .insert({ ...item, user_id: claims })
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async update(id: string, updates: UpdateTestItem, token?: string | null): Promise<TestItem> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update(updates)
        .eq('id', id)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async delete(id: string, token?: string | null): Promise<void> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { error } = await client
        .from(this.table)
        .delete()
        .eq('id', id)
      
      if (error) throw error
    })
  }

  async testGetUser() {
    const client = await this.getClient()
    const { data: { user }, error } = await client.auth.getUser()
    
    console.log('User data:', user);
    console.log('Error:', error);
  }
}

export const testService = new TestService()

================
File: supabase/setup-auth-db.md
================
// lib/supabase.ts

/**
 * IMPORTANT: Clerk + Supabase Integration Pattern
 * ----------------------------------------------
 * 
 * When using Clerk authentication with Supabase in this project:
 * 
 * 1. User IDs:
 *    - Clerk uses string IDs (e.g., "user_2rxQpCGXdYW7ZZu3Q9258lZS7o3")
 *    - Never use UUID type for user IDs in Supabase
 *    - Always use TEXT type for user_id columns
 * 
 * 2. Database Tables:
 *    ✅ DO: user_id TEXT NOT NULL
 *    ❌ DON'T: user_id UUID NOT NULL
 * 
 * 3. RLS Policies:
 *    ✅ DO: auth.jwt()->>'sub'
 *    ❌ DON'T: auth.uid()
 * 
 * 4. Storage Bucket Setup:
 *    a. Drop existing policies
 *    b. Ensure owner/owner_id columns are TEXT type
 *    c. Create policies using JWT checks:
 *       USING (
 *         bucket_id = 'your_bucket_name' AND
 *         (auth.jwt()->>'sub')::text IS NOT NULL
 *       )
 * 
 * This pattern prevents UUID/string type mismatches between 
 * Clerk's authentication and Supabase's storage/database systems.
 */

================
File: supabase/types/example-types.ts
================
// src/lib/supabase/types/test.ts

export interface TestItem {
    id: string
    created_at: string
    content: string
  }
  
  export type CreateTestItem = Omit<TestItem, 'id' | 'created_at'>
  export type UpdateTestItem = Partial<CreateTestItem>



================================================================
End of Codebase
================================================================
