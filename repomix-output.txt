This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T04:29:52.549Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/profile-form.tsx
components/profile-view.tsx
hooks/use-profile.ts
layout.tsx
page.tsx
services/profile.service.ts
types/profile.types.ts

================================================================
Files
================================================================

================
File: components/profile-form.tsx
================
'use client'

import { useState, useEffect } from 'react'
import { useProfile } from '../hooks/use-profile'
import type { UpdateUserProfile } from '../types/profile.types'

interface ProfileFormProps {
  onSuccess?: () => void
}

export function ProfileForm({ onSuccess }: ProfileFormProps) {
  const { profile, updateProfile, loading } = useProfile()
  const [formData, setFormData] = useState<UpdateUserProfile>({
    display_name: profile?.display_name || '',
    bio: profile?.bio || '',
    timezone: profile?.timezone || '',
  })

  useEffect(() => {
    if (profile) {
      setFormData({
        display_name: profile.display_name || '',
        bio: profile.bio || '',
        timezone: profile.timezone || '',
      })
    }
  }, [profile])

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({ ...prev, [name]: value }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    try {
      const updatedProfile = await updateProfile(formData)
      if (updatedProfile) {
        onSuccess?.()
      }
    } catch (error) {
      console.error('Failed to update profile:', error)
    }
  }

  if (!profile) return null

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <label htmlFor="display_name" className="block text-sm font-medium text-gray-700">
          Display Name
        </label>
        <input
          type="text"
          id="display_name"
          name="display_name"
          value={formData.display_name}
          onChange={handleChange}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
          required
        />
      </div>

      <div>
        <label htmlFor="bio" className="block text-sm font-medium text-gray-700">
          Bio
        </label>
        <textarea
          id="bio"
          name="bio"
          rows={3}
          value={formData.bio || ''}
          onChange={handleChange}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
        />
      </div>

      <div>
        <label htmlFor="timezone" className="block text-sm font-medium text-gray-700">
          Timezone
        </label>
        <input
          type="text"
          id="timezone"
          name="timezone"
          value={formData.timezone || ''}
          onChange={handleChange}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
        />
      </div>

      <div className="flex justify-end">
        <button
          type="submit"
          disabled={loading}
          className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {loading ? 'Saving...' : 'Save Changes'}
        </button>
      </div>
    </form>
  )
}

================
File: components/profile-view.tsx
================
// src/features/user-profile/components/profile-view.tsx

'use client'

import { useState } from 'react'
import { useProfile } from '../hooks/use-profile'
import { ProfileForm } from './profile-form'

export function ProfileView() {
  const { profile, loading, error } = useProfile()
  const [isEditing, setIsEditing] = useState(false)

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[200px]">
        <div className="text-gray-500">Loading profile...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 p-4 rounded-md">
        <div className="text-red-700">Error loading profile: {error.message}</div>
      </div>
    )
  }

  if (!profile) {
    return (
      <div className="bg-yellow-50 p-4 rounded-md">
        <div className="text-yellow-700">No profile found. One will be created automatically.</div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="bg-white shadow sm:rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          {!isEditing ? (
            <div className="space-y-4">
              <div className="flex justify-between items-start">
                <h3 className="text-lg font-medium leading-6 text-gray-900">Your Profile</h3>
                <button
                  onClick={() => setIsEditing(true)}
                  className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                >
                  Edit Profile
                </button>
              </div>
              <div className="mt-4 space-y-4">
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Display Name</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.display_name || 'Not set'}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Email</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.email || 'Not set'}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Bio</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.bio || 'Not set'}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Timezone</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.timezone || 'Not set'}</p>
                </div>
              </div>
            </div>
          ) : (
            <div>
              <div className="flex justify-between items-start mb-4">
                <h3 className="text-lg font-medium leading-6 text-gray-900">Edit Profile</h3>
                <button
                  onClick={() => setIsEditing(false)}
                  className="inline-flex justify-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                >
                  Cancel
                </button>
              </div>
              <ProfileForm onSuccess={() => setIsEditing(false)} />
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

================
File: hooks/use-profile.ts
================
// src/features/user-profile/hooks/use-profile.ts

import { useState, useCallback, useEffect, useRef, useMemo } from 'react'
import { useAuth, useUser } from '@clerk/nextjs'
import type { UserProfile, UpdateUserProfile } from '../types/profile.types'
import { userProfileService } from '../services/profile.service'
import { SupabaseError } from '@/lib/supabase/errors/supabase'
import { useErrorHandler } from '@/lib/errors/handlers'

export function useProfile() {
  const isMounted = useRef(false)
  const fetchInProgress = useRef(false)
  const { userId, getToken } = useAuth()
  const { user } = useUser()
  const [profile, setProfile] = useState<UserProfile | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<SupabaseError | null>(null)
  const handleError = useErrorHandler()

  const authState = useMemo(() => ({
    userId,
    user,
    getToken
  }), [userId, user, getToken])

  const fetchProfile = useCallback(async () => {
    if (!authState.userId || fetchInProgress.current) {
      return
    }

    try {
      fetchInProgress.current = true
      setLoading(true)
      setError(null)
      const token = await authState.getToken({ template: 'supabase' })
      let data = await userProfileService.getProfile(authState.userId, token)
      
      if (!data && authState.user) {
        const newProfile = {
          id: authState.userId,
          display_name: authState.user.username || 
                       authState.user.firstName && authState.user.lastName ? 
                       `${authState.user.firstName} ${authState.user.lastName}` :
                       authState.user.firstName || 'New User',
          email: authState.user.primaryEmailAddress?.emailAddress || '',
          avatar_url: authState.user.imageUrl || undefined,
        }
        data = await userProfileService.createProfile(newProfile, token)
      }

      if (isMounted.current) {
        setProfile(data)
      }
    } catch (err) {
      if (isMounted.current) {
        const supabaseError = SupabaseError.fromError(err)
        setError(supabaseError)
        handleError(supabaseError)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
      fetchInProgress.current = false
    }
  }, [authState, handleError])

  const updateProfile = useCallback(async (updates: UpdateUserProfile) => {
    if (!authState.userId || !profile) return

    // Optimistic update
    const previousProfile = profile
    const optimisticProfile = { ...profile, ...updates }
    setProfile(optimisticProfile)

    try {
      setLoading(true)
      const token = await authState.getToken({ template: 'supabase' })
      const updated = await userProfileService.updateProfile(authState.userId, updates, token)
      
      if (isMounted.current) {
        // Update with actual server response
        setProfile(updated)
      }
      return updated
    } catch (err) {
      // Revert to previous state on error
      if (isMounted.current) {
        setProfile(previousProfile)
        const supabaseError = SupabaseError.fromError(err)
        setError(supabaseError)
        handleError(supabaseError)
      }
      throw err
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, [authState, handleError, profile])

  useEffect(() => {
    isMounted.current = true
    
    if (authState.userId && !profile && !error) {
      fetchProfile()
    }

    return () => {
      isMounted.current = false
    }
  }, [authState.userId, profile, error, fetchProfile])

  return {
    profile,
    loading,
    error,
    fetchProfile,
    updateProfile,
    user: authState.user
  }
}

================
File: layout.tsx
================
// src/app/profile/page.tsx
'use client'

import { ProfileView } from './components/profile-view'


export default function ProfilePage() {
  return (
    <div className="max-w-2xl mx-auto">
      <ProfileView />
    </div>
  )
}

================
File: page.tsx
================
// src/app/(authenticated)/profile/page.tsx
'use client'

import { ProfileView } from './components/profile-view'


export default function ProfilePage() {
  return (
    <div className="max-w-2xl mx-auto">
      <ProfileView />
    </div>
  )
}

================
File: services/profile.service.ts
================
// src/features/user-profile/services/profile.service.ts

import { BaseService } from '@/lib/supabase/services/base'
import type { UserProfile, CreateUserProfile, UpdateUserProfile } from '../types/profile.types'

export class UserProfileService extends BaseService {
  private readonly table = 'user_profiles'

  async getProfile(userId: string, token?: string | null): Promise<UserProfile | null> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
        .eq('id', userId)
        .maybeSingle()
      
      if (error) throw error
      return data
    })
  }

  async createProfile(profile: CreateUserProfile & { id: string }, token?: string | null): Promise<UserProfile> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)

      const { data, error } = await client
        .from(this.table)
        .insert(profile)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async updateProfile(userId: string, updates: UpdateUserProfile, token?: string | null): Promise<UserProfile> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update({ ...updates, updated_at: new Date().toISOString() })
        .eq('id', userId)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }
}

export const userProfileService = new UserProfileService()

================
File: types/profile.types.ts
================
// src/features/user-profile/types/profile.types.ts
// Basic interfaces for our domain model

export interface UserProfile {
    id: string               // Clerk user id
    display_name: string      
    email: string           // Clerk email
    bio?: string            // Optional in first iteration
    avatar_url?: string      // Optional in first iteration
    timezone?: string       // Optional in first iteration
    created_at: string
    updated_at: string
  }
  
  // For creating a new profile
  export type CreateUserProfile = Omit<UserProfile, 'id' | 'created_at' | 'updated_at'> 
  
  // For updating an existing profile
  export type UpdateUserProfile = Partial<Omit<UserProfile, 'id' | 'email' | 'created_at' | 'updated_at'>>
