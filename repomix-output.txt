This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
[id]/page.tsx
components/exercise-container.tsx
components/exercise-footer.tsx
components/exercise-header.tsx
components/index.ts
components/loading-overlay.tsx
components/slides/instruction-slide.tsx
components/slides/question-slide.tsx
components/slides/setup-slide.tsx
data/exercise-content.ts
data/index.ts
hooks/index.ts
hooks/use-exercise-scroll.ts
hooks/use-exercise-timer.ts
hooks/use-progression-state.ts
hooks/use-response-handler.ts
hooks/use-timer-state.ts
hooks/use-timer.ts
layout.tsx
metadata.ts
model/exercise-progression.ts
model/index.ts
model/timer.ts
services/exercise-progression.service.ts
services/index.ts
services/progression-rules.service.ts
store/use-progression-store.ts
types/exercise.types.ts
types/index.ts
types/progression.types.ts
types/question.types.ts
types/response.types.ts
types/timer.types.ts

================================================================
Files
================================================================

================
File: [id]/page.tsx
================
import { ExerciseContainer } from '../components'
import { exercises } from '../data'
import { notFound } from 'next/navigation'
import { Metadata } from 'next'

interface PageProps {
  params: Promise<{
    id: string
  }>
}

export default async function ExercisePage({ params }: PageProps) {
  const { id } = await params
  const exercise = exercises[id]

  if (!exercise) {
    notFound()
  }

  return <ExerciseContainer exercise={exercise} />
}

// Generate metadata for the page
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
  const { id } = await params
  const exercise = exercises[id]

  if (!exercise) {
    return {
      title: 'Exercise Not Found',
      description: 'The requested exercise could not be found.'
    }
  }

  return {
    title: `Exercise: ${exercise.name}`,
    description: `Follow along with the ${exercise.name.toLowerCase()} exercise progression.`
  }
}

// Generate static params for all exercises
export async function generateStaticParams() {
  return Object.keys(exercises).map((id) => ({
    id
  }))
}

================
File: components/exercise-container.tsx
================
'use client'

import { useEffect } from 'react'
import { useAuth } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import { Exercise } from '../types'
import { useProgressionStore } from '../store/use-progression-store'
import { ExerciseHeader } from './exercise-header'
import { ExerciseFooter } from './exercise-footer'
import { SetupSlide } from './slides/setup-slide'
import { InstructionSlide } from './slides/instruction-slide'
import { QuestionSlide } from './slides/question-slide'
import { LoadingOverlay } from './loading-overlay'
import { exercises } from '../data/exercise-content'
import { useExerciseTimer } from '../hooks/use-exercise-timer'
import { useExerciseScroll } from '../hooks/use-exercise-scroll'

interface ExerciseContainerProps {
  exercise: Exercise
}

export function ExerciseContainer({ exercise }: ExerciseContainerProps) {
  const { isLoaded, isSignedIn, getToken } = useAuth()
  const router = useRouter()

  const {
    exercises: exerciseStates,
    currentExerciseIndex,
    status,
    initializeExercise,
    startExercise,
    pauseExercise,
    submitResponse,
  } = useProgressionStore()

  // Initialize hooks
  useExerciseTimer()
  const {
    scrollToQuestion,
    scrollToInstruction,
    scrollToSetup,
    getQuestionRef,
    getInstructionRef,
    getSetupRef,
    scrollWithRetry
  } = useExerciseScroll()

  // Initialize the first exercise
  useEffect(() => {
    const init = async () => {
      if (!isLoaded) {
        console.log('Auth not loaded yet')
        return
      }

      if (!isSignedIn) {
        console.log('User not signed in, redirecting to sign-in')
        router.push('/sign-in')
        return
      }

      try {
        console.log('Getting Supabase token...')
        const token = await getToken({ template: 'supabase' })
        if (!token) {
          console.error('❌ No auth token available')
          return
        }
        console.log('✅ Got auth token:', token.slice(0, 10) + '...')

        console.log('Initializing exercise with token...')
        await initializeExercise(exercise, token)
        console.log('✅ Exercise initialized successfully')
      } catch (error) {
        console.error('❌ Failed to initialize exercise:', error)
        // TODO: Show error message to user
      }
    }
    
    if (isLoaded) {
      init()
    }
  }, [exercise, initializeExercise, isLoaded, isSignedIn, getToken, router])

  // Handle question appearance after 5 seconds
  useEffect(() => {
    const currentExercise = exerciseStates[currentExerciseIndex]
    if (!currentExercise) return

    if (
      currentExercise.isTimerActive && 
      currentExercise.timeRemaining === exercise.duration - 1 &&
      !currentExercise.currentQuestionId
    ) {
      console.log('Adding initial question after 5 seconds')
      submitResponse('initial', '')
    }
  }, [exerciseStates, currentExerciseIndex, exercise.duration, submitResponse])

  // Handle scroll on phase changes
  useEffect(() => {
    const currentExercise = exerciseStates[currentExerciseIndex]
    if (!currentExercise) return

    if (currentExercise.phase === 'active') {
      scrollWithRetry(() => scrollToInstruction())
    }
  }, [currentExerciseIndex, exerciseStates, scrollToInstruction, scrollWithRetry])

  // Handle scroll on question changes
  useEffect(() => {
    const currentExercise = exerciseStates[currentExerciseIndex]
    if (!currentExercise?.currentQuestionId) return

    scrollWithRetry(() => scrollToQuestion(currentExercise.currentQuestionId!))
  }, [currentExerciseIndex, exerciseStates, scrollToQuestion, scrollWithRetry])

  // Handle scroll to new exercise
  useEffect(() => {
    const shouldScroll = useProgressionStore.getState().shouldScrollToNewExercise
    if (shouldScroll) {
      console.log('Scrolling to new exercise:', exerciseStates[currentExerciseIndex]?.id)
      scrollWithRetry(() => scrollToSetup(exerciseStates[currentExerciseIndex]?.id))
      useProgressionStore.setState({ shouldScrollToNewExercise: false })
    }
  }, [currentExerciseIndex, exerciseStates, scrollToSetup, scrollWithRetry])

  // Handle exercise completion
  useEffect(() => {
    const currentExercise = exerciseStates[currentExerciseIndex]
    if (!currentExercise) return

    console.log('Exercise completion check:', {
      status,
      hasStopAnswer: currentExercise.answers['stop'],
      answers: currentExercise.answers
    })

    // Only redirect if explicitly stopped via stop button or negative responses
    if (status === 'stopped_early' && 
        (currentExercise.answers['stop'] === 'return_to_dashboard' || 
         currentExercise.answers['initial'] === 'worse' || 
         currentExercise.answers['location'] === 'peripheral')) {
      console.log('Exercise explicitly stopped via stop button or negative response')
      router.push('/dashboard')
    } else if (status === 'stopped_early') {
      console.log('Exercise status is stopped_early but not from explicit stop - likely a state issue')
    }
  }, [status, exerciseStates, currentExerciseIndex, router])

  // Redirect if not signed in
  if (!isLoaded) return <LoadingOverlay />
  if (!isSignedIn) {
    router.push('/sign-in')
    return null
  }

  const currentExercise = exerciseStates[currentExerciseIndex]
  if (!currentExercise) return <LoadingOverlay />

  return (
    <div className="min-h-[100dvh] flex flex-col">
      <div className="fixed top-0 left-0 right-0 z-50 bg-white border-b">
        <ExerciseHeader 
          name={exercise.name}
          timeRemaining={currentExercise.timeRemaining}
          isActive={currentExercise.isTimerActive}
        />
      </div>

      <main className="flex-1 overflow-y-auto px-4 pb-32 pt-20">
        <div className="max-w-2xl mx-auto">
          {exerciseStates.map((exerciseState) => {
            const exercise = exercises[exerciseState.id]
            
            return (
              <div 
                key={exerciseState.id} 
                className="mb-6"
                ref={getSetupRef(exerciseState.id)}
              >
                <SetupSlide
                  exercise={exercise}
                  state={exerciseState}
                  onTimerStart={startExercise}
                  onTimerStop={pauseExercise}
                  onAnswerSelected={submitResponse}
                />

                {exerciseState.phase !== 'setup' && (
                  <div className="mt-6">
                    <InstructionSlide
                      ref={getInstructionRef}
                      exercise={exercise}
                      state={exerciseState}
                      onTimerStart={startExercise}
                      onTimerStop={pauseExercise}
                      onAnswerSelected={submitResponse}
                    />
                  </div>
                )}

                {exerciseState.visibleQuestions.map((questionId) => (
                  <div key={questionId} className="mt-6">
                    <QuestionSlide
                      ref={getQuestionRef(questionId)}
                      exercise={exercise}
                      state={exerciseState}
                      questionId={questionId}
                      onTimerStart={startExercise}
                      onTimerStop={pauseExercise}
                      onAnswerSelected={submitResponse}
                    />
                  </div>
                ))}
              </div>
            )
          })}
        </div>
      </main>

      <div className="fixed bottom-0 left-0 right-0 z-50 bg-white border-t">
        <ExerciseFooter
          isActive={currentExercise.isTimerActive}
          timeRemaining={currentExercise.timeRemaining}
          onStart={startExercise}
          onStop={pauseExercise}
          canContinue={currentExercise.phase === 'active' && currentExercise.visibleQuestions.length > 0}
        />
      </div>
    </div>
  )
}

================
File: components/exercise-footer.tsx
================
'use client'

import { Button } from "@/components/ui/button"
import { PauseCircle, Play } from 'lucide-react'

interface ExerciseFooterProps {
  isActive: boolean
  timeRemaining: number
  onStart: () => void
  onStop: () => void
  canContinue: boolean
}

export function ExerciseFooter({ 
  isActive, 
  timeRemaining,
  onStart, 
  onStop,
  canContinue
}: ExerciseFooterProps) {
  if (timeRemaining === 0) {
    return (
      <div className="fixed bottom-0 left-0 right-0 p-4 shadow-lg bg-white">
        <div className="max-w-xs mx-auto">
          <Button 
            onClick={onStop}
            className="w-full h-12 text-lg bg-green-500 hover:bg-green-600"
            disabled={!canContinue}
          >
            Complete Exercise
          </Button>
        </div>
      </div>
    )
  }

  return (
    <div className="fixed bottom-0 left-0 right-0 p-4 shadow-lg bg-white">
      <div className="max-w-xs mx-auto">
        {!isActive ? (
          <Button 
            onClick={onStart}
            className="w-full h-12 text-lg bg-green-500 hover:bg-green-500 hover:shadow-sm hover:scale-105 transition-transform"
          >
            <Play className="w-5 h-5 mr-2" style={{ marginRight: '2%' }} />
            <span style={{ marginRight: '8%' }}>Start Exercise</span>
          </Button>
        ) : (
          <Button 
            onClick={onStop}
            variant="destructive"
            className="w-full h-12 text-lg"
          >
            <PauseCircle className="w-5 h-5 mr-2" style={{ marginRight: '2%' }} />
            <span style={{ marginRight: '8%' }}>Stop Exercise</span>
          </Button>
        )}
      </div>
    </div>
  )
}

================
File: components/exercise-header.tsx
================
'use client'

import { motion } from 'framer-motion'
import { UserButton } from '@clerk/nextjs'
import Link from 'next/link'
import { ArrowLeft } from 'lucide-react'

interface ExerciseHeaderProps {
  name: string
  timeRemaining: number
  isActive: boolean
}

export function ExerciseHeader({ name, timeRemaining }: ExerciseHeaderProps) {
  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`
  }

  return (
    <motion.header 
      className="sticky top-0 z-50 bg-white border-b"
      initial={{ y: -100 }}
      animate={{ y: 0 }}
    >
      <div className="flex items-center justify-between p-4">
        <Link 
          href="/dashboard" 
          className="text-gray-600 hover:text-gray-900 transition-colors"
        >
          <ArrowLeft size={24} />
        </Link>
        <div className="flex-grow text-center text-2xl font-bold">
          {name} - {formatTime(timeRemaining)}
        </div>
        <div className="flex items-center">
          <UserButton />
        </div>
      </div>
    </motion.header>
  )
}

================
File: components/index.ts
================
export * from './exercise-container'
export * from './exercise-header'
export * from './exercise-footer'
export * from './loading-overlay'
export * from './slides/setup-slide'
export * from './slides/instruction-slide'
export * from './slides/question-slide'

================
File: components/loading-overlay.tsx
================
'use client'

import { motion } from 'framer-motion'
import { Loader2 } from 'lucide-react'

interface LoadingOverlayProps {
  message?: string
}

export function LoadingOverlay({ message = 'Loading...' }: LoadingOverlayProps) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="fixed inset-0 bg-white/80 backdrop-blur-sm flex items-center justify-center z-50"
    >
      <div className="flex flex-col items-center gap-3">
        <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
        <div className="text-sm text-gray-600">
          {message}
        </div>
      </div>
    </motion.div>
  )
}

================
File: components/slides/instruction-slide.tsx
================
'use client'

import { forwardRef } from 'react'
import { Card } from "@/components/ui/card"
import { AlertCircle } from 'lucide-react'
import { motion } from 'framer-motion'
import { Exercise, ExerciseState } from '../../types'

interface InstructionSlideProps {
  exercise: Exercise
  state: ExerciseState
  onTimerStart: () => void
  onTimerStop: () => void
  onAnswerSelected: (questionId: string, answerId: string) => void
}

export const InstructionSlide = forwardRef<HTMLDivElement, InstructionSlideProps>(
  function InstructionSlide({ exercise }, ref) {
    return (
      <motion.div
        ref={ref}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className="scroll-mt-20"
      >
        <Card className="p-6 space-y-6">
          <div className="space-y-4">
            {/* Execution Instructions */}
            <div className="bg-blue-50 p-4 rounded-lg">
              <h3 className="font-semibold text-lg mb-3">During Exercise</h3>
              <ul className="space-y-2">
                {exercise.instructions.execution.map((instruction, index) => (
                  <li key={index} className="flex items-start gap-3">
                    <span className="text-blue-500">•</span>
                    <span className="text-slate-700">{instruction}</span>
                  </li>
                ))}
              </ul>
            </div>

            {/* Safety Instructions */}
            <div className="bg-red-50 p-4 rounded-lg">
              <div className="flex items-start gap-3">
                <AlertCircle className="w-5 h-5 text-red-500 flex-shrink-0 mt-1" />
                <div>
                  <h3 className="font-semibold text-lg mb-2">Safety Notes</h3>
                  <ul className="space-y-2">
                    {exercise.instructions.safety.map((instruction, index) => (
                      <li key={index} className="text-slate-700">
                        • {instruction}
                      </li>
                    ))}
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </Card>
      </motion.div>
    )
  }
)

================
File: components/slides/question-slide.tsx
================
'use client'

import { Card } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { motion } from 'framer-motion'
import { Exercise, ExerciseState } from '../../types'
import { questions } from '../../data/exercise-content'
import { forwardRef } from 'react'

interface QuestionSlideProps {
  exercise: Exercise
  state: ExerciseState
  questionId: string
  onTimerStart: () => void
  onTimerStop: () => void
  onAnswerSelected: (questionId: string, answerId: string) => void
}

export const QuestionSlide = forwardRef<HTMLDivElement, QuestionSlideProps>(({ 
  state, 
  questionId,
  onAnswerSelected 
}, ref) => {
  const question = questions[questionId]
  const selectedAnswer = state.answers[questionId]

  return (
    <motion.div
      ref={ref}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      className="scroll-mt-20"
    >
      <Card className="p-6 space-y-4">
        <h3 className="text-lg font-semibold">
          {question.text}
        </h3>

        <div className="grid grid-cols-1 gap-3">
          {question.options.map((option) => (
            <Button
              key={option.id}
              variant={selectedAnswer === option.id ? "default" : "outline"}
              className={`w-full justify-start text-left h-auto p-4 ${
                selectedAnswer === option.id ? 'bg-blue-50 border-blue-500 text-blue-700' : ''
              }`}
              onClick={() => {
                if (!selectedAnswer) {
                  onAnswerSelected(questionId, option.id)
                }
              }}
            >
              {option.text}
            </Button>
          ))}
        </div>
      </Card>
    </motion.div>
  )
}) as React.ForwardRefExoticComponent<QuestionSlideProps & React.RefAttributes<HTMLDivElement>>;

// Add display name for the component
QuestionSlide.displayName = 'QuestionSlide';

================
File: components/slides/setup-slide.tsx
================
'use client'

import Image from 'next/image'
import { Card } from "@/components/ui/card"
import { CheckCircle } from 'lucide-react'
import { motion } from 'framer-motion'
import { Exercise, ExerciseState } from '../../types'
import { useEffect, useState } from 'react'

interface SetupSlideProps {
  exercise: Exercise
  state: ExerciseState
  onTimerStart: () => void
  onTimerStop: () => void
  onAnswerSelected: (questionId: string, answerId: string) => void
}

export function SetupSlide({ exercise }: SetupSlideProps) {
  const [videoUrl, setVideoUrl] = useState(exercise.imageUrl)

  useEffect(() => {
    if (exercise.mediaType === 'video') {
      // In a real app, you'd fetch this from your video service
      setVideoUrl(exercise.imageUrl)
    }
  }, [exercise])

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <Card className="p-3 space-y-1">
        <h2 className="text-2xl font-bold text-center">
          {exercise.name}
        </h2>

        <div className="relative h-[140px] md:h-[250px] rounded-lg overflow-hidden bg-gray-100">
          {exercise.mediaType === 'video' ? (
            <video
              src={videoUrl}
              className="w-full h-full object-contain"
              controls
              playsInline
            />
          ) : (
            <Image
              src={exercise.imageUrl}
              alt={exercise.name}
              fill
              sizes="(max-width: 768px) 100vw, 50vw"
              className="object-contain"
              priority
              unoptimized
            />
          )}
        </div>

        <div className="space-y-1">
          <h3 className="font-semibold text-lg">Setup Instructions</h3>
          <ul className="space-y-3">
            {exercise.instructions.setup.map((instruction, index) => (
              <li key={index} className="flex items-start gap-3">
                <CheckCircle className="w-5 h-5 text-green-500 flex-shrink-0 mt-1" />
                <span>{instruction}</span>
              </li>
            ))}
          </ul>
        </div>
      </Card>
    </motion.div>
  )
}

================
File: data/exercise-content.ts
================
import { Exercise, Question } from '../types'

export const exercises: Record<string, Exercise> = {
  '1': {
    id: '1',
    name: 'Lying Face Down',
    duration: 120, // 2 minutes
    imageUrl: '/prone-lying.png',
    mediaType: 'image',
    instructions: {
      setup: [
        'Find a comfortable spot on the floor or bed if unable to lie on floor',
        'Have your phone in front of you and accessible',
        'Ensure enough space to lie flat',
        'When you are in position and ready, press "Start Exercise" button below',
        'The exercise should be performed for 1-2 minutes'
      ],
      execution: [
        'Be mindful of how the pain is distributed',
        'Pain reducing, or disappearing is a good sign',
        'Pain moving out of the legs and towards the spine is a good sign'
      ],
      safety: [
        'Stop if pain increases in butt or legs',
        'Stop if symptoms move further down your legs',
      ]
    }
  },
  '2': {
    id: '2',
    name: "Lying Down on Elbows",
    duration: 120, // 2 minutes
    imageUrl: "/prone-on-elbows.png",
    mediaType: 'image',
    instructions: {
      setup: [
        "Start by lying face down",
        "Position elbows under shoulders",
        "Have your phone within reach",
        "When you are in position and ready, press 'Start Exercise' button below"       
      ],
      execution: [
        "Be mindful of how the pain is distributed",
        "Pain reducing, or disappearing is a good sign",
        "Pain moving out of the legs and towards the spine is a good sign"
      ],
      safety: [
        "Stop if pain increases in butt or legs",
        "Stop if symptoms move further into legs",
      ]
    }
  },
  '3': {
    id: '3',
    name: "Prone Press Up",
    duration: 120, // 2 minutes
    imageUrl: "/prone-press-up.mp4",
    mediaType: 'video',
    instructions: {
      setup: [
        'Start by lying face down, with hands by chest in a push up position', 
        'While pressing up, your back, hips and legs should remain relaxed', 
        'The goal is to let the back arch and curl up, while keeping the hips and legs relaxed',
        'When you are in position and ready, press "Start Exercise" button below',
        'Perform 10-15 repetitions'
      ],
      execution: [
        "Be mindful of how the pain is distributed",
        "Pain reducing, or disappearing is a good sign",
        "Pain moving out of the legs and towards the spine is a good sign"
      ],
      safety: [
        'Stop if pain increases',
        'Stop if symptoms move further into legs',
      ]
    }
  }
}

export const questions: Record<string, Question> = {
  'initial': {
    id: 'initial',
    text: 'Wait to answer this question until you notice a change in your symptoms. How are your symptoms responding?',
    options: [
      { 
        id: 'better', 
        text: 'Better',
        nextQuestionId: 'location'
      },
      { 
        id: 'worse', 
        text: 'Worse',
        nextQuestionId: 'stop'
      },
      { 
        id: 'same', 
        text: 'Same',
        nextQuestionId: 'location'
      }
    ]
  },
  'location': {
    id: 'location',
    text: 'Where is your pain located now?',
    options: [
      { 
        id: 'central', 
        text: 'More central/toward spine',
        nextQuestionId: 'continue'
      },
      { 
        id: 'peripheral', 
        text: 'More peripheral/toward legs',
        nextQuestionId: 'stop'
      },
      { 
        id: 'same', 
        text: 'Same location',
        nextQuestionId: 'continue'
      }
    ]
  },
  'continue': {
    id: 'continue',
    text: 'Would you like to continue with the exercise?',
    options: [
      { 
        id: 'yes', 
        text: 'Yes',
        nextQuestionId: null
      },
      { 
        id: 'no', 
        text: 'No',
        nextQuestionId: 'stop'
      }
    ]
  },
  'stop': {
    id: 'stop',
    text: 'We should stop this exercise.',
    options: [
      {
        id: "return_to_dashboard",
        text: "Return to Dashboard",
        nextQuestionId: null
      }
    ]
  },
  'completion': {
    id: 'completion',
    text: 'This is the last exercise in the series. When you are done with it, please return to the dashboard.',
    options: [
      { 
        id: 'finish', 
        text: 'Return to Dashboard',
        nextQuestionId: null
      }
    ]
  }
}

================
File: data/index.ts
================
export * from './exercise-content'

================
File: hooks/index.ts
================
export * from './use-progression-state'
export * from './use-timer-state'
export * from './use-response-handler'

================
File: hooks/use-exercise-scroll.ts
================
import { useCallback, useRef } from 'react'

interface ScrollRefs {
  questions: Record<string, HTMLDivElement | null>
  instruction: HTMLDivElement | null
  setup: Record<string, HTMLDivElement | null>
}

export function useExerciseScroll() {
  const refs = useRef<ScrollRefs>({
    questions: {},
    instruction: null,
    setup: {}
  })

  const scrollToElement = useCallback((element: HTMLElement | null) => {
    if (!element) return

    const offset = 80 // Fixed offset for header
    const elementPosition = element.getBoundingClientRect().top + window.scrollY - offset

    window.scrollTo({
      top: elementPosition,
      behavior: 'smooth'
    })
  }, [])

  const scrollToQuestion = useCallback((questionId: string) => {
    const element = refs.current.questions[questionId]
    if (element) {
      scrollToElement(element)
    }
  }, [scrollToElement])

  const scrollToInstruction = useCallback(() => {
    scrollToElement(refs.current.instruction)
  }, [scrollToElement])

  const scrollToSetup = useCallback((exerciseId: string) => {
    const element = refs.current.setup[exerciseId]
    if (element) {
      scrollToElement(element)
    }
  }, [scrollToElement])

  const getQuestionRef = useCallback((questionId: string) => (
    (el: HTMLDivElement | null) => {
      refs.current.questions[questionId] = el
    }
  ), [])

  const getInstructionRef = useCallback((el: HTMLDivElement | null) => {
    refs.current.instruction = el
  }, [])

  const getSetupRef = useCallback((exerciseId: string) => (
    (el: HTMLDivElement | null) => {
      refs.current.setup[exerciseId] = el
    }
  ), [])

  // Single attempt scroll with a small delay
  const scrollWithRetry = useCallback((scrollFn: () => void) => {
    setTimeout(scrollFn, 50)
  }, [])

  return {
    scrollToQuestion,
    scrollToInstruction,
    scrollToSetup,
    getQuestionRef,
    getInstructionRef,
    getSetupRef,
    scrollWithRetry
  }
}

================
File: hooks/use-exercise-timer.ts
================
import { useEffect, useRef } from 'react'
import { useProgressionStore } from '../store/use-progression-store'

export function useExerciseTimer() {
  const { 
    exercises,
    currentExerciseIndex,
    updateTimeRemaining
  } = useProgressionStore()

  const timerRef = useRef<NodeJS.Timeout | null>(null)
  const startTimeRef = useRef<number | null>(null)

  useEffect(() => {
    const currentExercise = exercises[currentExerciseIndex]
    if (!currentExercise) return


    if (currentExercise.isTimerActive) {
      // Clear any existing timer
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }

      // Set start time when timer becomes active
      startTimeRef.current = Date.now()
      const initialTimeRemaining = currentExercise.timeRemaining

      timerRef.current = setInterval(() => {
        if (!startTimeRef.current) return

        // Calculate elapsed time based on real time difference
        const elapsedSeconds = Math.floor((Date.now() - startTimeRef.current) / 1000)
        const newTimeRemaining = Math.max(0, initialTimeRemaining - elapsedSeconds)

  

        updateTimeRemaining(newTimeRemaining)

        // Stop timer if we've reached 0
        if (newTimeRemaining <= 0 && timerRef.current) {
          clearInterval(timerRef.current)
        }
      }, 1000)
    } else {
      // Clear timer when not active
      if (timerRef.current) {
        clearInterval(timerRef.current)
        timerRef.current = null
      }
      startTimeRef.current = null
    }

    // Cleanup on unmount or when dependencies change
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [exercises, currentExerciseIndex, updateTimeRemaining])
}

================
File: hooks/use-progression-state.ts
================
import { useState, useCallback, useEffect, useMemo } from 'react'
import { useAuth } from '@clerk/nextjs'
import { ExerciseProgression } from '../model'
import { ExerciseProgressionService, ProgressionRulesService } from '../services'
import { Exercise, ProgressionState } from '../types'

export function useProgressionState(initialExercises: Exercise[]) {
  const { getToken } = useAuth()
  const [progression] = useState(() => new ExerciseProgression(initialExercises))
  const [state, setState] = useState<ProgressionState>({
    id: progression.getId(),
    exercises: initialExercises,
    states: initialExercises.map(exercise => ({
      id: exercise.id,
      phase: 'setup',
      timeRemaining: exercise.duration,
      isTimerActive: false,
      currentQuestionId: null,
      answers: {},
      visibleQuestions: []
    })),
    currentExerciseIndex: 0,
    status: 'not_started'
  })

  const [service, setService] = useState<ExerciseProgressionService | null>(null)
  const rulesService = useMemo(() => new ProgressionRulesService(), [])

  // Initialize service with token
  useEffect(() => {
    const initService = async () => {
      try {
        const token = await getToken()
        console.log('Initializing service with token:', !!token)
        setService(new ExerciseProgressionService(token))
      } catch (error) {
        console.error('Failed to initialize service:', error)
      }
    }
    initService()
  }, [getToken])

  const startExercise = useCallback(() => {
    console.log('Starting exercise, current state:', state.states[state.currentExerciseIndex])
    try {
      progression.startExercise()
      setState(prev => ({
        ...prev,
        states: prev.states.map((state, index) => 
          index === prev.currentExerciseIndex 
            ? { ...state, phase: 'active', isTimerActive: true }
            : state
        ),
        status: 'in_progress'
      }))
      console.log('Exercise started successfully')
    } catch (error) {
      console.error('Failed to start exercise:', error)
    }
  }, [progression, state.currentExerciseIndex, state.states])

  const pauseExercise = useCallback(() => {
    console.log('Pausing exercise')
    progression.pauseExercise()
    setState(prev => ({
      ...prev,
      states: prev.states.map((state, index) => 
        index === prev.currentExerciseIndex 
          ? { ...state, isTimerActive: false }
          : state
      )
    }))
  }, [progression])

  const submitResponse = useCallback(async (questionId: string, answerId: string) => {
    console.log('Submitting response:', { questionId, answerId })
    progression.submitResponse(questionId, answerId)
    const currentState = progression.getCurrentState()
    
    setState(prev => ({
      ...prev,
      states: prev.states.map((state, index) => 
        index === prev.currentExerciseIndex 
          ? {
              ...state,
              answers: {
                ...state.answers,
                [questionId]: answerId
              }
            }
          : state
      )
    }))

    // Evaluate responses
    const evaluation = rulesService.evaluateResponses(currentState.answers)
    console.log('Response evaluation:', evaluation)
    
    if (evaluation.shouldStop && service) {
      console.log('Stopping exercise due to evaluation')
      await service.saveProgression({
        id: state.id,
        userId: 'current', // This will be set by the service
        startedAt: new Date().toISOString(),
        completedAt: new Date().toISOString(),
        status: 'stopped_early',
        exercises: [{
          id: currentState.id,
          responses: Object.entries(currentState.answers).map(([qId, aId]) => ({
            questionId: qId,
            answerId: aId,
            timestamp: new Date().toISOString()
          })),
          startedAt: new Date().toISOString(),
          completedAt: new Date().toISOString()
        }]
      })
    }

    // Get next question if available
    const nextQuestionId = rulesService.getNextQuestionId(questionId, answerId)
    console.log('Next question:', nextQuestionId)
    if (nextQuestionId) {
      setState(prev => ({
        ...prev,
        states: prev.states.map((state, index) => 
          index === prev.currentExerciseIndex 
            ? {
                ...state,
                currentQuestionId: nextQuestionId,
                visibleQuestions: [...state.visibleQuestions, nextQuestionId]
              }
            : state
        )
      }))
    }
  }, [progression, service, rulesService, state.id])

  const updateTimeRemaining = useCallback((timeRemaining: number) => {
    progression.updateTimeRemaining(timeRemaining)
    setState(prev => ({
      ...prev,
      states: prev.states.map((state, index) => 
        index === prev.currentExerciseIndex 
          ? { ...state, timeRemaining }
          : state
      )
    }))
  }, [progression])

  return {
    state,
    startExercise,
    pauseExercise,
    submitResponse,
    updateTimeRemaining
  }
}

================
File: hooks/use-response-handler.ts
================
import { useCallback, useMemo } from 'react'
import { useRouter } from 'next/navigation'
import { ProgressionRulesService } from '../services'
import { ResponseSet } from '../types'

interface UseResponseHandlerProps {
  onSubmitResponse: (questionId: string, answerId: string) => Promise<void>
  currentResponses: ResponseSet
}

export function useResponseHandler({
  onSubmitResponse,
  currentResponses
}: UseResponseHandlerProps) {
  const router = useRouter()
  const rulesService = useMemo(() => new ProgressionRulesService(), [])

  const handleResponse = useCallback(async (questionId: string, answerId: string) => {
    await onSubmitResponse(questionId, answerId)
    
    const evaluation = rulesService.evaluateResponses({
      ...currentResponses,
      [questionId]: answerId
    })

    if (evaluation.shouldStop && questionId === 'stop' && answerId === 'return_to_dashboard') {
      router.push('/dashboard')
      return
    }
  }, [onSubmitResponse, currentResponses, rulesService, router])

  const canContinue = useCallback((responses: ResponseSet) => {
    const evaluation = rulesService.evaluateResponses(responses)
    return evaluation.canProgress
  }, [rulesService])

  const shouldStop = useCallback((responses: ResponseSet) => {
    const evaluation = rulesService.evaluateResponses(responses)
    return evaluation.shouldStop
  }, [rulesService])

  const getNextQuestion = useCallback((currentQuestionId: string | null, response: string) => {
    return rulesService.getNextQuestionId(currentQuestionId, response)
  }, [rulesService])

  return {
    handleResponse,
    canContinue,
    shouldStop,
    getNextQuestion
  }
}

================
File: hooks/use-timer-state.ts
================
import { useEffect, useCallback, useMemo } from 'react'
import { Timer } from '../model'

interface UseTimerStateProps {
  duration: number
  onTimeUpdate: (timeRemaining: number) => void
  isActive: boolean
}

export function useTimerState({ 
  duration,
  onTimeUpdate,
  isActive
}: UseTimerStateProps) {
  // Create memoized timer instance
  const timer = useMemo(() => {
    const timer = new Timer()
    timer.reset(duration)
    return timer
  }, [duration])

  // Setup timer listener
  useEffect(() => {
    timer.addListener(onTimeUpdate)
    return () => timer.removeListener(onTimeUpdate)
  }, [timer, onTimeUpdate])

  // Handle timer state changes
  useEffect(() => {
    if (isActive) {
      timer.start()
    } else {
      timer.pause()
    }
  }, [timer, isActive])

  const startTimer = useCallback(() => {
    timer.start()
  }, [timer])

  const pauseTimer = useCallback(() => {
    timer.pause()
  }, [timer])

  const resetTimer = useCallback((newDuration: number) => {
    timer.reset(newDuration)
  }, [timer])

  return {
    startTimer,
    pauseTimer,
    resetTimer,
    timeRemaining: timer.getTimeRemaining(),
    isRunning: timer.isRunning()
  }
}

================
File: hooks/use-timer.ts
================
import { useMemo } from 'react'
import { Timer } from '../model'

export function useTimer(duration: number) {
  const timer = useMemo(() => {
    const timer = new Timer()
    timer.reset(duration)
    return timer
  }, [duration])

  return timer
}

================
File: layout.tsx
================
'use client'

import { ReactNode } from 'react'
import { motion } from 'framer-motion'
import { cn } from '@/components/ui/utils'

interface ExerciseLayoutProps {
  children: ReactNode
  className?: string
}

export default function ExerciseLayout({ children, className }: ExerciseLayoutProps) {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className={cn(
        "min-h-[100dvh] bg-background",
        "overscroll-y-none touch-pan-y",
        "overflow-x-hidden",
        className
      )}
      style={{
        scrollBehavior: 'smooth',
        WebkitOverflowScrolling: 'touch'
      }}
    >
      {/* Skip link for accessibility */}
      <a 
        href="#exercise-content" 
        className="sr-only focus:not-sr-only focus:absolute focus:z-50"
      >
        Skip to exercise content
      </a>

      {/* Main content */}
      <div 
        id="exercise-content"
        className="relative scroll-smooth"
      >
        {children}
      </div>
    </motion.div>
  )
}

================
File: metadata.ts
================
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Exercise Progression',
  description: 'Follow along with your prescribed exercise progression',
  openGraph: {
    title: 'Exercise Progression',
    description: 'Follow along with your prescribed exercise progression',
    type: 'website'
  }
}

================
File: model/exercise-progression.ts
================
import { v4 as uuidv4 } from 'uuid'
import { 
  Exercise,
  ExerciseState,
  ProgressionStatus,
  Timer as TimerInterface
} from '../types'
import { Timer } from './timer'

export class ExerciseProgression {
  private readonly id: string
  private readonly exercises: Exercise[]
  private currentExerciseIndex: number
  private states: ExerciseState[]
  private status: ProgressionStatus
  private timer: TimerInterface

  constructor(exercises: Exercise[]) {
    this.id = uuidv4()
    this.exercises = exercises
    this.currentExerciseIndex = 0
    this.states = exercises.map(exercise => ({
      id: exercise.id,
      phase: 'setup',
      timeRemaining: exercise.duration,
      isTimerActive: false,
      currentQuestionId: null,
      answers: {},
      visibleQuestions: []
    }))
    this.status = 'not_started'
    this.timer = new Timer()
  }

  // Getters
  public getId(): string {
    return this.id
  }

  public getCurrentExercise(): Exercise {
    return this.exercises[this.currentExerciseIndex]
  }

  public getCurrentState(): ExerciseState {
    return this.states[this.currentExerciseIndex]
  }

  public getStatus(): ProgressionStatus {
    return this.status
  }

  // State Management
  public startExercise(): void {
    const currentState = this.getCurrentState()
    if (currentState.phase !== 'setup') {
      throw new Error('Exercise must be in setup phase to start')
    }

    this.states[this.currentExerciseIndex] = {
      ...currentState,
      phase: 'active',
      isTimerActive: true
    }
    this.status = 'in_progress'
    this.timer.start()
  }

  public pauseExercise(): void {
    const currentState = this.getCurrentState()
    if (currentState.phase !== 'active') {
      throw new Error('Exercise must be active to pause')
    }

    this.states[this.currentExerciseIndex] = {
      ...currentState,
      isTimerActive: false
    }
    this.timer.pause()
  }

  public submitResponse(questionId: string, answerId: string): void {
    const currentState = this.getCurrentState()
    if (currentState.phase !== 'active' && currentState.phase !== 'questions') {
      throw new Error('Exercise must be active or in questions phase to submit response')
    }

    // Update answers
    this.states[this.currentExerciseIndex] = {
      ...currentState,
      answers: {
        ...currentState.answers,
        [questionId]: answerId
      }
    }

    // Evaluate if we should move to next exercise
    if (this.shouldProgressToNextExercise()) {
      this.progressToNextExercise()
    }
  }

  private shouldProgressToNextExercise(): boolean {
    const currentState = this.getCurrentState()
    const { initial, location, continue: continueResponse } = currentState.answers

    return (
      continueResponse === 'yes' &&
      (initial === 'better' || initial === 'same') &&
      (location === 'central' || location === 'same')
    )
  }

  private progressToNextExercise(): void {
    if (this.currentExerciseIndex >= this.exercises.length - 1) {
      this.completeProgression()
      return
    }

    this.currentExerciseIndex++
    this.timer.reset(this.getCurrentExercise().duration)
  }

  private completeProgression(): void {
    this.status = 'completed'
    this.timer.stop()
  }

  // Timer Management
  public updateTimeRemaining(timeRemaining: number): void {
    const currentState = this.getCurrentState()
    this.states[this.currentExerciseIndex] = {
      ...currentState,
      timeRemaining
    }

    if (timeRemaining <= 0) {
      this.handleTimeExpired()
    }
  }

  private handleTimeExpired(): void {
    const currentState = this.getCurrentState()
    this.states[this.currentExerciseIndex] = {
      ...currentState,
      phase: 'questions',
      isTimerActive: false
    }
  }
}

================
File: model/index.ts
================
export * from './exercise-progression'
export * from './timer'

================
File: model/timer.ts
================
import { Timer as TimerInterface, TimerState } from '../types/timer.types'

export class Timer implements TimerInterface {
  private duration: number
  private timeRemaining: number
  private isActive: boolean
  private startTime: number | null
  private listeners: ((timeRemaining: number) => void)[]

  constructor() {
    this.duration = 0
    this.timeRemaining = 0
    this.isActive = false
    this.startTime = null
    this.listeners = []
  }

  public start(): void {
    if (this.isActive) return
    
    this.isActive = true
    this.startTime = Date.now()
    this.tick()
  }

  public pause(): void {
    this.isActive = false
    this.startTime = null
  }

  public stop(): void {
    this.isActive = false
    this.startTime = null
    this.timeRemaining = 0
  }

  public reset(duration: number): void {
    this.duration = duration
    this.timeRemaining = duration
    this.isActive = false
    this.startTime = null
  }

  public addListener(listener: (timeRemaining: number) => void): void {
    this.listeners.push(listener)
  }

  public removeListener(listener: (timeRemaining: number) => void): void {
    this.listeners = this.listeners.filter(l => l !== listener)
  }

  private tick(): void {
    if (!this.isActive || !this.startTime) return

    const now = Date.now()
    const elapsed = Math.floor((now - this.startTime) / 1000)
    this.timeRemaining = Math.max(0, this.duration - elapsed)

    // Notify listeners
    this.listeners.forEach(listener => listener(this.timeRemaining))

    // Continue ticking if time remains and timer is active
    if (this.timeRemaining > 0 && this.isActive) {
      requestAnimationFrame(() => this.tick())
    } else if (this.timeRemaining <= 0) {
      this.stop()
    }
  }

  public getTimeRemaining(): number {
    return this.timeRemaining
  }

  public isRunning(): boolean {
    return this.isActive
  }

  public getState(): TimerState {
    return {
      duration: this.duration,
      timeRemaining: this.timeRemaining,
      isActive: this.isActive
    }
  }
}

================
File: services/exercise-progression.service.ts
================
import { BaseService } from '@/lib/supabase/services/base'
import { ProgressionSnapshot } from '../types'
import { v4 as uuidv4 } from 'uuid'

interface BaseResponse<T> {
  data: T | null
  error: Error | null
}

interface ExerciseSession {
  exercise_id: string
  started_at: string
  completed_at?: string
  responses: Array<{
    question_id: string
    answer_id: string
    timestamp: string
  }>
}

interface ProgressionRecord {
  id: string
  user_id: string
  started_at: string
  completed_at?: string
  status: string
  exercise_sessions: ExerciseSession[]
}

export class ExerciseProgressionService extends BaseService {
  private readonly progressionTable = 'exercise_progressions'
  private readonly exerciseSessionsTable = 'exercise_sessions'
  private readonly responsesTable = 'exercise_responses'

  setToken(token: string) {
    if (!token) {
      throw new Error('Token cannot be empty')
    }
    console.log('Setting token:', token.slice(0, 10) + '...')
    this.token = token
  }

  private validateToken() {
    if (!this.token) {
      console.error('❌ No auth token available')
      throw new Error('Authentication token is required')
    }
  }

  async saveProgression(progression: ProgressionSnapshot): Promise<BaseResponse<ProgressionSnapshot>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      
      // First save the progression
      const { data: progressionData, error: progressionError } = await client
        .from(this.progressionTable)
        .insert({
          id: progression.id,
          user_id: progression.userId,
          started_at: progression.startedAt,
          completed_at: progression.completedAt,
          status: progression.status
        })
        .select()
        .single()

      if (progressionError) throw progressionError

      // Then save each exercise session and its responses
      for (const exercise of progression.exercises) {
        const { error: sessionError } = await client
          .from(this.exerciseSessionsTable)
          .insert({
            progression_id: progression.id,
            exercise_id: exercise.id,
            started_at: exercise.startedAt,
            completed_at: exercise.completedAt
          })

        if (sessionError) throw sessionError

        // Save responses
        if (exercise.responses.length > 0) {
          const { error: responsesError } = await client
            .from(this.responsesTable)
            .insert(
              exercise.responses.map(response => ({
                progression_id: progression.id,
                exercise_id: exercise.id,
                question_id: response.questionId,
                answer_id: response.answerId,
                timestamp: response.timestamp
              }))
            )

          if (responsesError) throw responsesError
        }
      }

      return { data: progressionData as ProgressionSnapshot, error: null }
    })
  }

  async getProgressionHistory(userId: string): Promise<BaseResponse<ProgressionSnapshot[]>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      
      const { data: progressions, error: progressionsError } = await client
        .from(this.progressionTable)
        .select(`
          *,
          exercise_sessions:${this.exerciseSessionsTable}(
            *,
            responses:${this.responsesTable}(*)
          )
        `)
        .eq('user_id', userId)
        .order('started_at', { ascending: false })

      if (progressionsError) throw progressionsError

      // Transform the data into the expected format
      const formattedProgressions: ProgressionSnapshot[] = (progressions as ProgressionRecord[]).map(prog => ({
        id: prog.id,
        userId: prog.user_id,
        startedAt: prog.started_at,
        completedAt: prog.completed_at,
        status: prog.status as ProgressionSnapshot['status'],
        exercises: prog.exercise_sessions.map(session => ({
          id: session.exercise_id,
          startedAt: session.started_at,
          completedAt: session.completed_at,
          responses: session.responses.map(response => ({
            questionId: response.question_id,
            answerId: response.answer_id,
            timestamp: response.timestamp
          }))
        }))
      }))

      return { data: formattedProgressions, error: null }
    })
  }

  async getLatestProgression(userId: string): Promise<BaseResponse<ProgressionSnapshot | null>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      
      const { data: progression, error } = await client
        .from(this.progressionTable)
        .select(`
          *,
          exercise_sessions:${this.exerciseSessionsTable}(
            *,
            responses:${this.responsesTable}(*)
          )
        `)
        .eq('user_id', userId)
        .order('started_at', { ascending: false })
        .limit(1)
        .maybeSingle()

      if (error) throw error
      if (!progression) return { data: null, error: null }

      const record = progression as ProgressionRecord
      // Transform to expected format
      const formattedProgression: ProgressionSnapshot = {
        id: record.id,
        userId: record.user_id,
        startedAt: record.started_at,
        completedAt: record.completed_at,
        status: record.status as ProgressionSnapshot['status'],
        exercises: record.exercise_sessions.map(session => ({
          id: session.exercise_id,
          startedAt: session.started_at,
          completedAt: session.completed_at,
          responses: session.responses.map(response => ({
            questionId: response.question_id,
            answerId: response.answer_id,
            timestamp: response.timestamp
          }))
        }))
      }

      return { data: formattedProgression, error: null }
    })
  }

  async saveResponse(sessionId: string, questionId: string, answerId: string): Promise<BaseResponse<any>> {
    return this.withErrorHandling(async () => {
      console.log('=== Saving Response to Database ===')
      console.log('Session ID:', sessionId)
      console.log('Question ID:', questionId)
      console.log('Answer ID:', answerId)

      this.validateToken()
      const client = await this.getClient(this.token)
      
      const response = {
        id: uuidv4(),
        session_id: sessionId,
        question_id: questionId,
        answer_id: answerId,
        timestamp: new Date().toISOString()
      }

      console.log('Inserting response:', response)
      
      const { data, error } = await client
        .from(this.responsesTable)
        .insert(response)
        .select()
        .single()

      if (error) {
        console.error('❌ Database error:', error)
        throw error
      }

      console.log('✅ Response saved successfully:', data)
      return { data, error: null }
    })
  }

  async createSeries(seriesId: string): Promise<BaseResponse<any>> {
    return this.withErrorHandling(async () => {
      console.log('=== Creating Exercise Series ===')
      console.log('Series ID:', seriesId)

      this.validateToken()
      const client = await this.getClient(this.token)
      
      // Get user ID directly from JWT token
      try {
        if (!this.token) {
          throw new Error('No token available')
        }

        // Decode JWT to get sub claim
        const [headerB64, payloadB64] = this.token.split('.')
        if (!payloadB64) {
          throw new Error('Invalid JWT format')
        }

        // Add padding if needed
        const base64 = payloadB64.replace(/-/g, '+').replace(/_/g, '/')
        const pad = base64.length % 4
        const paddedBase64 = pad ? base64 + '='.repeat(4 - pad) : base64

        const decodedPayload = JSON.parse(atob(paddedBase64))
        const userId = decodedPayload.sub

        if (!userId) {
          console.error('❌ No user ID in JWT')
          throw new Error('No user ID in JWT')
        }

        console.log('Creating series for user:', userId)

        const series = {
          id: seriesId,
          user_id: userId,
          status: 'in_progress',
          started_at: new Date().toISOString()
        }

        console.log('Creating series:', series)
        
        const { data, error } = await client
          .from('exercise_series')
          .insert(series)
          .select()
          .single()

        if (error) {
          console.error('❌ Database error:', error)
          throw error
        }

        console.log('✅ Series created successfully:', data)
        return { data, error: null }
      } catch (error) {
        console.error('❌ Failed to decode JWT or create series:', error)
        throw error
      }
    })
  }

  async createSession(seriesId: string, exerciseId: string, sessionId: string): Promise<BaseResponse<any>> {
    return this.withErrorHandling(async () => {
      console.log('=== Creating Exercise Session ===')
      console.log('Series ID:', seriesId)
      console.log('Exercise ID:', exerciseId)
      console.log('Session ID:', sessionId)

      this.validateToken()
      const client = await this.getClient(this.token)
      
      const session = {
        id: sessionId,
        series_id: seriesId,
        exercise_id: exerciseId,
        status: 'in_progress',
        started_at: new Date().toISOString()
      }

      console.log('Creating session:', session)
      
      const { data, error } = await client
        .from('exercise_sessions')
        .insert(session)
        .select()
        .single()

      if (error) {
        console.error('❌ Database error:', error)
        throw error
      }

      console.log('✅ Session created successfully:', data)
      return { data, error: null }
    })
  }

  async getToken(): Promise<string | null> {
    try {
      const client = await this.getClient()
      const { data: { session }, error } = await client.auth.getSession()
      
      if (error) {
        console.error('❌ Failed to get auth session:', error)
        return null
      }

      return session?.access_token ?? null
    } catch (error) {
      console.error('❌ Error getting token:', error)
      return null
    }
  }

  async updateSession(sessionId: string, updates: { status: string; completed_at?: string; stop_reason?: string }): Promise<BaseResponse<any>> {
    return this.withErrorHandling(async () => {
      console.log('=== Updating Exercise Session ===')
      console.log('Session ID:', sessionId)
      console.log('Updates:', updates)

      this.validateToken()
      const client = await this.getClient(this.token)
      
      const { data, error } = await client
        .from('exercise_sessions')
        .update(updates)
        .eq('id', sessionId)
        .select()
        .single()

      if (error) {
        console.error('❌ Database error:', error)
        throw error
      }

      console.log('✅ Session updated successfully:', data)
      return { data, error: null }
    })
  }

  async updateSeries(seriesId: string, updates: { status: string; completed_at?: string }): Promise<BaseResponse<any>> {
    return this.withErrorHandling(async () => {
      console.log('=== Updating Exercise Series ===')
      console.log('Series ID:', seriesId)
      console.log('Updates:', updates)

      this.validateToken()
      const client = await this.getClient(this.token)
      
      const { data, error } = await client
        .from('exercise_series')
        .update(updates)
        .eq('id', seriesId)
        .select()
        .single()

      if (error) {
        console.error('❌ Database error:', error)
        throw error
      }

      console.log('✅ Series updated successfully:', data)
      return { data, error: null }
    })
  }
}

================
File: services/index.ts
================
export * from './exercise-progression.service'
export * from './progression-rules.service'

================
File: services/progression-rules.service.ts
================
import { 
  ResponseSet, 
  ResponseEvaluation,
} from '../types'

export class ProgressionRulesService {
  evaluateResponses(responses: ResponseSet): ResponseEvaluation {
    // Check for return to dashboard response first
    if (responses.stop === 'return_to_dashboard' || responses.completion === 'finish') {
      return {
        canProgress: false,
        shouldStop: true,
        nextQuestionId: null,
        message: 'Returning to dashboard'
      }
    }

    // If no initial response yet, can't evaluate
    if (!responses.initial) {
      return {
        canProgress: false,
        shouldStop: false,
        nextQuestionId: 'initial'
      }
    }

    // Check for negative responses that should stop the exercise
    if (responses.initial === 'worse') {
      return {
        canProgress: false,
        shouldStop: false,
        nextQuestionId: 'stop',
        message: 'Exercise stopped due to worsening symptoms'
      }
    }

    // If we have initial but no location, that's the next question
    if (!responses.location) {
      return {
        canProgress: false,
        shouldStop: false,
        nextQuestionId: 'location'
      }
    }

    // Check location response
    if (responses.location === 'peripheral') {
      return {
        canProgress: false,
        shouldStop: false,
        nextQuestionId: 'stop',
        message: 'Exercise stopped due to symptoms moving peripherally'
      }
    }

    // For the last exercise, if we have good responses, show completion instead of continue
    if (responses.exerciseId === '3' && 
        (responses.initial === 'better' || responses.initial === 'same') && 
        (responses.location === 'central' || responses.location === 'same')) {
      return {
        canProgress: false,
        shouldStop: false,
        nextQuestionId: 'completion',
        message: 'Exercise series completed'
      }
    }

    // If we have both responses but no continue response, that's next
    if (!responses.continue) {
      return {
        canProgress: false,
        shouldStop: false,
        nextQuestionId: 'continue'
      }
    }

    // Final evaluation
    const canProgress = this.canProgressToNext(responses)
    
    return {
      canProgress,
      shouldStop: !canProgress,
      message: canProgress 
        ? 'Ready to progress to next exercise'
        : 'Exercise series completed'
    }
  }

  private canProgressToNext(responses: ResponseSet): boolean {
    return (
      responses.continue === 'yes' &&
      (responses.initial === 'better' || responses.initial === 'same') &&
      (responses.location === 'central' || responses.location === 'same')
    )
  }

  getNextQuestionId(currentQuestionId: string | null, response: string): string | null {
    switch (currentQuestionId) {
      case 'initial':
        return response === 'worse' ? 'stop' : 'location'
      case 'location':
        return response === 'peripheral' ? 'stop' : 'continue'
      case 'continue':
        return response === 'yes' ? null : 'stop'
      case 'stop':
        return null
      case 'completion':
        return null
      default:
        return 'initial'
    }
  }
}

================
File: store/use-progression-store.ts
================
import { create } from 'zustand'
import { v4 as uuidv4 } from 'uuid'
import { Exercise, ProgressionStatus } from '../types'
import { ProgressionRulesService } from '../services'
import { exercises } from '../data/exercise-content'
import { ExerciseProgressionService } from '../services'

interface ExerciseState {
  id: string
  sessionId: string
  phase: 'setup' | 'active' | 'complete'
  timeRemaining: number
  isTimerActive: boolean
  currentQuestionId: string | null
  answers: Record<string, string>
  visibleQuestions: string[]
  startedAt?: string
  completedAt?: string
}

interface ProgressionStore {
  // State
  seriesId: string | null
  exercises: ExerciseState[]
  currentExerciseIndex: number
  status: ProgressionStatus
  shouldScrollToNewExercise: boolean
  authToken: string | null

  // Actions
  initializeExercise: (exercise: Exercise, token: string) => Promise<void>
  startExercise: () => Promise<void>
  pauseExercise: () => void
  submitResponse: (questionId: string, answerId: string) => Promise<void>
  updateTimeRemaining: (timeRemaining: number) => void
  addNextExercise: (exercise: Exercise) => void
  handleEarlyStop: (reason: string) => void
}

const rulesService = new ProgressionRulesService()
const exerciseProgressionService = new ExerciseProgressionService()

export const useProgressionStore = create<ProgressionStore>((set, get) => ({
  seriesId: null,
  exercises: [],
  currentExerciseIndex: 0,
  status: 'not_started',
  shouldScrollToNewExercise: false,
  authToken: null,

  initializeExercise: async (exercise: Exercise, token: string) => {
    console.log('Setting up initial exercise state:', exercise.id)
    
    // Just set up the initial UI state and store the token
    set({
      authToken: token,
      exercises: [{
        id: exercise.id,
        sessionId: '', // Will be set when exercise starts
        phase: 'setup',
        timeRemaining: exercise.duration,
        isTimerActive: false,
        currentQuestionId: null,
        answers: {},
        visibleQuestions: [],
        startedAt: undefined
      }]
    })
  },

  startExercise: async () => {
    console.log('Starting exercise at index:', get().currentExerciseIndex)
    const state = get()
    const currentExercise = state.exercises[state.currentExerciseIndex]

    try {
      // Set the token in the service
      exerciseProgressionService.setToken(state.authToken!)
      console.log('✅ Auth token set for exercise start')

      // Create series if this is the first exercise
      let seriesId = state.seriesId
      if (!seriesId) {
        seriesId = uuidv4()
        console.log('Creating new exercise series...')
        const { error: seriesError } = await exerciseProgressionService.createSeries(seriesId)
        if (seriesError) {
          console.error('❌ Failed to create series:', seriesError)
          throw seriesError
        }
        console.log('✅ Series created successfully')
        set({ seriesId })
      }

      // Create session for this exercise
      const sessionId = uuidv4()
      console.log('Creating new exercise session...', {
        seriesId,
        exerciseId: currentExercise.id,
        sessionId
      })
      
      const { error: sessionError } = await exerciseProgressionService.createSession(
        seriesId,
        currentExercise.id,
        sessionId
      )
      if (sessionError) {
        console.error('❌ Failed to create session:', sessionError)
        throw sessionError
      }
      console.log('✅ Session created successfully')

      // Update the UI state
      set(state => ({
        status: 'in_progress',
        exercises: state.exercises.map((exercise, index) =>
          index === state.currentExerciseIndex
            ? {
                ...exercise,
                sessionId,
                phase: 'active',
                isTimerActive: true,
                startedAt: new Date().toISOString()
              }
            : exercise
        )
      }))
    } catch (error) {
      console.error('❌ Failed to start exercise:', error)
      throw error
    }
  },

  pauseExercise: () => {
    console.log('Pausing exercise at index:', get().currentExerciseIndex)
    set(state => ({
      exercises: state.exercises.map((exercise, index) =>
        index === state.currentExerciseIndex
          ? { ...exercise, isTimerActive: false }
          : exercise
      )
    }))
  },

  submitResponse: async (questionId: string, answerId: string) => {
    try {
      console.log('=== Submitting Response ===')
      console.log('Question ID:', questionId)
      console.log('Answer ID:', answerId)
      
      const state = get()
      const currentExercise = state.exercises[state.currentExerciseIndex]
      
      console.log('Current Exercise State:', {
        id: currentExercise.id,
        sessionId: currentExercise.sessionId,
        phase: currentExercise.phase,
        answers: currentExercise.answers
      })

      // Save response to database
      if (answerId !== '') {
        try {
          console.log('Saving response to database...')
          await exerciseProgressionService.saveResponse(
            currentExercise.sessionId,
            questionId,
            answerId
          )
          console.log('✅ Response saved successfully')
        } catch (error) {
          console.error('❌ Failed to save response:', error)
        }
      }

      const updatedExercises = state.exercises.map((exercise, index) =>
        index === state.currentExerciseIndex
          ? { ...exercise, answers: { ...exercise.answers, [questionId]: answerId } }
          : exercise
      )

      const evaluation = rulesService.evaluateResponses({
        ...currentExercise.answers,
        [questionId]: answerId
      })

      console.log('Response Evaluation:', {
        evaluation,
        currentAnswers: { ...currentExercise.answers, [questionId]: answerId }
      })

      if (evaluation.shouldStop) {
        console.log('Exercise should stop:', evaluation.message)
        if (answerId === 'worse' || answerId === 'peripheral') {
          console.log('Stopping exercise due to negative response')
          await get().handleEarlyStop(
            answerId === 'worse' ? 'worse_symptoms' : 'peripheral_pain'
          )
          set({ status: 'stopped_early' })
          return
        }
      }

      // Handle return to dashboard
      if (questionId === 'stop' && answerId === 'return_to_dashboard' || 
          questionId === 'completion' && answerId === 'finish') {
        console.log('Returning to dashboard')
        
        try {
          // Update session status
          console.log('Updating session status...')
          const { error: sessionError } = await exerciseProgressionService.updateSession(
            currentExercise.sessionId,
            {
              status: 'completed',
              completed_at: new Date().toISOString()
            }
          )
          if (sessionError) {
            console.error('❌ Failed to update session:', sessionError)
            throw sessionError
          }

          // Update series status only when explicitly stopping
          console.log('Updating series status...')
          const { error: seriesError } = await exerciseProgressionService.updateSeries(
            state.seriesId!,
            {
              status: questionId === 'stop' ? 'cancelled' : 'completed',
              completed_at: new Date().toISOString()
            }
          )
          if (seriesError) {
            console.error('❌ Failed to update series:', seriesError)
            throw seriesError
          }

          console.log('✅ Successfully updated session and series status')
        } catch (error) {
          console.error('❌ Failed to update status:', error)
        }

        set({
          status: questionId === 'stop' ? 'stopped_early' : 'completed',
          exercises: updatedExercises.map((exercise, index) =>
            index === state.currentExerciseIndex
              ? { ...exercise, completedAt: new Date().toISOString() }
              : exercise
          )
        })
        window.location.href = '/dashboard'
        return
      }

      // Check if we should progress to next exercise
      const shouldProgress = !evaluation.nextQuestionId && 
        (answerId === 'yes' || answerId === 'better' || answerId === 'central')

      if (shouldProgress) {
        console.log('=== Exercise Progression ===')
        console.log('Current exercise:', currentExercise.id)
        console.log('Trigger answer:', { questionId, answerId })
        
        const nextExerciseId = String(parseInt(currentExercise.id) + 1)
        const nextExercise = exercises[nextExerciseId]

        if (nextExercise) {
          const nextSessionId = uuidv4()
          console.log('Next exercise details:', {
            id: nextExerciseId,
            sessionId: nextSessionId,
            exercise: nextExercise
          })

          try {
            // Update current session as completed
            console.log('Updating current session status to completed...')
            const { error: sessionError } = await exerciseProgressionService.updateSession(
              currentExercise.sessionId,
              {
                status: 'completed',
                completed_at: new Date().toISOString()
              }
            )

            if (sessionError) {
              console.error('❌ Failed to update current session:', sessionError)
              throw sessionError
            }
            console.log('✅ Current session updated successfully')

            // Create new session for next exercise
            console.log('Creating new session...')
            const { error: newSessionError } = await exerciseProgressionService.createSession(
              state.seriesId!,
              nextExerciseId,
              nextSessionId
            )

            if (newSessionError) {
              console.error('❌ Failed to create session for next exercise:', newSessionError)
              throw newSessionError
            }
            console.log('✅ New session created successfully')

            // Update UI state to show next exercise
            const newState = {
              exercises: [
                ...updatedExercises,
                {
                  id: nextExerciseId,
                  sessionId: nextSessionId,
                  phase: 'setup' as const,
                  timeRemaining: nextExercise.duration,
                  isTimerActive: false,
                  currentQuestionId: null,
                  answers: {},
                  visibleQuestions: [],
                  startedAt: new Date().toISOString()
                }
              ],
              currentExerciseIndex: state.exercises.length,
              shouldScrollToNewExercise: true,
              status: 'in_progress' as const // Keep series in progress
            }
            console.log('Setting new state:', newState)
            set((state) => ({
              ...state,
              ...newState
            }))
            console.log('✅ UI state updated for next exercise')
          } catch (error) {
            console.error('❌ Failed to progress to next exercise:', error)
            throw error
          }
          return
        } else {
          // This is the final exercise and they've completed it successfully
          console.log('Final exercise completed')
          set({
            exercises: updatedExercises.map((exercise, index) =>
              index === state.currentExerciseIndex
                ? {
                    ...exercise,
                    currentQuestionId: 'completion',
                    visibleQuestions: [...exercise.visibleQuestions, 'completion']
                  }
                : exercise
            )
          })
          return
        }
      }

      // Update visible questions if there's a next question
      if (evaluation.nextQuestionId) {
        console.log('Adding next question:', evaluation.nextQuestionId)
        set({
          exercises: updatedExercises.map((exercise, index) =>
            index === state.currentExerciseIndex
              ? {
                  ...exercise,
                  currentQuestionId: evaluation.nextQuestionId!,
                  visibleQuestions: exercise.visibleQuestions.includes(evaluation.nextQuestionId!)
                    ? exercise.visibleQuestions
                    : [...exercise.visibleQuestions, evaluation.nextQuestionId!]
                }
              : exercise
          )
        })
      }
    } catch (error) {
      console.error('❌ Error submitting response:', error)
    }
  },

  updateTimeRemaining: (timeRemaining: number) => {
    set(state => ({
      exercises: state.exercises.map((exercise, index) =>
        index === state.currentExerciseIndex
          ? { ...exercise, timeRemaining }
          : exercise
      )
    }))
  },

  addNextExercise: (exercise: Exercise) => {
    console.log('Adding next exercise:', exercise.id)
    set(state => ({
      exercises: [
        ...state.exercises,
        {
          id: exercise.id,
          sessionId: '', // Will be set when exercise starts
          phase: 'setup',
          timeRemaining: exercise.duration,
          isTimerActive: false,
          currentQuestionId: null,
          answers: {},
          visibleQuestions: [],
          startedAt: new Date().toISOString()
        }
      ],
      currentExerciseIndex: state.exercises.length
    }))
  },

  handleEarlyStop: async (reason: string) => {
    console.log('Handling early stop:', reason)
    const state = get()
    const currentExercise = state.exercises[state.currentExerciseIndex]

    try {
      // Set the token in the service
      exerciseProgressionService.setToken(state.authToken!)

      // Update session status
      console.log('Updating session status to stopped...')
      const { error: sessionError } = await exerciseProgressionService.updateSession(
        currentExercise.sessionId,
        {
          status: 'cancelled',
          completed_at: new Date().toISOString(),
          stop_reason: reason
        }
      )
      if (sessionError) {
        console.error('❌ Failed to update session:', sessionError)
        throw sessionError
      }

      // Update series status
      console.log('Updating series status to stopped...')
      const { error: seriesError } = await exerciseProgressionService.updateSeries(
        state.seriesId!,
        {
          status: 'cancelled',
          completed_at: new Date().toISOString()
        }
      )
      if (seriesError) {
        console.error('❌ Failed to update series:', seriesError)
        throw seriesError
      }

      console.log('✅ Successfully updated session and series status')
    } catch (error) {
      console.error('❌ Failed to handle early stop:', error)
      throw error
    }
  }
}))

================
File: types/exercise.types.ts
================
export interface Exercise {
    id: string
    name: string
    duration: number
    imageUrl: string
    mediaType: 'image' | 'video'
    instructions: {
      setup: string[]
      execution: string[]
      safety: string[]
    }
  }
  
  export type ExercisePhase = 'setup' | 'active' | 'questions' | 'complete'
  
  export interface ExerciseState {
    id: string
    phase: ExercisePhase
    timeRemaining: number
    isTimerActive: boolean
    currentQuestionId: string | null
    answers: Record<string, string>
    visibleQuestions: string[]
  }

================
File: types/index.ts
================
export * from './exercise.types'
export * from './progression.types'
export * from './question.types'
export * from './response.types'
export * from './timer.types'

================
File: types/progression.types.ts
================
import { Exercise, ExerciseState } from './exercise.types'

export type ProgressionStatus = 'not_started' | 'in_progress' | 'completed' | 'stopped_early'

export interface ProgressionState {
  id: string
  exercises: Exercise[]
  states: ExerciseState[]
  currentExerciseIndex: number
  status: ProgressionStatus
}

export interface ProgressionEvent {
  type: 
    | 'EXERCISE_STARTED'
    | 'EXERCISE_PAUSED'
    | 'EXERCISE_COMPLETED'
    | 'RESPONSE_SUBMITTED'
    | 'TIME_EXPIRED'
    | 'PROGRESSION_COMPLETED'
  payload: {
    progressionId: string
    exerciseId: string
    timestamp: number
    data?: unknown
  }
}

export interface ProgressionSnapshot {
  id: string
  userId: string
  startedAt: string
  completedAt?: string
  status: ProgressionStatus
  exercises: {
    id: string
    responses: Array<{
      questionId: string
      answerId: string
      timestamp: string
    }>
    startedAt: string
    completedAt?: string
  }[]
}

================
File: types/question.types.ts
================
export interface Question {
    id: string
    text: string
    options: QuestionOption[]
  }
  
  export interface QuestionOption {
    id: string
    text: string
    nextQuestionId?: string | null
  }

================
File: types/response.types.ts
================
export type ResponseType = 'better' | 'worse' | 'same'
export type LocationType = 'central' | 'peripheral' | 'same'
export type ContinueType = 'yes' | 'no'

export interface Response {
  questionId: string
  answerId: string
  timestamp: string
}

export interface ResponseSet {
  initial?: ResponseType
  location?: LocationType
  continue?: ContinueType
  [key: string]: string | undefined
}

export interface ResponseEvaluation {
  canProgress: boolean
  shouldStop: boolean
  nextQuestionId?: string | null
  message?: string
}

export interface ResponseHistory {
  exerciseId: string
  responses: Response[]
  startedAt: string
  completedAt?: string
}

================
File: types/timer.types.ts
================
export interface TimerState {
  duration: number
  timeRemaining: number
  isActive: boolean
}

export interface Timer {
  start(): void
  pause(): void
  stop(): void
  reset(duration: number): void
  addListener(listener: (timeRemaining: number) => void): void
  removeListener(listener: (timeRemaining: number) => void): void
  getTimeRemaining(): number
  isRunning(): boolean
}



================================================================
End of Codebase
================================================================
