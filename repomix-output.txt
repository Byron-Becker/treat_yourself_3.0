This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T03:24:34.216Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app/(features)/state-management-guidelines.md
app/(features)/user-profile/components/profile-form.tsx
app/(features)/user-profile/components/profile-view.tsx
app/(features)/user-profile/hooks/use-profile.ts
app/(features)/user-profile/layout.tsx
app/(features)/user-profile/page.tsx
app/(features)/user-profile/services/profile.service.ts
app/(features)/user-profile/types/profile.types.ts
app/auth/sign-in/[[...sign-in]]/page.tsx
app/auth/sign-up/[[...sign-up]]/page.tsx
app/globals.css
app/layout.tsx
app/page.tsx
components/error-boundary.tsx
components/footer.tsx
components/next-progress.tsx
components/test/error-test.test.tsx
components/test/error-test.tsx
components/theme-provider.tsx
components/ui/button.tsx
components/ui/dropdown-menu.tsx
components/ui/navigation-menu.tsx
components/ui/navigation.tsx
components/ui/toast.tsx
components/ui/toaster.tsx
components/ui/utils.ts
hooks/use-toast.ts
lib/errors/base.ts
lib/errors/codes.ts
lib/errors/handlers.ts
lib/supabase/client-singleton.ts
lib/supabase/client-ssr.ts
lib/supabase/errors/supabase.ts
lib/supabase/hooks/example-hook.ts
lib/supabase/README-supa.md
lib/supabase/services/base.ts
lib/supabase/services/example-service.ts
lib/supabase/setup-auth-db.md
lib/supabase/types/example-types.ts
middleware.ts

================================================================
Files
================================================================

================
File: app/(features)/state-management-guidelines.md
================
State Management Guidelines for Feature-Slice Design
This document outlines state management patterns for Feature-Slice Design (FSD) with Domain-Driven Design (DDD) principles and Test-Driven Development (TDD).

Feature Structure:

features/
  feature-name/
    model/          # Business logic & state
      store.ts      # Feature-specific state
      types.ts      # Feature-specific types
      constants.ts  # Feature-specific constants
    ui/            # React components
    api/           # API integration
    lib/           # Feature-specific utilities
    tests/         # Feature tests

Core Principles
## Implementation Patterns

### A. Local Component State
```typescript
// Good: Encapsulated UI state
function FeatureComponent() {
  const [isOpen, setIsOpen] = useState(false)
  const [inputValue, setInputValue] = useState("")
}
// model/store.ts
export function useFeatureStore() {
  // Feature-specific state management
  const [entities, setEntities] = useState<Entity[]>([])
  const [isLoading, setIsLoading] = useState(false)
  
  // Business logic stays with state
  const processEntity = (entity: Entity) => {
    // Domain logic here
  }

  return {
    entities,
    isLoading,
    processEntity
  }
}
// model/domain.ts
export function calculateSomething(data: FeatureData) {
  // Pure business logic
  // No UI or state management here
}
// tests/store.test.ts
describe('Feature Store', () => {
  // Test business logic in isolation
  test('processes entity correctly', () => {})
  
  // Test state changes
  test('updates state as expected', () => {})
})

// tests/ui.test.ts
describe('Feature UI', () => {
  // Test UI behavior
  test('shows loading state', () => {})
})

Feature Isolation

Each feature manages its own state
No direct state access between features
Features communicate through defined interfaces
Business logic stays within feature boundary


State Ownership

State lives as close as possible to where it's used
Clear separation between UI and business logic
Explicit data flow within feature
Traceable state changes for testing



State Location Guidelines
Local UI State
Use for component-specific state that doesn't affect business logic:

Form input values
UI toggles (modal open/closed)
Animation states
Component-specific loading states

function FeatureComponent() {
  const [isOpen, setIsOpen] = useState(false)
  const [inputValue, setInputValue] = useState("")
  
  // Local UI logic only
  const handleToggle = () => setIsOpen(!isOpen)
}

Feature-Level State
Use for state that affects business logic or is shared across components:

Domain entity data
Feature-wide loading states
Feature-specific error states
Selected items/filters

// model/store.ts
export function useFeatureStore() {
  // Feature-specific state
  const [entities, setEntities] = useState<Entity[]>([])
  const [isLoading, setIsLoading] = useState(false)
  
  // Business logic stays with state
  const processEntity = (entity: Entity) => {
    // Domain logic here
  }

  return {
    entities,
    isLoading,
    processEntity
  }
}

Shared State (Use Sparingly)
Only for truly global state that multiple features need:

User authentication
Theme settings
Global notifications
App-wide settings

Cross-Feature Communication
Events Pattern
Use when features need to react to changes in other features:

// Shared event types
type FeatureEvent = {
  type: 'entityCreated' | 'entityUpdated'
  payload: unknown
}

// Feature A
const emitEvent = (event: FeatureEvent) => {
  // Event emission logic
}

// Feature B
const handleEvent = (event: FeatureEvent) => {
  // Event handling logic
}

Testing Strategy
Unit Tests
Test business logic in isolation:

// tests/domain.test.ts
describe('Feature Domain Logic', () => {
  test('processes data correctly', () => {
    const result = processData(testData)
    expect(result).toMatchExpectedOutput()
  })
})

Integration Tests
Test state management and UI together:

// tests/integration.test.ts
describe('Feature Integration', () => {
  test('updates UI when state changes', async () => {
    render(<FeatureComponent />)
    // Test state changes reflect in UI
  })
})

Best Practices

State Organization

Keep state modifications traceable
Document state shape and mutations
Use TypeScript for state typing
Implement proper error boundaries


Performance

Minimize state updates
Use proper memoization
Split state logically to prevent unnecessary rerenders
Consider state granularity


Development Flow

Start with domain model
Write tests first (TDD)
Implement business logic
Add UI components last



Anti-patterns to Avoid

State Management

Directly accessing other feature's state
Mixing UI and business logic state
Keeping mutable state
Deep nesting of state


Feature Organization

Circular dependencies between features
Shared state when not necessary
Unclear feature boundaries
Mixed responsibilities



Scaling Considerations

State Persistence

Define clear serialization patterns
Handle hydration properly
Consider offline capabilities


Performance at Scale

Implement proper state splitting
Use effective caching strategies
Consider code splitting impact


Team Collaboration

Document state management decisions
Maintain clear feature ownership
Regular state management audits

================
File: app/(features)/user-profile/components/profile-form.tsx
================
'use client'

import { useState, useEffect } from 'react'
import { useProfile } from '../hooks/use-profile'
import type { UpdateUserProfile } from '../types/profile.types'

interface ProfileFormProps {
  onSuccess?: () => void
}

export function ProfileForm({ onSuccess }: ProfileFormProps) {
  const { profile, updateProfile, loading } = useProfile()
  const [formData, setFormData] = useState<UpdateUserProfile>({
    display_name: profile?.display_name || '',
    bio: profile?.bio || '',
    timezone: profile?.timezone || '',
  })

  useEffect(() => {
    if (profile) {
      setFormData({
        display_name: profile.display_name || '',
        bio: profile.bio || '',
        timezone: profile.timezone || '',
      })
    }
  }, [profile])

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target
    setFormData(prev => ({ ...prev, [name]: value }))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    try {
      const updatedProfile = await updateProfile(formData)
      if (updatedProfile) {
        onSuccess?.()
      }
    } catch (error) {
      console.error('Failed to update profile:', error)
    }
  }

  if (!profile) return null

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <label htmlFor="display_name" className="block text-sm font-medium text-gray-700">
          Display Name
        </label>
        <input
          type="text"
          id="display_name"
          name="display_name"
          value={formData.display_name}
          onChange={handleChange}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
          required
        />
      </div>

      <div>
        <label htmlFor="bio" className="block text-sm font-medium text-gray-700">
          Bio
        </label>
        <textarea
          id="bio"
          name="bio"
          rows={3}
          value={formData.bio || ''}
          onChange={handleChange}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
        />
      </div>

      <div>
        <label htmlFor="timezone" className="block text-sm font-medium text-gray-700">
          Timezone
        </label>
        <input
          type="text"
          id="timezone"
          name="timezone"
          value={formData.timezone || ''}
          onChange={handleChange}
          className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
        />
      </div>

      <div className="flex justify-end">
        <button
          type="submit"
          disabled={loading}
          className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {loading ? 'Saving...' : 'Save Changes'}
        </button>
      </div>
    </form>
  )
}

================
File: app/(features)/user-profile/components/profile-view.tsx
================
// src/features/user-profile/components/profile-view.tsx

'use client'

import { useState } from 'react'
import { useProfile } from '../hooks/use-profile'
import { ProfileForm } from './profile-form'

export function ProfileView() {
  const { profile, loading, error } = useProfile()
  const [isEditing, setIsEditing] = useState(false)

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[200px]">
        <div className="text-gray-500">Loading profile...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-red-50 p-4 rounded-md">
        <div className="text-red-700">Error loading profile: {error.message}</div>
      </div>
    )
  }

  if (!profile) {
    return (
      <div className="bg-yellow-50 p-4 rounded-md">
        <div className="text-yellow-700">No profile found. One will be created automatically.</div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="bg-white shadow sm:rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          {!isEditing ? (
            <div className="space-y-4">
              <div className="flex justify-between items-start">
                <h3 className="text-lg font-medium leading-6 text-gray-900">Your Profile</h3>
                <button
                  onClick={() => setIsEditing(true)}
                  className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                >
                  Edit Profile
                </button>
              </div>
              <div className="mt-4 space-y-4">
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Display Name</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.display_name || 'Not set'}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Email</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.email || 'Not set'}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Bio</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.bio || 'Not set'}</p>
                </div>
                <div>
                  <h4 className="text-sm font-medium text-gray-500">Timezone</h4>
                  <p className="mt-1 text-sm text-gray-900">{profile.timezone || 'Not set'}</p>
                </div>
              </div>
            </div>
          ) : (
            <div>
              <div className="flex justify-between items-start mb-4">
                <h3 className="text-lg font-medium leading-6 text-gray-900">Edit Profile</h3>
                <button
                  onClick={() => setIsEditing(false)}
                  className="inline-flex justify-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                >
                  Cancel
                </button>
              </div>
              <ProfileForm onSuccess={() => setIsEditing(false)} />
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

================
File: app/(features)/user-profile/hooks/use-profile.ts
================
// src/features/user-profile/hooks/use-profile.ts

import { useState, useCallback, useEffect, useRef, useMemo } from 'react'
import { useAuth, useUser } from '@clerk/nextjs'
import type { UserProfile, UpdateUserProfile } from '../types/profile.types'
import { userProfileService } from '../services/profile.service'
import { SupabaseError } from '@/lib/supabase/errors/supabase'
import { useErrorHandler } from '@/lib/errors/handlers'

export function useProfile() {
  const isMounted = useRef(false)
  const fetchInProgress = useRef(false)
  const { userId, getToken } = useAuth()
  const { user } = useUser()
  const [profile, setProfile] = useState<UserProfile | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<SupabaseError | null>(null)
  const handleError = useErrorHandler()

  const authState = useMemo(() => ({
    userId,
    user,
    getToken
  }), [userId, user, getToken])

  const fetchProfile = useCallback(async () => {
    if (!authState.userId || fetchInProgress.current) {
      return
    }

    try {
      fetchInProgress.current = true
      setLoading(true)
      setError(null)
      const token = await authState.getToken({ template: 'supabase' })
      let data = await userProfileService.getProfile(authState.userId, token)
      
      if (!data && authState.user) {
        const newProfile = {
          id: authState.userId,
          display_name: authState.user.username || 
                       authState.user.firstName && authState.user.lastName ? 
                       `${authState.user.firstName} ${authState.user.lastName}` :
                       authState.user.firstName || 'New User',
          email: authState.user.primaryEmailAddress?.emailAddress || '',
          avatar_url: authState.user.imageUrl || undefined,
        }
        data = await userProfileService.createProfile(newProfile, token)
      }

      if (isMounted.current) {
        setProfile(data)
      }
    } catch (err) {
      if (isMounted.current) {
        const supabaseError = SupabaseError.fromError(err)
        setError(supabaseError)
        handleError(supabaseError)
      }
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
      fetchInProgress.current = false
    }
  }, [authState, handleError])

  const updateProfile = useCallback(async (updates: UpdateUserProfile) => {
    if (!authState.userId || !profile) return

    // Optimistic update
    const previousProfile = profile
    const optimisticProfile = { ...profile, ...updates }
    setProfile(optimisticProfile)

    try {
      setLoading(true)
      const token = await authState.getToken({ template: 'supabase' })
      const updated = await userProfileService.updateProfile(authState.userId, updates, token)
      
      if (isMounted.current) {
        // Update with actual server response
        setProfile(updated)
      }
      return updated
    } catch (err) {
      // Revert to previous state on error
      if (isMounted.current) {
        setProfile(previousProfile)
        const supabaseError = SupabaseError.fromError(err)
        setError(supabaseError)
        handleError(supabaseError)
      }
      throw err
    } finally {
      if (isMounted.current) {
        setLoading(false)
      }
    }
  }, [authState, handleError, profile])

  useEffect(() => {
    isMounted.current = true
    
    if (authState.userId && !profile && !error) {
      fetchProfile()
    }

    return () => {
      isMounted.current = false
    }
  }, [authState.userId, profile, error, fetchProfile])

  return {
    profile,
    loading,
    error,
    fetchProfile,
    updateProfile,
    user: authState.user
  }
}

================
File: app/(features)/user-profile/layout.tsx
================
// src/app/profile/page.tsx
'use client'

import { ProfileView } from './components/profile-view'


export default function ProfilePage() {
  return (
    <div className="max-w-2xl mx-auto">
      <ProfileView />
    </div>
  )
}

================
File: app/(features)/user-profile/page.tsx
================
// src/app/(authenticated)/profile/page.tsx
'use client'

import { ProfileView } from './components/profile-view'


export default function ProfilePage() {
  return (
    <div className="max-w-2xl mx-auto">
      <ProfileView />
    </div>
  )
}

================
File: app/(features)/user-profile/services/profile.service.ts
================
// src/features/user-profile/services/profile.service.ts

import { BaseService } from '@/lib/supabase/services/base'
import type { UserProfile, CreateUserProfile, UpdateUserProfile } from '../types/profile.types'

export class UserProfileService extends BaseService {
  private readonly table = 'user_profiles'

  async getProfile(userId: string, token?: string | null): Promise<UserProfile | null> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
        .eq('id', userId)
        .maybeSingle()
      
      if (error) throw error
      return data
    })
  }

  async createProfile(profile: CreateUserProfile & { id: string }, token?: string | null): Promise<UserProfile> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)

      const { data, error } = await client
        .from(this.table)
        .insert(profile)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async updateProfile(userId: string, updates: UpdateUserProfile, token?: string | null): Promise<UserProfile> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update({ ...updates, updated_at: new Date().toISOString() })
        .eq('id', userId)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }
}

export const userProfileService = new UserProfileService()

================
File: app/(features)/user-profile/types/profile.types.ts
================
// src/features/user-profile/types/profile.types.ts
// Basic interfaces for our domain model

export interface UserProfile {
    id: string               // Clerk user id
    display_name: string      
    email: string           // Clerk email
    bio?: string            // Optional in first iteration
    avatar_url?: string      // Optional in first iteration
    timezone?: string       // Optional in first iteration
    created_at: string
    updated_at: string
  }
  
  // For creating a new profile
  export type CreateUserProfile = Omit<UserProfile, 'id' | 'created_at' | 'updated_at'> 
  
  // For updating an existing profile
  export type UpdateUserProfile = Partial<Omit<UserProfile, 'id' | 'email' | 'created_at' | 'updated_at'>>

================
File: app/auth/sign-in/[[...sign-in]]/page.tsx
================
// app/(auth)/sign-in/[[...sign-in]]/page.tsx
import { SignIn } from "@clerk/nextjs"

export default function SignInPage() {
  return (
    // Make this container fill the ENTIRE main area height and negate container padding
    <div className="absolute inset-0 flex items-center justify-center">
      <SignIn
        appearance={{
          elements: {
            rootBox: "w-full max-w-md px-5",
            card: "shadow-md rounded-lg",
            main: "px-2 py-4",
            footer: "px-4 pb-4"
          }
        }}
      />
    </div>
  )
}

================
File: app/auth/sign-up/[[...sign-up]]/page.tsx
================
// app/(auth)/sign-up/[[...sign-up]]/page.tsx
import { SignUp } from "@clerk/nextjs"

export default function SignUpPage() {
 return (
   // Remove 'items-center' to make it start from top, and add height constraints
   <div className="absolute inset-0 flex justify-center overflow-y-auto">
     <div className="pt-4">
       <SignUp
         appearance={{
           elements: {
             rootBox: "w-full max-w-md px-4",
             card: "shadow-md rounded-lg",
             main: "px-4 py-4",
             footer: "px-4 pb-4"
           }
         }}
       />
     </div>
   </div>
 )
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 10% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Add these styles for NProgress */
#nprogress {
  pointer-events: none;
}

#nprogress .bar {
  background: #0284c7;
  position: fixed;
  z-index: 1031;
  top: 0;
  left: 0;
  width: 100%;
  height: 2px;
}

================
File: app/layout.tsx
================
import { ClerkProvider, SignInButton, SignedIn, SignedOut, UserButton } from '@clerk/nextjs'
import { Navigation } from '@/components/ui/navigation-menu'
import { Footer } from '@/components/footer'
import { cn } from '@/components/ui/utils'
import { Toaster } from '@/components/ui/toaster'
import { ThemeProvider } from '@/components/theme-provider'
import { NextProgress } from '@/components/next-progress'
import { ErrorBoundary } from '@/components/error-boundary'
import './globals.css'

interface RootLayoutProps {
  children: React.ReactNode,
  className?: string
}

export default function RootLayout({ children, className }: RootLayoutProps) {
  return (
    <ClerkProvider>
      <html lang="en" className="h-full" suppressHydrationWarning>
        <head>
          <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
        </head>
        <body 
          className={cn(
            "min-h-[100dvh] flex flex-col bg-background",
            "px-safe-offset-x pb-safe-offset-bottom",
            "overscroll-y-none",
            "select-none",
            "touch-pan-y",
            className
          )}
        >
          <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            {/* Skip to main content link for accessibility */}
            <a 
              href="#main-content" 
              className="sr-only focus:not-sr-only focus:absolute focus:z-50"
            >
              Skip to main content
            </a>

            <Navigation className="flex-none z-50">
              <SignedOut>
                <SignInButton />
              </SignedOut>
              <SignedIn>
                <UserButton />
              </SignedIn>
            </Navigation>
            
            <main 
              id="main-content"
              className="flex-1 flex flex-col relative overflow-y-auto"
              style={{ scrollBehavior: 'smooth' }}
            >
              {/* Progress bar for page loads */}
              <NextProgress />
              
              {/* Inner content wrapper */}
              <div className={cn(
                "flex-1 container mx-auto",
                "px-4 sm:px-6 lg:px-8",
                "pt-safe-offset-top pb-safe-offset-bottom",
                "mb-safe-offset-bottom"
              )}>
                <ErrorBoundary>
                  {children}
                </ErrorBoundary>
              </div>
            </main>

            <Footer className="flex-none z-40" />
            
            {/* Toast notifications */}
            <Toaster />
          </ThemeProvider>

          {/* Portal container for modals */}
          <div id="modal-root" />
        </body>
      </html>
    </ClerkProvider>
  )
}

// Add metadata
export const metadata = {
  title: {
    default: 'Your App Name',
    template: '%s | Your App Name',
  },
  description: 'Your app description',
}

export const viewport = {
  width: 'device-width',
  initialScale: 1,
  maximumScale: 1,
  viewportFit: 'cover',
}

export const themeConfig = {
  themeColor: [
    { media: '(prefers-color-scheme: light)', color: 'white' },
    { media: '(prefers-color-scheme: dark)', color: 'black' }
  ],
}

================
File: app/page.tsx
================
'use client'

import { useEffect } from 'react'
import { useTestItems } from '@/lib/supabase/hooks/example-hook'
import { Button } from '@/components/ui/button'
import { useToast } from '@/hooks/use-toast'
import { ErrorTest } from '@/components/test/error-test'

export default function Home() {
  const { items, loading, error, fetchItems, createItem, updateItem, deleteItem } = useTestItems()
  const { toast } = useToast()

  useEffect(() => {
    fetchItems()
  }, [fetchItems])

  const handleCreate = async () => {
    try {
      await createItem({ content: 'Test item ' + Date.now() })
      toast({
        title: 'Success',
        description: 'Item created'
      })
    } catch (error) {
      console.error('Failed to create item:', error)
      toast({
        title: 'Error',
        description: 'Failed to create item',
        variant: 'destructive'
      })
    }
  }

  if (error) {
    return (
      <div className="p-4">
        <div className="text-red-500">Error: {error.message}</div>
        <Button onClick={() => fetchItems()} className="mt-2">Retry</Button>
      </div>
    )
  }

  return (
    <div className="container mx-auto py-8 space-y-8">
      <div className="p-4 space-y-4 border rounded-lg shadow-sm">
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-bold">Test Items</h1>
          <Button onClick={handleCreate} disabled={loading}>
            Add Item
          </Button>
        </div>

        {loading && <div>Loading...</div>}
        
        <div className="space-y-2">
          {items.map(item => (
            <div key={item.id} className="flex items-center justify-between p-2 border rounded">
              <span>{item.content}</span>
              <div className="space-x-2">
                <Button 
                  onClick={() => updateItem(item.id, { content: 'Updated ' + Date.now() })}
                  variant="outline"
                  disabled={loading}
                >
                  Update
                </Button>
                <Button 
                  onClick={() => deleteItem(item.id)}
                  variant="destructive"
                  disabled={loading}
                >
                  Delete
                </Button>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="border rounded-lg shadow-sm">
        <ErrorTest />
      </div>
    </div>
  )
}

================
File: components/error-boundary.tsx
================
"use client"

import { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children?: ReactNode
}

interface State {
  hasError: boolean
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  }

  public static getDerivedStateFromError(_: Error): State {
    return { hasError: true }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo)
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 text-center">
          <h2>Something went wrong.</h2>
          <button
            className="mt-2 underline"
            onClick={() => this.setState({ hasError: false })}
          >
            Try again
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

================
File: components/footer.tsx
================
export function Footer({ className }: { className?: string }) {
  return (
    <footer className={className}>
      {/* Add your footer content here */}
      <div className="container mx-auto py-4">
        <p className="text-center text-sm text-muted-foreground">
          © {new Date().getFullYear()} Your Company Name
        </p>
      </div>
    </footer>
  )
}

================
File: components/next-progress.tsx
================
"use client"

import NProgress from "nprogress"
import { useEffect } from "react"
import { usePathname, useSearchParams } from "next/navigation"

export function NextProgress() {
  const pathname = usePathname()
  const searchParams = useSearchParams()

  useEffect(() => {
    NProgress.configure({ showSpinner: false })
    NProgress.done()
  }, [pathname, searchParams])

  return null
}

================
File: components/test/error-test.test.tsx
================
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import '@testing-library/jest-dom'
import { ErrorTest } from './error-test'
import { useErrorHandler } from '@/lib/errors/handlers'
import { ValidationError, AuthError, NetworkError, NotFoundError } from '@/lib/errors/base'
import { ErrorCode } from '@/lib/errors/codes'

// Mock the useErrorHandler hook
jest.mock('@/lib/errors/handlers', () => ({
  useErrorHandler: jest.fn()
}))

// Mock the toast hook since we're not testing UI feedback
jest.mock('@/hooks/use-toast', () => ({
  useToast: () => ({
    toast: jest.fn()
  })
}))

describe('ErrorTest Component', () => {
  let mockHandleError: jest.Mock

  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks()
    
    // Setup mock error handler
    mockHandleError = jest.fn()
    ;(useErrorHandler as jest.Mock).mockReturnValue(mockHandleError)

    // Reset timers before each test
    jest.useFakeTimers()
  })

  afterEach(() => {
    jest.useRealTimers()
  })

  it('should handle validation error correctly', async () => {
    render(<ErrorTest />)
    
    const button = screen.getByRole('button', { name: /test validation error/i })
    expect(button).toBeInTheDocument()
    
    fireEvent.click(button)
    
    expect(mockHandleError).toHaveBeenCalledWith(
      expect.any(ValidationError)
    )
    
    const error = mockHandleError.mock.calls[0][0]
    expect(error).toBeInstanceOf(ValidationError)
    expect(error.code).toBe(ErrorCode.VALIDATION_ERROR)
    expect(error.message).toBe('Invalid email format')
    expect(error.details).toEqual({ field: 'email' })
  })

  it('should handle auth error correctly', async () => {
    render(<ErrorTest />)
    
    const button = screen.getByRole('button', { name: /test auth error/i })
    expect(button).toBeInTheDocument()
    
    fireEvent.click(button)
    
    expect(mockHandleError).toHaveBeenCalledWith(
      expect.any(AuthError)
    )
    
    const error = mockHandleError.mock.calls[0][0]
    expect(error).toBeInstanceOf(AuthError)
    expect(error.code).toBe(ErrorCode.AUTH_ERROR)
    expect(error.message).toBe('Session has expired')
  })

  it('should handle network error correctly', async () => {
    render(<ErrorTest />)
    
    const button = screen.getByRole('button', { name: /test network error/i })
    expect(button).toBeInTheDocument()
    
    fireEvent.click(button)
    
    expect(mockHandleError).toHaveBeenCalledWith(
      expect.any(NetworkError)
    )
    
    const error = mockHandleError.mock.calls[0][0]
    expect(error).toBeInstanceOf(NetworkError)
    expect(error.code).toBe(ErrorCode.NETWORK_ERROR)
    expect(error.message).toBe('Failed to connect to the server')
  })

  it('should handle not found error correctly', async () => {
    render(<ErrorTest />)
    
    const button = screen.getByRole('button', { name: /test not found error/i })
    expect(button).toBeInTheDocument()
    
    fireEvent.click(button)
    
    expect(mockHandleError).toHaveBeenCalledWith(
      expect.any(NotFoundError)
    )
    
    const error = mockHandleError.mock.calls[0][0]
    expect(error).toBeInstanceOf(NotFoundError)
    expect(error.code).toBe(ErrorCode.NOT_FOUND)
    expect(error.message).toBe('User profile not found')
  })

  it('should handle async error correctly', async () => {
    render(<ErrorTest />)
    
    const button = screen.getByRole('button', { name: /test async error/i })
    expect(button).toBeInTheDocument()
    
    fireEvent.click(button)
    
    // Button should be disabled while loading
    expect(button).toHaveAttribute('disabled')
    expect(screen.getByText('Loading...')).toBeInTheDocument()
    
    // Fast-forward timer to complete the setTimeout
    jest.advanceTimersByTime(1000)
    
    // Need to use await act here because we're testing async state updates
    await waitFor(() => {
      expect(mockHandleError).toHaveBeenCalledWith(expect.any(NetworkError))
    }, { timeout: 2000 })
    
    const error = mockHandleError.mock.calls[0][0]
    expect(error).toBeInstanceOf(NetworkError)
    expect(error.code).toBe(ErrorCode.NETWORK_ERROR)
    expect(error.message).toBe('API request failed')
    expect(error.details).toEqual({
      endpoint: '/api/test',
      status: 503
    })
    
    // Button should be re-enabled after error
    await waitFor(() => {
      expect(button).not.toHaveAttribute('disabled')
      expect(screen.getByText('Test Async Error')).toBeInTheDocument()
    })
  })
})

================
File: components/test/error-test.tsx
================
import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { useErrorHandler } from '@/lib/errors/handlers'
import { ValidationError, AuthError, NetworkError, NotFoundError } from '@/lib/errors/base'

export function ErrorTest() {
  const handleError = useErrorHandler()
  const [loading, setLoading] = useState(false)

  const simulateValidationError = () => {
    try {
      throw new ValidationError('Invalid email format', { field: 'email' })
    } catch (error) {
      handleError(error)
    }
  }

  const simulateAuthError = () => {
    try {
      throw new AuthError('Session has expired')
    } catch (error) {
      handleError(error)
    }
  }

  const simulateNetworkError = () => {
    try {
      throw new NetworkError('Failed to connect to the server')
    } catch (error) {
      handleError(error)
    }
  }

  const simulateNotFoundError = () => {
    try {
      throw new NotFoundError('User profile not found')
    } catch (error) {
      handleError(error)
    }
  }

  const simulateAsyncError = async () => {
    try {
      setLoading(true)
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000))
      throw new NetworkError('API request failed', { 
        endpoint: '/api/test',
        status: 503 
      })
    } catch (error) {
      handleError(error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-4 p-4">
      <h2 className="text-2xl font-bold mb-4">Error Handling Test</h2>
      
      <div className="flex flex-col gap-2">
        <Button 
          onClick={simulateValidationError}
          variant="outline"
        >
          Test Validation Error
        </Button>

        <Button 
          onClick={simulateAuthError}
          variant="outline"
        >
          Test Auth Error
        </Button>

        <Button 
          onClick={simulateNetworkError}
          variant="outline"
        >
          Test Network Error
        </Button>

        <Button 
          onClick={simulateNotFoundError}
          variant="outline"
        >
          Test Not Found Error
        </Button>

        <Button 
          onClick={simulateAsyncError}
          variant="outline"
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Test Async Error'}
        </Button>
      </div>
    </div>
  )
}

================
File: components/theme-provider.tsx
================
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

type ThemeProviderProps = React.ComponentProps<typeof NextThemesProvider>;

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return (
    <NextThemesProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
      {...props}
    >
      {children}
    </NextThemesProvider>
  );
}

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/components/ui/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/components/ui/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: components/ui/navigation-menu.tsx
================
"use client"

import Link from "next/link"
import { cn } from "@/components/ui/utils"

interface NavigationProps {
  className?: string
  children?: React.ReactNode
}

export function Navigation({ className, children }: NavigationProps) {
  return (
    <nav className={cn("border-b bg-background", className)}>
      <div className="container flex h-14 items-center px-4">
        <Link href="/" className="font-bold">
          Your App
        </Link>
        <div className="ml-auto flex items-center space-x-4">
          {children}
        </div>
      </div>
    </nav>
  )
}

================
File: components/ui/navigation.tsx
================
"use client"

import Link from "next/link"
import { cn } from "@/components/ui/utils"

interface NavigationProps {
  className?: string
  children?: React.ReactNode
}

export function Navigation({ className, children }: NavigationProps) {
  return (
    <nav className={cn("border-b bg-background", className)}>
      <div className="container flex h-14 items-center px-4">
        <Link href="/" className="font-bold">
          Your App
        </Link>
        <div className="ml-auto flex items-center space-x-4">
          {children}
        </div>
      </div>
    </nav>
  )
}

================
File: components/ui/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/components/ui/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: components/ui/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: components/ui/utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: lib/errors/base.ts
================
import { ErrorCode } from './codes'

export class AppError extends Error {
  constructor(
    message: string,
    public code: ErrorCode,
    public status: number = 500,
    public details?: unknown,
    public timestamp: Date = new Date()
  ) {
    super(message)
    this.name = 'AppError'
    // Maintains proper stack trace for where error was thrown (if available)
    if (Error.captureStackTrace && typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor)
    } else {
      this.stack = new Error().stack
    }
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      status: this.status,
      details: this.details,
      timestamp: this.timestamp,
      stack: this.stack
    }
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.VALIDATION_ERROR, 400, details)
    this.name = 'ValidationError'
  }
}

export class AuthError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.AUTH_ERROR, 401, details)
    this.name = 'AuthError'
  }
}

export class NotFoundError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.NOT_FOUND, 404, details)
    this.name = 'NotFoundError'
  }
}

export class NetworkError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, ErrorCode.NETWORK_ERROR, 503, details)
    this.name = 'NetworkError'
  }
}

export const isAppError = (error: unknown): error is AppError => {
  return error instanceof AppError
}

================
File: lib/errors/codes.ts
================
export enum ErrorCode {
  // Authentication & Authorization
  AUTH_ERROR = 'AUTH_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  
  // Validation & Data
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INVALID_INPUT = 'INVALID_INPUT',
  NOT_FOUND = 'NOT_FOUND',
  DUPLICATE_ENTRY = 'DUPLICATE_ENTRY',
  
  // Network & External Services
  NETWORK_ERROR = 'NETWORK_ERROR',
  API_ERROR = 'API_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT = 'TIMEOUT',
  
  // Database
  DB_ERROR = 'DB_ERROR',
  QUERY_ERROR = 'QUERY_ERROR',
  
  // Application
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  NOT_IMPLEMENTED = 'NOT_IMPLEMENTED'
}

================
File: lib/errors/handlers.ts
================
import { type ToastProps } from '@/components/ui/toast'
import { useToast } from '@/hooks/use-toast'
import { AppError } from './base'
import { ErrorCode } from './codes'

interface ErrorToastConfig {
  [key: string]: {
    title: string
    variant: ToastProps['variant']
  }
}

const ERROR_TOAST_CONFIG: ErrorToastConfig = {
  [ErrorCode.AUTH_ERROR]: {
    title: 'Authentication Error',
    variant: 'destructive',
  },
  [ErrorCode.VALIDATION_ERROR]: {
    title: 'Validation Error',
    variant: 'destructive',
  },
  [ErrorCode.NETWORK_ERROR]: {
    title: 'Network Error',
    variant: 'destructive',
  },
  [ErrorCode.NOT_FOUND]: {
    title: 'Not Found',
    variant: 'destructive',
  },
  DEFAULT: {
    title: 'Error',
    variant: 'destructive',
  },
}

export function logError(error: unknown) {
  if (error instanceof AppError) {
    console.error(`[${error.code}] ${error.message}`, {
      details: error.details,
      timestamp: error.timestamp,
      stack: error.stack,
    })
  } else {
    console.error('Unhandled error:', error)
  }
}

export function useErrorHandler() {
  const { toast } = useToast()

  return (error: unknown) => {
    // Log the error
    logError(error)

    // Show toast notification
    if (error instanceof AppError) {
      const config = ERROR_TOAST_CONFIG[error.code] || ERROR_TOAST_CONFIG.DEFAULT
      toast({
        title: config.title,
        description: error.message,
        variant: config.variant,
      })
      return
    }

    // Handle unknown errors
    toast({
      title: ERROR_TOAST_CONFIG.DEFAULT.title,
      description: 'An unexpected error occurred',
      variant: 'destructive',
    })
  }
}

// API error handler middleware
export async function apiErrorHandler(error: unknown) {
  if (error instanceof AppError) {
    return new Response(JSON.stringify(error.toJSON()), {
      status: error.status,
      headers: { 'Content-Type': 'application/json' },
    })
  }

  const appError = new AppError(
    'An unexpected error occurred',
    ErrorCode.INTERNAL_ERROR,
    500,
    error
  )
  
  return new Response(JSON.stringify(appError.toJSON()), {
    status: 500,
    headers: { 'Content-Type': 'application/json' },
  })
}

================
File: lib/supabase/client-singleton.ts
================
import { createClient, SupabaseClient } from '@supabase/supabase-js'

class SupabaseClientSingleton {
  private static instance: SupabaseClient | null = null
  private static currentToken: string | null = null

  private constructor() {}

  static async getInstance(token?: string | null): Promise<SupabaseClient> {
    try {
      // If instance exists and token hasn't changed, return existing instance
      if (this.instance && token === this.currentToken) {
        return this.instance
      }

      // Create new instance with updated token
      this.currentToken = token || null
      this.instance = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_KEY!,
        {
          global: {
            headers: token ? {
              Authorization: `Bearer ${token}`
            } : {}
          },
          auth: {
            persistSession: false
          }
        }
      )

      return this.instance
    } catch (error) {
      console.error('Error getting Supabase instance:', error)
      throw error
    }
  }

  static resetInstance(): void {
    this.instance = null
    this.currentToken = null
  }
}

export default SupabaseClientSingleton

================
File: lib/supabase/client-ssr.ts
================
import { auth } from '@clerk/nextjs/server'
import { createClient } from '@supabase/supabase-js'

export async function createClerkSupabaseClientSsr() {
  // The `useAuth()` hook is used to access the `getToken()` method
  const { getToken } = await auth()

  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!,
    {
      global: {
        // Get the custom Supabase token from Clerk
        fetch: async (url, options = {}) => {
          const clerkToken = await getToken({
            template: 'supabase',
          })

          // Insert the Clerk Supabase token into the headers
          const headers = new Headers(options?.headers)
          headers.set('Authorization', `Bearer ${clerkToken}`)

          // Now call the default fetch
          return fetch(url, {
            ...options,
            headers,
          })
        },
      },
    },
  )
}

================
File: lib/supabase/errors/supabase.ts
================
// src/lib/supabase/errors/supabase.ts

export class SupabaseError extends Error {
    constructor(
      message: string,
      public code: string,
      public status?: number,
      public details?: unknown
    ) {
      super(message)
      this.name = 'SupabaseError'
    }
  
    static fromError(error: unknown): SupabaseError {
      if (error instanceof SupabaseError) {
        return error
      }
  
      // PostgreSQL error codes
      const pgErrorCodes = {
        '23505': 'UNIQUE_VIOLATION',
        '23503': 'FOREIGN_KEY_VIOLATION',
        '42P01': 'UNDEFINED_TABLE',
      }
  
      // Handle Supabase errors
      if (error && typeof error === 'object' && 'code' in error) {
        const code = error.code as string
        const message = 'message' in error ? String(error.message) : 'Unknown error'
        const status = 'status' in error ? Number(error.status) : undefined
        
        return new SupabaseError(
          message,
          pgErrorCodes[code as keyof typeof pgErrorCodes] || code,
          status,
          error
        )
      }
  
      // Handle unknown errors
      return new SupabaseError(
        error instanceof Error ? error.message : 'Unknown error',
        'UNKNOWN_ERROR',
        500,
        error
      )
    }
  }
  
  export const isSupabaseError = (error: unknown): error is SupabaseError => {
    return error instanceof SupabaseError
  }

================
File: lib/supabase/hooks/example-hook.ts
================
// src/lib/supabase/hooks/test.ts

import { useState, useCallback } from 'react'
import { useAuth } from '@clerk/nextjs'
import type { TestItem, CreateTestItem, UpdateTestItem } from '../types/example-types'
import { testService } from '../services/example-service'
import { SupabaseError } from '../errors/supabase'

export function useTestItems() {
  const { getToken } = useAuth()
  const [items, setItems] = useState<TestItem[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<SupabaseError | null>(null)

  const fetchItems = useCallback(async () => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const data = await testService.getAll(token)
      setItems(data)
      setError(null)
    } catch (err) {
      setError(SupabaseError.fromError(err))
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const createItem = useCallback(async (item: CreateTestItem) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const newItem = await testService.create(item, token)
      setItems(prev => [...prev, newItem])
      setError(null)
      return newItem
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const updateItem = useCallback(async (id: string, updates: UpdateTestItem) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      const updated = await testService.update(id, updates, token)
      setItems(prev => prev.map(item => item.id === id ? updated : item))
      setError(null)
      return updated
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  const deleteItem = useCallback(async (id: string) => {
    try {
      setLoading(true)
      const token = await getToken({ template: 'supabase' })
      await testService.delete(id, token)
      setItems(prev => prev.filter(item => item.id !== id))
      setError(null)
    } catch (err) {
      setError(SupabaseError.fromError(err))
      throw err
    } finally {
      setLoading(false)
    }
  }, [getToken])

  return {
    items,
    loading,
    error,
    fetchItems,
    createItem,
    updateItem,
    deleteItem
  }
}

================
File: lib/supabase/README-supa.md
================
// src/lib/supabase/README.md

# Data Fetching Enhancements

## SWR/React Query Integration

When scaling the application, consider adding SWR or React Query for:
- Automatic caching
- Background revalidation
- Optimistic updates
- Request deduplication
- Offline support

### Implementation Location:
```
src/lib/supabase/
  ├── hooks/              
  │   ├── base.ts        # Add base hook with SWR/Query config
  │   └── [domain].ts    # Domain hooks extend base hook
```

### Example Pattern:
```typescript
// hooks/base.ts
import useSWR from 'swr'

export function useQuery<T>(key: string, fetcher: () => Promise<T>) {
  return useSWR(key, fetcher, {
    revalidateOnFocus: false,
    dedupingInterval: 2000
  })
}

// hooks/[domain].ts
export function useItems() {
  const { data, error, mutate } = useQuery(
    'items', 
    () => itemsService.getAll()
  )
  // ... rest of hook logic
}
```

Choose SWR for lighter needs, React Query for more complex requirements.

================
File: lib/supabase/services/base.ts
================
// src/lib/supabase/services/base.ts

import { SupabaseClient } from '@supabase/supabase-js'
import { SupabaseError } from '../errors/supabase'
import SupabaseClientSingleton from '../client-singleton'

export abstract class BaseService {
  protected supabase: SupabaseClient | null = null
  
  constructor(protected token?: string | null) {}
  
  protected async getClient(token?: string | null): Promise<SupabaseClient> {
    try {
      this.supabase = await SupabaseClientSingleton.getInstance(token)
      return this.supabase
    } catch (error) {
      throw SupabaseError.fromError(error)
    }
  }

  protected handleError(error: unknown): never {
    throw SupabaseError.fromError(error)
  }

  protected async withErrorHandling<T>(operation: () => Promise<T>): Promise<T> {
    try {
      return await operation()
    } catch (error) {
      this.handleError(error)
    }
  }
}

================
File: lib/supabase/services/example-service.ts
================
// src/lib/supabase/services/test.ts

import { BaseService } from './base'
import type { TestItem, CreateTestItem, UpdateTestItem } from '../types/example-types'

export class TestService extends BaseService {
  private readonly table = 'test_items'

  async getAll(token?: string | null): Promise<TestItem[]> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
      
      if (error) throw error
      return data
    })
  }

  async create(item: CreateTestItem, token?: string | null): Promise<TestItem> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      
      // Get the user_id from the JWT claims
      const { data: claims, error: claimsError } = await client.rpc('requesting_user_id')
      if (claimsError) throw claimsError
      if (!claims) throw new Error('No user ID found in JWT claims')

      // Insert with explicit user_id
      const { data, error } = await client
        .from(this.table)
        .insert({ ...item, user_id: claims })
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async update(id: string, updates: UpdateTestItem, token?: string | null): Promise<TestItem> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update(updates)
        .eq('id', id)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async delete(id: string, token?: string | null): Promise<void> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { error } = await client
        .from(this.table)
        .delete()
        .eq('id', id)
      
      if (error) throw error
    })
  }

  async testGetUser() {
    const client = await this.getClient()
    const { data: { user }, error } = await client.auth.getUser()
    
    console.log('User data:', user);
    console.log('Error:', error);
  }
}

export const testService = new TestService()

================
File: lib/supabase/setup-auth-db.md
================
// lib/supabase.ts

/**
 * IMPORTANT: Clerk + Supabase Integration Pattern
 * ----------------------------------------------
 * 
 * When using Clerk authentication with Supabase in this project:
 * 
 * 1. User IDs:
 *    - Clerk uses string IDs (e.g., "user_2rxQpCGXdYW7ZZu3Q9258lZS7o3")
 *    - Never use UUID type for user IDs in Supabase
 *    - Always use TEXT type for user_id columns
 * 
 * 2. Database Tables:
 *    ✅ DO: user_id TEXT NOT NULL
 *    ❌ DON'T: user_id UUID NOT NULL
 * 
 * 3. RLS Policies:
 *    ✅ DO: auth.jwt()->>'sub'
 *    ❌ DON'T: auth.uid()
 * 
 * 4. Storage Bucket Setup:
 *    a. Drop existing policies
 *    b. Ensure owner/owner_id columns are TEXT type
 *    c. Create policies using JWT checks:
 *       USING (
 *         bucket_id = 'your_bucket_name' AND
 *         (auth.jwt()->>'sub')::text IS NOT NULL
 *       )
 * 
 * This pattern prevents UUID/string type mismatches between 
 * Clerk's authentication and Supabase's storage/database systems.
 */

================
File: lib/supabase/types/example-types.ts
================
// src/lib/supabase/types/test.ts

export interface TestItem {
    id: string
    created_at: string
    content: string
  }
  
  export type CreateTestItem = Omit<TestItem, 'id' | 'created_at'>
  export type UpdateTestItem = Partial<CreateTestItem>

================
File: middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isPublicRoute = createRouteMatcher(['/', '/auth/sign-in(.*)', '/auth/sign-up(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (isPublicRoute(req)) return // if it's a public route, do nothing
  await auth.protect() // for any other route, require auth
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
