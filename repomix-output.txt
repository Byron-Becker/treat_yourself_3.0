This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/course-card.tsx
components/course-grid.tsx
components/dashboard-layout.tsx
components/nav-bar.tsx
components/progress-overview.tsx
components/streak-display.tsx
components/task-list.tsx
hooks/__tests__/use-dashboard-state.test.ts
hooks/use-dashboard-state.ts
hooks/use-progress-tracking.ts
hooks/use-user-activity.ts
index.tsx
layout.tsx
model/dashboard-state.ts
model/progress-tracking.ts
model/user-activity.ts
page.tsx
services/__tests__/activity.service.ts
services/__tests__/dashboard.service.test.ts
services/__tests__/progress.service.ts
services/activity.service.ts
services/dashboard.service.ts
services/progress.service.ts
types/api.types.ts
types/dashboard.types.ts
types/progress.types.ts
types/service.types.ts

================================================================
Files
================================================================

================
File: components/course-card.tsx
================
import { Card, CardContent } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import Link from "next/link"
import { cn } from "@/components/ui/utils"

interface CourseCardProps {
  subject: string
  level: number
  title: string
  icon: React.ReactNode
  color: string
  href: string
  disabled?: boolean
}

export function CourseCard({ 
  subject, 
  level, 
  title, 
  icon, 
  color, 
  href, 
  disabled 
}: CourseCardProps) {
  const content = (
    <Card className={cn(
      "w-full transition-all",
      disabled ? "opacity-50 cursor-not-allowed" : "hover:shadow-md"
    )}>
      <CardContent className="p-6">
        <div className="mb-4">{icon}</div>
        <div className={cn("text-sm mb-2", color)}>
          {subject} Â· LEVEL {level}
        </div>
        <h3 className="font-semibold text-lg">{title}</h3>
        <Button 
          variant="default" 
          className="w-full mt-4 bg-black text-white hover:bg-black/90 md:hidden"
          disabled={disabled}
        >
          {disabled ? 'Complete initial exam first' : 'Start lesson'}
        </Button>
      </CardContent>
    </Card>
  )

  if (disabled) {
    return content
  }

  return (
    <Link href={href} className="block">
      {content}
    </Link>
  )
}

================
File: components/course-grid.tsx
================
'use client'

import { useDashboardState } from "../hooks/use-dashboard-state"
import { CourseCard } from "./course-card"
import { ArrowUpRight, Timer } from "lucide-react"

export function CourseGrid() {
  const { canAccessLessons, isLoading } = useDashboardState()

  if (isLoading) {
    return <CourseGridSkeleton />
  }

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">Available Lessons</h2>
      <div className="grid gap-4">
        <CourseCard
          subject="POSTURE"
          level={1}
          title="Understanding Good Posture"
          icon={<ArrowUpRight className="w-8 h-8 text-blue-500" />}
          color="text-blue-500"
          href="/lessons/posture-lesson"
          disabled={!canAccessLessons}
        />
        <CourseCard
          subject="EXERCISE"
          level={1}
          title="Exercise Fundamentals"
          icon={<Timer className="w-8 h-8 text-purple-500" />}
          color="text-purple-500"
          href="/lessons/exercise-lesson"
          disabled={!canAccessLessons}
        />
      </div>
    </div>
  )
}

function CourseGridSkeleton() {
  return (
    <div className="space-y-4 animate-pulse">
      {/* Skeleton content */}
    </div>
  )
}

================
File: components/dashboard-layout.tsx
================
'use client'

import { NavBar } from "./nav-bar"
import { StreakDisplay } from "./streak-display"
import { TaskList } from "./task-list"
import { CourseGrid } from "./course-grid"
import { ProgressOverview } from "./progress-overview"

export function DashboardLayout() {
  return (
    <>
      <NavBar />
      <main className="container mx-auto p-4 md:p-6 max-w-5xl mt-16">
        <div className="grid md:grid-cols-2 gap-6">
          <div className="space-y-6">
            <TaskList />
            <ProgressOverview />
            <StreakDisplay />
          </div>
          <CourseGrid />
        </div>
      </main>
    </>
  )
}

================
File: components/nav-bar.tsx
================
'use client'

import Image from "next/image"
import Link from "next/link"
import { UserButton } from "@clerk/nextjs"
import { cn } from "@/components/ui/utils"

export function NavBar() {
  return (
    <nav className="fixed top-0 left-0 right-0 bg-white border-b z-50">
      <div className="container mx-auto px-4">
        <div className="flex items-center justify-between h-16">
          {/* Logo and Main Nav */}
          <div className="flex items-center gap-8">
            <Link href="/" className="hidden md:block">
              <Image 
                src="/logo.png"
                alt="Logo"
                width={120}
                height={40}
                priority
              />
            </Link>
            <div className="flex gap-6">
              <NavLink href="/" active>
                Home
              </NavLink>
              <NavLink href="/insights">
                Insights
              </NavLink>
              <NavLink href="/logs">
                Logs
              </NavLink>
            </div>
          </div>

          {/* User Menu */}
          <div className="flex items-center gap-4">
            <UserButton afterSignOutUrl="/" />
          </div>
        </div>
      </div>
    </nav>
  )
}

interface NavLinkProps {
  href: string
  children: React.ReactNode
  active?: boolean
}

function NavLink({ href, children, active }: NavLinkProps) {
  return (
    <Link 
      href={href} 
      className={cn(
        "text-sm font-medium transition-colors",
        active ? "text-foreground" : "text-muted-foreground hover:text-foreground"
      )}
    >
      {children}
    </Link>
  )
}

================
File: components/progress-overview.tsx
================
'use client'

import { Card, CardContent } from "@/components/ui/card"
import { useDashboardState } from "../hooks/use-dashboard-state"
import { BadgeCheck, Clock } from "lucide-react"

export function ProgressOverview() {
  const { state, isLoading } = useDashboardState()

  if (isLoading) {
    return <ProgressOverviewSkeleton />
  }

  const totalLessons = 2 // Hardcoded for now
  const completedLessons = Object.values(state.lessonCompletions).length

  return (
    <Card>
      <CardContent className="p-6">
        <h2 className="text-xl font-semibold mb-4">Your Progress</h2>
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <BadgeCheck className="h-5 w-5 text-green-500" />
              <span className="text-sm text-muted-foreground">Completed</span>
            </div>
            <p className="text-2xl font-bold">{completedLessons}</p>
          </div>
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <Clock className="h-5 w-5 text-blue-500" />
              <span className="text-sm text-muted-foreground">Remaining</span>
            </div>
            <p className="text-2xl font-bold">{totalLessons - completedLessons}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}

function ProgressOverviewSkeleton() {
  return (
    <Card>
      <CardContent className="p-6 animate-pulse">
        {/* Skeleton content */}
      </CardContent>
    </Card>
  )
}

================
File: components/streak-display.tsx
================
// features/dashboard/components/streak-display.tsx
'use client'

import { Card, CardContent } from "@/components/ui/card"
import { useProgressTracking } from "../hooks/use-progress-tracking"
import { Zap } from "lucide-react"
import { cn } from "@/components/ui/utils"

export function StreakDisplay() {
  const { streakData, isLoading } = useProgressTracking()

  if (isLoading) {
    return <StreakDisplaySkeleton />
  }

  const today = new Date().toISOString().split('T')[0]
  const days = [
    { label: "Mon", date: getDateForDay(1) },
    { label: "Tue", date: getDateForDay(2) },
    { label: "Wed", date: getDateForDay(3) },
    { label: "Thu", date: getDateForDay(4) },
    { label: "Fri", date: getDateForDay(5) },
    { label: "Sat", date: getDateForDay(6) },
    { label: "Sun", date: getDateForDay(0) },
  ].map(day => ({
    ...day,
    isActive: streakData.dates.includes(day.date),
    isToday: day.date === today
  }))

  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-semibold">Daily Check-in</h2>
          <div className="flex items-center gap-2">
            <span className="text-3xl font-bold">{streakData.currentStreak}</span>
            <Zap className={cn(
              "h-6 w-6",
              streakData.currentStreak > 0 ? "text-yellow-500" : "text-gray-200"
            )} />
          </div>
        </div>

        <div className="flex justify-between">
          {days.map((day) => (
            <div key={day.label} className="flex flex-col items-center">
              <div className={cn(
                "w-10 h-10 rounded-full border-2 flex items-center justify-center mb-2",
                day.isActive ? "border-primary bg-primary/10" : "border-gray-200",
                day.isToday && "ring-2 ring-offset-2 ring-primary"
              )}>
                <Zap className={cn(
                  "h-5 w-5",
                  day.isActive ? "text-primary" : "text-gray-200"
                )} />
              </div>
              <span className={cn(
                "text-sm",
                day.isToday ? "font-semibold" : "text-muted-foreground"
              )}>
                {day.label}
              </span>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  )
}

function StreakDisplaySkeleton() {
  return (
    <Card>
      <CardContent className="p-6 animate-pulse">
        {/* Skeleton content */}
      </CardContent>
    </Card>
  )
}

function getDateForDay(dayNumber: number): string {
  const today = new Date()
  const currentDay = today.getDay()
  let diff = dayNumber - currentDay
  if (dayNumber === 0) {
    diff = 7 - currentDay
  }
  const targetDate = new Date(today)
  targetDate.setDate(today.getDate() + diff)
  return targetDate.toISOString().split('T')[0]
}

================
File: components/task-list.tsx
================
'use client'

import { Check } from "lucide-react"
import Link from "next/link"
import { useDashboardState } from "../hooks/use-dashboard-state"
import { useUserActivity } from "../hooks/use-user-activity"

export function TaskList() {
  const { state, canAccessLessons, canAccessExercises } = useDashboardState()
  const { needsAssessment } = useUserActivity()

  const today = new Date().toISOString().split('T')[0]
  const hasCompletedTodaysExercise = state.exerciseState.lastCompletedAt === today

  return (
    <div className="p-6 bg-green-50 rounded-lg border border-green-200">
      <h3 className="font-semibold text-xl mb-4">Your To-Do List</h3>
      <div className="space-y-3">
        <TaskItem
          isCompleted={state.initialExam.isCompleted}
          label="Complete your initial exam"
          href="/initial-exam"
          disabledLabel="Complete your initial exam"
        />

        <TaskItem
          isCompleted={state.lessonCompletions['exercise-lesson']?.isCompleted}
          label="Complete exercise lesson"
          href="/lessons/exercise-lesson"
          disabled={!canAccessLessons}
          disabledLabel="Complete initial exam first"
        />

        <TaskItem
          isCompleted={hasCompletedTodaysExercise}
          label="Complete your daily exercise"
          href="/exercise-progression/1"
          disabled={!canAccessExercises}
          disabledLabel="Complete exercise lesson first"
        />

        <TaskItem
          isCompleted={!needsAssessment}
          label="Complete Movement Analysis"
          href="/range-of-motion"
          disabled={!canAccessExercises}
          disabledLabel="Complete exercise lesson first"
        />
      </div>
    </div>
  )
}

interface TaskItemProps {
  isCompleted: boolean
  label: string
  href: string
  disabled?: boolean
  disabledLabel?: string
}

function TaskItem({ isCompleted, label, href, disabled, disabledLabel }: TaskItemProps) {
  return (
    <div className="flex items-center gap-3">
      <div className={`w-5 h-5 rounded-full flex items-center justify-center
        ${isCompleted ? 'bg-green-500' : 'border-2 border-gray-300'}`}>
        {isCompleted && <Check className="w-3 h-3 text-white" />}
      </div>
      
      {isCompleted ? (
        <span className="text-gray-600 line-through">{label}</span>
      ) : disabled ? (
        <span className="text-gray-400">{disabledLabel}</span>
      ) : (
        <Link href={href} className="text-blue-600 hover:underline">
          {label}
        </Link>
      )}
    </div>
  )
}

================
File: hooks/__tests__/use-dashboard-state.test.ts
================
import { renderHook, act } from '@testing-library/react'
import { useDashboardState } from '../use-dashboard-state'
import { DashboardService } from '../../services/dashboard.service'

jest.mock('@clerk/nextjs', () => ({
  useAuth: () => ({
    getToken: jest.fn().mockResolvedValue('mock-token')
  })
}))

jest.mock('../../services/dashboard.service')

describe('useDashboardState', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should initialize with loading state', () => {
    const { result } = renderHook(() => useDashboardState())
    
    expect(result.current.isLoading).toBe(true)
    expect(result.current.error).toBeNull()
  })

  it('should update state when initial exam data is loaded', async () => {
    const mockExam = {
      id: '1',
      is_completed: true,
      body_map_id: '123',
      created_at: new Date().toISOString()
    }

    ;(DashboardService.prototype.getInitialExamStatus as jest.Mock).mockResolvedValue({
      data: mockExam,
      error: null
    })

    const { result, waitForNextUpdate } = renderHook(() => useDashboardState())
    
    await waitForNextUpdate()

    expect(result.current.state.initialExam.isCompleted).toBe(true)
    expect(result.current.canAccessLessons).toBe(true)
  })

  // Add more tests...
})

================
File: hooks/use-dashboard-state.ts
================
import { useState, useEffect } from 'react'
import { useAuth } from '@clerk/nextjs'
import { DashboardStateModel } from '../model/dashboard-state'
import { DashboardService } from '../services/dashboard.service'

export function useDashboardState() {
  const { getToken } = useAuth()
  const [dashboardModel] = useState(() => new DashboardStateModel())
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    async function loadDashboardState() {
      try {
        setIsLoading(true)
        const token = await getToken({ template: 'supabase' })
        const service = new DashboardService(token)

        const [examResponse, completionsResponse] = await Promise.all([
          service.getInitialExamStatus(),
          service.getLessonCompletions()
        ])

        if (examResponse.data) {
          dashboardModel.updateInitialExam({
            id: examResponse.data.id,
            isCompleted: examResponse.data.is_completed,
            bodyMapId: examResponse.data.body_map_id,
            createdAt: examResponse.data.created_at
          })
        }

        if (completionsResponse.data) {
          completionsResponse.data.forEach(completion => {
            dashboardModel.updateLessonCompletion(completion.lesson_id, {
              id: completion.id,
              isCompleted: true,
              completedAt: completion.completed_at
            })
          })
        }
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Failed to load dashboard'))
      } finally {
        setIsLoading(false)
      }
    }

    loadDashboardState()
  }, [getToken, dashboardModel])

  return {
    state: dashboardModel.getState(),
    canAccessLessons: dashboardModel.canAccessLessons(),
    canAccessExercises: dashboardModel.canAccessExercises(),
    isLoading,
    error
  }
}

================
File: hooks/use-progress-tracking.ts
================
import { useState, useEffect } from 'react'
import { useAuth } from '@clerk/nextjs'
import { ProgressTrackingModel } from '../model/progress-tracking'
import { ProgressService } from '../services/progress.service'


export function useProgressTracking() {
  const { getToken } = useAuth()
  const [progressModel] = useState(() => new ProgressTrackingModel())
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    async function loadProgressData() {
      try {
        setIsLoading(true)
        const token = await getToken({ template: 'supabase' })
        const service = new ProgressService(token)
        
        const activityResponse = await service.getActivityDates({
          from: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()
        })

        if (activityResponse.data) {
          activityResponse.data.forEach(date => {
            progressModel.addActivity({
              date,
              type: 'exercise',
              id: date
            })
          })
        }
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Failed to load progress'))
      } finally {
        setIsLoading(false)
      }
    }

    loadProgressData()
  }, [getToken, progressModel])

  return {
    streakData: progressModel.getStreakData(),
    activityLog: progressModel.getActivityLog(),
    isLoading,
    error
  }
}

================
File: hooks/use-user-activity.ts
================
import { useState, useEffect } from 'react'
import { useAuth } from '@clerk/nextjs'
import { UserActivityModel } from '../model/user-activity'
import { ActivityService } from '../services/activity.service'

export function useUserActivity() {
  const { getToken } = useAuth()
  const [activityModel] = useState(() => new UserActivityModel())
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    async function loadActivityData() {
      try {
        setIsLoading(true)
        const token = await getToken({ template: 'supabase' })
        const service = new ActivityService(token)

        const [recentActivityResponse, streakResponse] = await Promise.all([
          service.getRecentActivity({ limit: 10 }),
          service.getCurrentStreak()
        ])

        if (recentActivityResponse.data?.[0]) {
          activityModel.recordExercise(
            recentActivityResponse.data[0].completed_at
          )
        }

        if (streakResponse.data) {
          // Update streak in model if needed
          const currentStreak = streakResponse.data
          for (let i = 0; i < currentStreak; i++) {
            const date = new Date()
            date.setDate(date.getDate() - i)
            activityModel.recordExercise(date.toISOString())
          }
        }

      } catch (err) {
        setError(err instanceof Error ? err : new Error('Failed to load activity'))
      } finally {
        setIsLoading(false)
      }
    }

    loadActivityData()
  }, [getToken, activityModel])

  return {
    exerciseStreak: activityModel.getExerciseStreak(),
    totalExercises: activityModel.getTotalExercises(),
    completedLessons: activityModel.getCompletedLessons(),
    needsAssessment: activityModel.needsAssessment(),
    isLoading,
    error
  }
}

================
File: index.tsx
================
export { DashboardLayout } from './components/dashboard-layout'
export { useDashboardState } from './hooks/use-dashboard-state'
export { useProgressTracking } from './hooks/use-progress-tracking'
export { useUserActivity } from './hooks/use-user-activity'

================
File: layout.tsx
================
interface DashboardLayoutProps {
    children: React.ReactNode
  }
  
  export default function DashboardLayout({
    children,
  }: DashboardLayoutProps) {
    return (
      <div className="min-h-screen bg-gray-50">
        {children}
      </div>
    )
  }

================
File: model/dashboard-state.ts
================
import type { DashboardState, InitialExamState, LessonState, ExerciseState } from '../types/dashboard.types'

export class DashboardStateModel {
  private state: DashboardState

  constructor(initial?: Partial<DashboardState>) {
    this.state = {
      initialExam: {
        id: initial?.initialExam?.id ?? null,
        isCompleted: initial?.initialExam?.isCompleted ?? false,
        bodyMapId: initial?.initialExam?.bodyMapId ?? null,
        createdAt: initial?.initialExam?.createdAt ?? null
      },
      lessonCompletions: initial?.lessonCompletions ?? {},
      exerciseState: {
        lastCompletedAt: initial?.exerciseState?.lastCompletedAt ?? null,
        currentStreak: initial?.exerciseState?.currentStreak ?? 0,
        totalSessions: initial?.exerciseState?.totalSessions ?? 0
      },
      romAssessmentLastCompletedAt: initial?.romAssessmentLastCompletedAt ?? null
    }
  }

  updateInitialExam(exam: InitialExamState): void {
    this.state.initialExam = exam
  }

  updateLessonCompletion(lessonId: string, completion: LessonState): void {
    this.state.lessonCompletions[lessonId] = completion
  }

  updateExerciseState(exercise: ExerciseState): void {
    this.state.exerciseState = exercise
  }

  updateROMAssessment(completedAt: string): void {
    this.state.romAssessmentLastCompletedAt = completedAt
  }

  canAccessLessons(): boolean {
    return this.state.initialExam.isCompleted
  }

  canAccessExercises(): boolean {
    return this.state.initialExam.isCompleted && 
           this.isLessonCompleted('exercise-lesson')
  }

  isLessonCompleted(lessonId: string): boolean {
    return !!this.state.lessonCompletions[lessonId]?.isCompleted
  }

  hasRecentROMAssessment(): boolean {
    if (!this.state.romAssessmentLastCompletedAt) return false
    
    const threeDaysAgo = new Date()
    threeDaysAgo.setDate(threeDaysAgo.getDate() - 3)
    
    return new Date(this.state.romAssessmentLastCompletedAt) > threeDaysAgo
  }

  getState(): DashboardState {
    return { ...this.state }
  }
}

================
File: model/progress-tracking.ts
================
import type { ProgressState, ActivityLog, StreakData } from '../types/progress.types'

export class ProgressTrackingModel {
  private state: ProgressState

  constructor(initial?: Partial<ProgressState>) {
    this.state = {
      streakData: {
        dates: initial?.streakData?.dates ?? [],
        currentStreak: initial?.streakData?.currentStreak ?? 0,
        bestStreak: initial?.streakData?.bestStreak ?? 0
      },
      activityLog: initial?.activityLog ?? [],
      lastActive: initial?.lastActive ?? null
    }
  }

  addActivity(activity: ActivityLog): void {
    this.state.activityLog.push(activity)
    this.state.lastActive = activity.date
    this.updateStreakData(activity.date)
  }

  private updateStreakData(activityDate: string): void {
    const dates = new Set(this.state.streakData.dates)
    dates.add(activityDate)
    
    this.state.streakData.dates = Array.from(dates).sort()
    this.calculateCurrentStreak()
  }

  private calculateCurrentStreak(): void {
    if (!this.state.streakData.dates.length) {
      this.state.streakData.currentStreak = 0
      return
    }

    // const today = new Date().toISOString().split('T')[0]
    const yesterday = new Date(Date.now() - 86400000)
      .toISOString().split('T')[0]

    const sortedDates = [...this.state.streakData.dates].sort()
    const lastActivityDate = sortedDates[sortedDates.length - 1]

    if (lastActivityDate < yesterday) {
      this.state.streakData.currentStreak = 0
      return
    }

    let streak = 1
    for (let i = sortedDates.length - 2; i >= 0; i--) {
      const currentDate = new Date(sortedDates[i])
      const nextDate = new Date(sortedDates[i + 1])
      
      const diffDays = Math.floor(
        (nextDate.getTime() - currentDate.getTime()) / (1000 * 60 * 60 * 24)
      )
      
      if (diffDays === 1) {
        streak++
      } else {
        break
      }
    }

    this.state.streakData.currentStreak = streak
    this.state.streakData.bestStreak = Math.max(
      this.state.streakData.bestStreak,
      streak
    )
  }

  getStreakData(): StreakData {
    return { ...this.state.streakData }
  }

  getActivityLog(): ActivityLog[] {
    return [...this.state.activityLog]
  }
}

================
File: model/user-activity.ts
================
interface ActivityState {
    lastExerciseDate: string | null
    lastAssessmentDate: string | null
    exerciseStreak: number
    totalExercises: number
    completedLessons: Set<string>
  }
  
  export class UserActivityModel {
    private state: ActivityState
  
    constructor(initial?: Partial<ActivityState>) {
      this.state = {
        lastExerciseDate: initial?.lastExerciseDate ?? null,
        lastAssessmentDate: initial?.lastAssessmentDate ?? null,
        exerciseStreak: initial?.exerciseStreak ?? 0,
        totalExercises: initial?.totalExercises ?? 0,
        completedLessons: new Set(initial?.completedLessons)
      }
    }
  
    recordExercise(date: string): void {
      this.state.lastExerciseDate = date
      this.state.totalExercises++
      this.updateExerciseStreak(date)
    }
  
    recordAssessment(date: string): void {
      this.state.lastAssessmentDate = date
    }
  
    completeLesson(lessonId: string): void {
      this.state.completedLessons.add(lessonId)
    }
  
    private updateExerciseStreak(date: string): void {
      const today = new Date().toISOString().split('T')[0]
      const yesterday = new Date(Date.now() - 86400000)
        .toISOString().split('T')[0]
  
      if (!this.state.lastExerciseDate || 
          this.state.lastExerciseDate < yesterday) {
        this.state.exerciseStreak = 1
      } else if (date === today && 
                 this.state.lastExerciseDate === yesterday) {
        this.state.exerciseStreak++
      }
    }
  
    needsAssessment(): boolean {
      if (!this.state.lastAssessmentDate) return true
  
      const threeDaysAgo = new Date()
      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3)
      
      return new Date(this.state.lastAssessmentDate) < threeDaysAgo
    }
  
    getExerciseStreak(): number {
      return this.state.exerciseStreak
    }
  
    getTotalExercises(): number {
      return this.state.totalExercises
    }
  
    getCompletedLessons(): string[] {
      return Array.from(this.state.completedLessons)
    }
  }

================
File: page.tsx
================
import { DashboardLayout } from './components/dashboard-layout'
import { ErrorBoundary } from '@/components/error-boundary'
import { Suspense } from 'react'

export default function DashboardPage() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<div>Loading dashboard...</div>}>
        <DashboardLayout />
      </Suspense>
    </ErrorBoundary>
  )
}

// Metadata
export const metadata = {
  title: 'Dashboard',
  description: 'Your personal exercise and progress dashboard',
}

================
File: services/__tests__/activity.service.ts
================
import { ActivityService } from '../activity.service'
import { BaseService } from '@/lib/supabase/services/base'

jest.mock('@/lib/supabase/services/base')

describe('ActivityService', () => {
  let service: ActivityService
  let mockSupabaseQuery: any

  beforeEach(() => {
    mockSupabaseQuery = {
      from: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      limit: jest.fn().mockReturnThis()
    }

    ;(BaseService.prototype.getClient as jest.Mock).mockResolvedValue(mockSupabaseQuery)
    ;(BaseService.prototype.withErrorHandling as jest.Mock).mockImplementation(
      (fn) => fn()
    )

    service = new ActivityService()
  })

  describe('getRecentActivity', () => {
    it('should fetch recent activities with limit', async () => {
      const mockActivities = [
        { id: '1', completed_at: '2024-02-12T10:00:00Z' },
        { id: '2', completed_at: '2024-02-11T10:00:00Z' }
      ]

      mockSupabaseQuery.limit.mockResolvedValue({ data: mockActivities, error: null })

      const result = await service.getRecentActivity({ limit: 2 })

      expect(result.data).toEqual(mockActivities)
      expect(mockSupabaseQuery.limit).toHaveBeenCalledWith(2)
    })

    it('should handle errors gracefully', async () => {
      const mockError = new Error('Database error')
      mockSupabaseQuery.select.mockResolvedValue({ data: null, error: mockError })

      await expect(service.getRecentActivity()).rejects.toThrow('Database error')
    })
  })

  describe('getCurrentStreak', () => {
    it('should calculate streak correctly', async () => {
      // Mock current date to be fixed
      jest.useFakeTimers().setSystemTime(new Date('2024-02-12'))

      const mockDates = {
        data: [
          { completed_at: '2024-02-12T10:00:00Z' },
          { completed_at: '2024-02-11T10:00:00Z' },
          { completed_at: '2024-02-10T10:00:00Z' },
          // Gap
          { completed_at: '2024-02-08T10:00:00Z' }
        ],
        error: null
      }

      mockSupabaseQuery.order.mockResolvedValue(mockDates)

      const result = await service.getCurrentStreak()

      expect(result.data).toBe(3) // 3 consecutive days
    })

    it('should return 0 for no recent activity', async () => {
      jest.useFakeTimers().setSystemTime(new Date('2024-02-12'))

      const mockDates = {
        data: [
          { completed_at: '2024-02-09T10:00:00Z' } // 3 days ago
        ],
        error: null
      }

      mockSupabaseQuery.order.mockResolvedValue(mockDates)

      const result = await service.getCurrentStreak()

      expect(result.data).toBe(0)
    })
  })

  afterEach(() => {
    jest.useRealTimers()
  })
})

================
File: services/__tests__/dashboard.service.test.ts
================
import { DashboardService } from '../dashboard.service'
import { BaseService } from '@/lib/supabase/services/base'

jest.mock('@/lib/supabase/services/base')

describe('DashboardService', () => {
  let service: DashboardService
  let mockSupabaseQuery: any

  beforeEach(() => {
    mockSupabaseQuery = {
      from: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      maybeSingle: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      gte: jest.fn().mockReturnThis()
    }

    ;(BaseService.prototype.getClient as jest.Mock).mockResolvedValue(mockSupabaseQuery)
    ;(BaseService.prototype.withErrorHandling as jest.Mock).mockImplementation(
      (fn) => fn()
    )

    service = new DashboardService()
  })

  describe('getInitialExamStatus', () => {
    it('should fetch initial exam status', async () => {
      const mockExam = {
        id: '1',
        is_completed: true,
        created_at: '2024-02-12T10:00:00Z'
      }

      mockSupabaseQuery.maybeSingle.mockResolvedValue({ data: mockExam, error: null })

      const result = await service.getInitialExamStatus()

      expect(result.data).toEqual(mockExam)
      expect(mockSupabaseQuery.from).toHaveBeenCalledWith('initial_exams')
    })

    it('should handle missing exam data', async () => {
      mockSupabaseQuery.maybeSingle.mockResolvedValue({ data: null, error: null })

      const result = await service.getInitialExamStatus()

      expect(result.data).toBeNull()
    })
  })

  describe('getLessonCompletions', () => {
    it('should fetch lesson completions', async () => {
      const mockCompletions = [
        { id: '1', lesson_id: 'lesson1', completed_at: '2024-02-12T10:00:00Z' },
        { id: '2', lesson_id: 'lesson2', completed_at: '2024-02-11T10:00:00Z' }
      ]

      mockSupabaseQuery.order.mockResolvedValue({ data: mockCompletions, error: null })

      const result = await service.getLessonCompletions()

      expect(result.data).toEqual(mockCompletions)
      expect(mockSupabaseQuery.from).toHaveBeenCalledWith('lesson_completions')
    })
  })

  describe('hasRecentROMAssessment', () => {
    it('should check for recent ROM assessment', async () => {
      jest.useFakeTimers().setSystemTime(new Date('2024-02-12'))

      mockSupabaseQuery.gte.mockResolvedValue({ count: 1, error: null })

      const result = await service.hasRecentROMAssessment()

      expect(result.data).toBe(true)
      expect(mockSupabaseQuery.from).toHaveBeenCalledWith('rom_assessments')
    })

    it('should return false when no recent assessments', async () => {
      mockSupabaseQuery.gte.mockResolvedValue({ count: 0, error: null })

      const result = await service.hasRecentROMAssessment()

      expect(result.data).toBe(false)
    })
  })

  afterEach(() => {
    jest.useRealTimers()
  })
})

================
File: services/__tests__/progress.service.ts
================
import { ProgressService } from '../progress.service'
import { BaseService } from '@/lib/supabase/services/base'

jest.mock('@/lib/supabase/services/base')

describe('ProgressService', () => {
  let service: ProgressService
  let mockSupabaseQuery: any

  beforeEach(() => {
    mockSupabaseQuery = {
      from: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      gte: jest.fn().mockReturnThis(),
      lte: jest.fn().mockReturnThis()
    }

    ;(BaseService.prototype.getClient as jest.Mock).mockResolvedValue(mockSupabaseQuery)
    ;(BaseService.prototype.withErrorHandling as jest.Mock).mockImplementation(
      (fn) => fn()
    )

    service = new ProgressService()
  })

  describe('getActivityDates', () => {
    it('should fetch activity dates with date range', async () => {
      const mockActivities = [
        { completed_at: '2024-02-12T10:00:00Z' },
        { completed_at: '2024-02-11T10:00:00Z' }
      ]

      mockSupabaseQuery.lte.mockResolvedValue({ data: mockActivities, error: null })

      const result = await service.getActivityDates({
        from: '2024-02-10',
        to: '2024-02-12'
      })

      expect(result.data).toEqual(['2024-02-12', '2024-02-11'])
      expect(mockSupabaseQuery.from).toHaveBeenCalledWith('exercise_series')
      expect(mockSupabaseQuery.gte).toHaveBeenCalledWith('completed_at', '2024-02-10')
      expect(mockSupabaseQuery.lte).toHaveBeenCalledWith('completed_at', '2024-02-12')
    })

    it('should handle missing date range', async () => {
      const mockActivities = [
        { completed_at: '2024-02-12T10:00:00Z' }
      ]

      mockSupabaseQuery.eq.mockResolvedValue({ data: mockActivities, error: null })

      const result = await service.getActivityDates()

      expect(result.data).toEqual(['2024-02-12'])
    })
  })

  describe('getLessonProgress', () => {
    it('should fetch lesson progress', async () => {
      const mockProgress = [
        { id: '1', lesson_id: 'lesson1', completed: true },
        { id: '2', lesson_id: 'lesson2', completed: false }
      ]

      mockSupabaseQuery.select.mockResolvedValue({ data: mockProgress, error: null })

      const result = await service.getLessonProgress()

      expect(result.data).toEqual(mockProgress)
      expect(mockSupabaseQuery.from).toHaveBeenCalledWith('lesson_completions')
    })

    it('should handle errors', async () => {
      const mockError = new Error('Database error')
      mockSupabaseQuery.select.mockResolvedValue({ data: null, error: mockError })

      await expect(service.getLessonProgress()).rejects.toThrow('Database error')
    })
  })
})

================
File: services/activity.service.ts
================
import { BaseService } from '@/lib/supabase/services/base'
import { ExerciseRecord } from '../types/api.types'
import { BaseResponse, QueryOptions } from '../types/service.types'

export class ActivityService extends BaseService {
  private readonly table = 'exercise_series'

  async getRecentActivity(options?: QueryOptions): Promise<BaseResponse<ExerciseRecord[]>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      let query = client
        .from(this.table)
        .select('*')
        .order('completed_at', { ascending: false })

      if (options?.limit) {
        query = query.limit(options.limit)
      }

      const { data, error } = await query

      if (error) throw error

      return { data, error: null }
    })
  }

  async getCurrentStreak(): Promise<BaseResponse<number>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      const { data: dates, error } = await client
        .from(this.table)
        .select('completed_at')
        .eq('status', 'completed')
        .order('completed_at', { ascending: false })

      if (error) throw error

      // Calculate streak logic
      const streak = this.calculateStreak(dates.map(d => d.completed_at))

      return { data: streak, error: null }
    })
  }

  private calculateStreak(dates: string[]): number {
    if (!dates.length) return 0

    // const today = new Date().toISOString().split('T')[0]
    const yesterday = new Date(Date.now() - 86400000)
      .toISOString().split('T')[0]

    const lastActivity = dates[0].split('T')[0]
    if (lastActivity < yesterday) return 0

    let streak = 1
    for (let i = 1; i < dates.length; i++) {
      const currentDate = new Date(dates[i])
      const prevDate = new Date(dates[i - 1])
      
      const diffDays = Math.floor(
        (prevDate.getTime() - currentDate.getTime()) / (1000 * 60 * 60 * 24)
      )
      
      if (diffDays === 1) streak++
      else break
    }

    return streak
  }
}

================
File: services/dashboard.service.ts
================
import { BaseService } from '@/lib/supabase/services/base'
import { 
  InitialExamRecord, 
  LessonCompletionRecord 
} from '../types/api.types'
import { BaseResponse } from '../types/service.types'

export class DashboardService extends BaseService {
  private readonly examTable = 'initial_exams'
  private readonly completionsTable = 'lesson_completions'
  private readonly romTable = 'rom_assessments'

  async getInitialExamStatus(): Promise<BaseResponse<InitialExamRecord>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      const { data, error } = await client
        .from(this.examTable)
        .select('*')
        .maybeSingle()

      if (error) throw error

      return { data, error: null }
    })
  }

  async getLessonCompletions(): Promise<BaseResponse<LessonCompletionRecord[]>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      const { data, error } = await client
        .from(this.completionsTable)
        .select('*')
        .order('completed_at', { ascending: false })

      if (error) throw error

      return { data, error: null }
    })
  }

  async hasRecentROMAssessment(): Promise<BaseResponse<boolean>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      const threeDaysAgo = new Date()
      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3)

      const { count, error } = await client
        .from(this.romTable)
        .select('*', { count: 'exact', head: true })
        .gte('created_at', threeDaysAgo.toISOString())

      if (error) throw error

      return { data: count ? count > 0 : false, error: null }
    })
  }
}

================
File: services/progress.service.ts
================
import { BaseService } from '@/lib/supabase/services/base'
import { LessonCompletionRecord } from '../types/api.types'
import { BaseResponse, QueryOptions } from '../types/service.types'

export class ProgressService extends BaseService {
  private readonly table = 'exercise_series'

  async getActivityDates(options?: QueryOptions): Promise<BaseResponse<string[]>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      let query = client
        .from(this.table)
        .select('completed_at')
        .eq('status', 'completed')

      if (options?.from) {
        query = query.gte('completed_at', options.from)
      }
      if (options?.to) {
        query = query.lte('completed_at', options.to)
      }

      const { data, error } = await query

      if (error) throw error

      return { 
        data: data.map(record => record.completed_at.split('T')[0]),
        error: null 
      }
    })
  }

  async getLessonProgress(): Promise<BaseResponse<LessonCompletionRecord[]>> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(this.token)
      const { data, error } = await client
        .from('lesson_completions')
        .select('*')

      if (error) throw error

      return { data, error: null }
    })
  }
}

================
File: types/api.types.ts
================
import { DatabaseRecord } from './service.types'

export interface InitialExamRecord extends DatabaseRecord {
  id: string
  user_id: string
  safety_answers: Record<string, unknown>
  treatment_answers: Record<string, unknown>
  body_map_id: string | null
  is_completed: boolean
}

export interface LessonCompletionRecord extends DatabaseRecord {
  id: string
  user_id: string
  lesson_id: string
  completed_at: string
}

// Mock types for exercise data until implemented
export interface ExerciseRecord extends DatabaseRecord {
  id: string
  user_id: string
  type: string
  completed_at: string
  metrics: Record<string, unknown>
}

================
File: types/dashboard.types.ts
================
export interface InitialExamState {
  id: string | null
  isCompleted: boolean
  bodyMapId: string | null
  createdAt: string | null
}

export interface LessonState {
  id: string
  isCompleted: boolean
  completedAt: string | null
}

export interface ExerciseState {
  lastCompletedAt: string | null
  currentStreak: number
  totalSessions: number
}

export interface DashboardState {
  initialExam: InitialExamState
  lessonCompletions: Record<string, LessonState>
  exerciseState: ExerciseState
  romAssessmentLastCompletedAt: string | null
}

================
File: types/progress.types.ts
================
export interface StreakData {
    dates: string[]
    currentStreak: number
    bestStreak: number
  }
  
  export interface ActivityLog {
    date: string
    type: 'exercise' | 'lesson' | 'assessment'
    id: string
  }
  
  export interface ProgressState {
    streakData: StreakData
    activityLog: ActivityLog[]
    lastActive: string | null
  }
  
  export interface DailyProgress {
    date: string
    isCompleted: boolean
  }
  
  export interface CourseProgress {
    courseId: string
    completedLessons: number
    totalLessons: number
    lastAccessed: string | null
  }

================
File: types/service.types.ts
================
export interface BaseResponse<T> {
    data: T | null
    error: Error | null
  }
  
  export interface QueryOptions {
    from?: string
    to?: string
    limit?: number
  }
  
  export interface DatabaseRecord {
    created_at: string
    updated_at?: string
  }



================================================================
End of Codebase
================================================================
