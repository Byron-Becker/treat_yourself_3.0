This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-07T23:26:08.134Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
[lessonId]/components/__tests__/lesson-container.integration.test.tsx
[lessonId]/components/image-error-boundary.tsx
[lessonId]/components/lesson-container.tsx
[lessonId]/components/lesson-header.tsx
[lessonId]/components/loading-overlay.tsx
[lessonId]/components/slides/info-bullet-slide.tsx
[lessonId]/components/slides/info-slide.tsx
[lessonId]/components/slides/question-slide.tsx
[lessonId]/layout.tsx
[lessonId]/page.tsx
actions/lesson-completion.ts
data/exercise-content.ts
data/posture-content.ts
hooks/__tests__/use-lesson-completion.test.ts
hooks/use-lesson-completion.ts
hooks/use-lesson-progress.ts
hooks/use-lesson.ts
hooks/use-slide-interaction.ts
hooks/use-viewport-scroll.ts
model/__tests__/lesson-progress.test.ts
model/__tests__/slide-interaction.test.ts
model/__tests__/viewport-state.test.ts
model/lesson-progress.ts
model/slide-interaction.ts
model/viewport-state.ts
services/__tests__/lesson-completion.service.test.ts
services/__tests__/use-lesson-completion.test.ts
services/lesson-completion.service.ts
services/lesson.service.ts
types/db.types.ts
types/lesson.types.ts

================================================================
Files
================================================================

================
File: [lessonId]/components/__tests__/lesson-container.integration.test.tsx
================
// features/lessons/components/__tests__/lesson-container.integration.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { LessonContainer } from '../lesson-container'
import { useLesson } from '../../../hooks/use-lesson'
import { useLessonCompletion } from '../../../hooks/use-lesson-completion'


jest.mock('../../../hooks/use-lesson')
jest.mock('../../../hooks/use-lesson-completion')


describe('LessonContainer Integration', () => {
  const mockLessonId = 'lesson-1'
  const mockSlides = [
    { id: 'slide-1', type: 'info', title: 'First Slide', body: 'Content 1' },
    { id: 'slide-2', type: 'info', title: 'Last Slide', body: 'Content 2' }
  ]

  beforeEach(() => {
    jest.clearAllMocks()
    
    // Mock useLesson default state
    ;(useLesson as jest.Mock).mockReturnValue({
      lesson: { id: mockLessonId, slides: mockSlides },
      visibleSlides: mockSlides,
      currentIndex: 0,
      completedSlides: new Set(),
      loading: false,
      completeSlide: jest.fn(),
      scrollToSlide: jest.fn(),
      updateSlidePosition: jest.fn()
    })

    // Mock useLessonCompletion default state
    ;(useLessonCompletion as jest.Mock).mockReturnValue({
      complete: jest.fn(),
      isCompleting: false,
      error: null
    })
  })

  it('should complete lesson when all slides are finished', async () => {
    const mockComplete = jest.fn()
    const mockCompleteSlide = jest.fn()

    ;(useLessonCompletion as jest.Mock).mockReturnValue({
      complete: mockComplete,
      isCompleting: false
    })

    ;(useLesson as jest.Mock).mockReturnValue({
      lesson: { id: mockLessonId, slides: mockSlides },
      visibleSlides: mockSlides,
      currentIndex: mockSlides.length - 1,
      completedSlides: new Set([mockSlides[0].id]),
      loading: false,
      completeSlide: mockCompleteSlide,
      scrollToSlide: jest.fn(),
      updateSlidePosition: jest.fn()
    })

    render(<LessonContainer lessonId={mockLessonId} />)

    // Click continue on last slide
    const continueButton = screen.getByText('Continue')
    fireEvent.click(continueButton)

    await waitFor(() => {
      expect(mockCompleteSlide).toHaveBeenCalledWith(mockSlides[1].id)
      expect(mockComplete).toHaveBeenCalled()
    })
  })

  it('should show loading state when completing lesson', async () => {
    ;(useLessonCompletion as jest.Mock).mockReturnValue({
      complete: jest.fn(),
      isCompleting: true
    })

    render(<LessonContainer lessonId={mockLessonId} />)
    expect(screen.getByText('Loading...')).toBeInTheDocument()
  })

  it('should handle slide progression correctly', async () => {
    const mockScrollToSlide = jest.fn()
    
    // Show only first slide
    ;(useLesson as jest.Mock).mockReturnValue({
      lesson: { id: mockLessonId, slides: mockSlides },
      visibleSlides: [mockSlides[0]], // Only show first slide
      currentIndex: 0,
      completedSlides: new Set(),
      loading: false,
      completeSlide: jest.fn(),
      scrollToSlide: mockScrollToSlide,
      updateSlidePosition: jest.fn()
    })

    render(<LessonContainer lessonId={mockLessonId} />)

    const continueButton = screen.getByText('Continue')
    fireEvent.click(continueButton)

    await waitFor(() => {
      expect(mockScrollToSlide).toHaveBeenCalledWith(mockSlides[0].id)
    })
  })
//   it('should handle errors during lesson completion', async () => {
//     const mockError = new Error('Failed to complete lesson')
//     const mockComplete = jest.fn().mockRejectedValue(mockError)
  
//     ;(useLessonCompletion as jest.Mock).mockReturnValue({
//       complete: mockComplete,
//       isCompleting: false,
//       error: mockError
//     })
  
//     render(<LessonContainer lessonId={mockLessonId} />)
  
//     const continueButton = screen.getByText('Continue')
//     fireEvent.click(continueButton)
  
//     await waitFor(() => {
//       expect(mockComplete).toHaveBeenCalled()
//     })
//   })
})

================
File: [lessonId]/components/image-error-boundary.tsx
================
// app/lessons/[lessonId]/components/image-error-boundary.tsx

'use client'

import React from 'react'
import { ImageOff } from 'lucide-react'
import { Button } from '@/components/ui/button'

interface Props {
  children: React.ReactNode
}

interface State {
  hasError: boolean
}

export class ImageErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError() {
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="w-full h-full flex flex-col items-center justify-center gap-4 bg-muted rounded-lg p-8">
          <ImageOff className="h-12 w-12 text-muted-foreground" />
          <p className="text-sm text-muted-foreground">Failed to load image</p>
          <Button 
            variant="outline" 
            size="sm"
            onClick={() => this.setState({ hasError: false })}
          >
            Retry
          </Button>
        </div>
      )
    }

    return this.props.children
  }
}

================
File: [lessonId]/components/lesson-container.tsx
================
// app/lessons/[lessonId]/components/lesson-container.tsx

'use client'

import { useLesson } from '../../hooks/use-lesson'
import { InfoSlide } from '../components/slides/info-slide'
import { QuestionSlide } from '../components/slides/question-slide'
import { InfoBulletSlide } from '../components/slides/info-bullet-slide'
import { LoadingOverlay } from '../components/loading-overlay'
import { cn } from '@/components/ui/utils'
import { memo, useEffect, useRef } from 'react'
import type { Slide } from '../../types/lesson.types'
import { useLessonCompletion } from '../../hooks/use-lesson-completion'

interface LessonContainerProps {
  lessonId: string
}

interface SlideWrapperProps {
  slide: Slide
  index: number
  currentIndex: number
  completedSlides: Set<string>
  interactionState: string
  handleAnswer: (optionId: string, correctOptionId: string) => void
  completeSlide: (slideId: string) => void
  scrollToSlide: (slideId: string) => void
  updateSlidePosition: (slideId: string, bounds: { top: number; bottom: number }) => void
}

const SlideWrapper = memo(function SlideWrapper({ 
  slide, 
  index,
  currentIndex,
  completedSlides,
  interactionState,
  handleAnswer,
  completeSlide,
  scrollToSlide,
  updateSlidePosition 
}: SlideWrapperProps) {
  const prevBoundsRef = useRef<{ top: number; bottom: number } | null>(null);

  return (
    <div 
      className="slide-item"
      ref={el => {
        if (el) {
          const bounds = el.getBoundingClientRect();
          const prevBounds = prevBoundsRef.current;
          if (!prevBounds || prevBounds.top !== bounds.top || prevBounds.bottom !== bounds.bottom) {
            updateSlidePosition(slide.id, {
              top: bounds.top,
              bottom: bounds.bottom
            });
            prevBoundsRef.current = bounds;
          }
        }
      }}
    >
      {slide.type === 'info' && (
        <InfoSlide
          content={slide}
          isActive={index === currentIndex}
          isCompleted={completedSlides.has(slide.id)}
          onComplete={() => {
            completeSlide(slide.id)
            setTimeout(() => {
              scrollToSlide(slide.id);
            }, 100);
          }}
        />
      )}

      {slide.type === 'question' && (
        <QuestionSlide
          content={slide}
          isActive={index === currentIndex}
          isCompleted={completedSlides.has(slide.id)}
          interactionState={interactionState}
          onAnswer={handleAnswer}
          onComplete={() => {
            completeSlide(slide.id)
            setTimeout(() => {
              scrollToSlide(slide.id);
            }, 100);
          }}
        />
      )}

      {slide.type === 'infoBullet' && (
        <InfoBulletSlide
          content={slide}
          isActive={index === currentIndex}
          isCompleted={completedSlides.has(slide.id)}
          onComplete={() => {
            completeSlide(slide.id)
            setTimeout(() => {
              scrollToSlide(slide.id);
            }, 100);
          }}
        />
      )}
    </div>
  )
})

export function LessonContainer({ lessonId }: LessonContainerProps) {
  const {
    lesson,
    visibleSlides,
    currentIndex,
    completedSlides,
    loading,
    interactionState,
    handleAnswer,
    completeSlide,
    scrollToSlide,
    updateSlidePosition,
    lastScrollPosition,
    activeSlideId
  } = useLesson(lessonId)

  const { complete, isCompleting } = useLessonCompletion(lessonId)

  // Handle final slide completion
  const handleFinalSlideCompletion = async (slideId: string) => {
    try {
      // Complete the slide first
      completeSlide(slideId)
      
      // If this was the last slide, attempt to mark as complete
      if (currentIndex === visibleSlides.length - 1) {
        try {
          await complete()
        } catch (error) {
          // Silently ignore duplicate completion errors
          // Still log other errors
          if (!error.message?.includes('duplicate key')) {
            console.error('Error completing lesson:', error)
          }
        }
      }
      
      // Scroll to next slide if available
      setTimeout(() => {
        scrollToSlide(slideId)
      }, 100)
    } catch (error) {
      console.error('Error completing slide:', error)
    }
  }

  useEffect(() => {
    
  }, [lesson]);

  useEffect(() => {
    
  }, [visibleSlides]);

  useEffect(() => {
    
  }, [currentIndex]);

  useEffect(() => {
    
  }, [completedSlides]);

  useEffect(() => {
    
  }, [interactionState]);

  useEffect(() => {
    
  }, [activeSlideId]);

  useEffect(() => {
    
  }, [lastScrollPosition]);

  if (!lesson) return null

  return (
    <main className={cn(
      "w-full max-w-2xl mx-auto",
      "space-y-6 py-6"
    )}>
      {(loading || isCompleting) && <LoadingOverlay />}

      {visibleSlides?.map((slide, index) => (
        <SlideWrapper
          key={slide.id}
          slide={slide}
          index={index}
          currentIndex={currentIndex}
          completedSlides={completedSlides}
          interactionState={interactionState}
          handleAnswer={handleAnswer}
          completeSlide={handleFinalSlideCompletion}
          scrollToSlide={scrollToSlide}
          updateSlidePosition={updateSlidePosition}
        />
      ))}
    </main>
  )
}

================
File: [lessonId]/components/lesson-header.tsx
================
// app/lessons/[lessonId]/components/lesson-header.tsx

'use client'

import { ArrowLeft, CheckCircle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Progress } from '@/components/ui/progress'
import { useRouter } from 'next/navigation'
import { cn } from '@/components/ui/utils'

interface LessonHeaderProps {
  className?: string
  progress: number
  isCompleted?: boolean
}

export function LessonHeader({ className, progress, isCompleted }: LessonHeaderProps) {
 const router = useRouter()

 return (
   <header className={cn(
     "bg-background/80 backdrop-blur-sm border-b",
     "px-4 py-3",
     className
   )}>
     <div className="flex items-center gap-4">
       <Button 
         variant="ghost" 
         size="icon"
         onClick={() => router.back()}
         className="shrink-0"
       >
         <ArrowLeft className="h-5 w-5" />
         <span className="sr-only">Go back</span>
       </Button>

       <div className="flex-1 min-w-0">
         <Progress 
           value={progress}
           className="h-2" 
         />
       </div>

       <div className="shrink-0 text-sm font-medium flex items-center gap-2">
         {progress}%
         {isCompleted && (
           <CheckCircle className="h-4 w-4 text-green-500" />
         )}
       </div>
     </div>
   </header>
 )
}

================
File: [lessonId]/components/loading-overlay.tsx
================
// app/lessons/[lessonId]/components/loading-overlay.tsx

import { cn } from "@/components/ui/utils"

export function LoadingOverlay() {
    return (
      <div className={cn(
        "fixed inset-0 z-50",
        "bg-background/80 backdrop-blur-sm",
        "flex items-center justify-center"
      )}>
        <div className="space-y-4 text-center">
          <div className="animate-spin">
            {/* Loading spinner */}
          </div>
          <p className="text-sm text-muted-foreground">
            Loading...
          </p>
        </div>
      </div>
    )
  }

================
File: [lessonId]/components/slides/info-bullet-slide.tsx
================
// app/lessons/[lessonId]/components/slides/info-bullet-slide.tsx

'use client'

import { motion } from 'framer-motion'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { InfoBulletSlide as InfoBulletSlideType } from '../../../types/lesson.types'
import { cn } from '@/components/ui/utils'
import Image from 'next/image'
import { ImageErrorBoundary } from '../image-error-boundary'

interface InfoBulletSlideProps {
  content: InfoBulletSlideType
  isActive: boolean
  isCompleted: boolean
  onComplete: () => void
}

export function InfoBulletSlide({ 
  content, 
  isActive, 
  isCompleted, 
  onComplete 
}: InfoBulletSlideProps) {
  return (
    <Card className={cn(
      "overflow-hidden transition-all",
      isActive && "ring-2 ring-primary"
    )}>
      <motion.div 
        className="p-6"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        {content.imageUrl && (
          <motion.div 
            className="relative w-full h-[240px] mb-6"
            initial={{ scale: 0.95 }}
            animate={{ scale: 1 }}
          >
            <ImageErrorBoundary>
              <Image
                src={content.imageUrl}
                alt={content.title}
                fill
                className="object-cover rounded-lg"
                sizes="(max-width: 768px) 100vw, 768px"
              />
            </ImageErrorBoundary>
          </motion.div>
        )}

        <motion.h2 
          className="text-2xl font-bold mb-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          {content.title}
        </motion.h2>

        {content.introduction && (
          <motion.p 
            className="text-muted-foreground mb-4"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
          >
            {content.introduction}
          </motion.p>
        )}

        <motion.ul
          className="space-y-3 mb-6"
          initial="hidden"
          animate="visible"
          variants={{
            visible: {
              transition: { staggerChildren: 0.1 }
            }
          }}
        >
          {content.bullets.map((bullet, index) => (
            <motion.li
              key={index}
              className="flex gap-3 text-muted-foreground"
              variants={{
                hidden: { opacity: 0, x: -20 },
                visible: { opacity: 1, x: 0 }
              }}
            >
              <span className="text-primary">â€¢</span>
              <span>{bullet.text}</span>
            </motion.li>
          ))}
        </motion.ul>

        {!isCompleted && (
          <motion.div 
            className="flex justify-end"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
          >
            <Button onClick={onComplete}>Continue</Button>
          </motion.div>
        )}
      </motion.div>
    </Card>
  )
}

================
File: [lessonId]/components/slides/info-slide.tsx
================
// app/lessons/[lessonId]/components/slides/info-slide.tsx

'use client'

import { motion } from 'framer-motion'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { ImageErrorBoundary } from '../image-error-boundary'
import { InfoSlide as InfoSlideType } from '../../../types/lesson.types'
import { cn } from '@/components/ui/utils'
import Image from 'next/image'


interface InfoSlideProps {
  content: InfoSlideType
  isActive: boolean
  isCompleted: boolean
  onComplete: () => void
}

export function InfoSlide({ content, isActive, isCompleted, onComplete }: InfoSlideProps) {
  return (
    <Card className={cn(
      "overflow-hidden transition-all",
      isActive && "ring-2 ring-primary"
    )}>
      <motion.div 
        className="p-6"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        {content.imageUrl && (
          <motion.div 
            className="relative w-full h-[240px] mb-6"
            initial={{ scale: 0.95 }}
            animate={{ scale: 1 }}
          >
            <ImageErrorBoundary>
              <Image
                src={content.imageUrl}
                alt={content.title}
                fill
                className="object-cover rounded-lg"
                sizes="(max-width: 768px) 100vw, 768px"
              />
            </ImageErrorBoundary>
          </motion.div>
        )}

        <motion.h2 
          className="text-2xl font-bold mb-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          {content.title}
        </motion.h2>

        <motion.p 
          className="text-muted-foreground mb-6"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          {content.body}
        </motion.p>

        {!isCompleted && (
          <motion.div 
            className="flex justify-end"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
          >
            <Button onClick={onComplete}>Continue</Button>
          </motion.div>
        )}
      </motion.div>
    </Card>
  )
}

================
File: [lessonId]/components/slides/question-slide.tsx
================
// app/lessons/[lessonId]/components/slides/question-slide.tsx

'use client'

import { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { Button } from '@/components/ui/button'
import { Card } from '@/components/ui/card'
import { QuestionSlide as QuestionSlideType } from '../../../types/lesson.types'
import { cn } from '@/components/ui/utils'
import Image from 'next/image'
import { ImageErrorBoundary } from '../image-error-boundary'

interface QuestionSlideProps {
  content: QuestionSlideType
  isActive: boolean
  isCompleted: boolean
  interactionState: string
  onAnswer: (optionId: string, correctOptionId: string) => void
  onComplete: () => void
}

export function QuestionSlide({ 
  content, 
  isActive, 
  isCompleted, 
  onAnswer,
  onComplete 
}: QuestionSlideProps) {
  const [selectedId, setSelectedId] = useState<string | null>(null)

  const correctOption = content.options.find(opt => opt.isCorrect)

  return (
    <Card className={cn(
      "overflow-hidden transition-all",
      isActive && "ring-2 ring-primary"
    )}>
      <motion.div 
        className="p-6"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
      >
        {content.imageUrl && (
          <motion.div 
            className="relative w-full h-[240px] mb-6"
            initial={{ scale: 0.95 }}
            animate={{ scale: 1 }}
          >
            <ImageErrorBoundary>
              <Image
                src={content.imageUrl}
                alt=""
                fill
                className="object-cover rounded-lg"
                sizes="(max-width: 768px) 100vw, 768px"
              />
            </ImageErrorBoundary>
          </motion.div>
        )}

        <motion.h2 
          className="text-xl font-semibold mb-6"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
        >
          {content.question}
        </motion.h2>

        <div className="space-y-3 mb-6">
          {content.options.map((option) => (
            <motion.button
              key={option.id}
              onClick={() => !isCompleted && setSelectedId(option.id)}
              className={cn(
                "w-full p-4 rounded-lg border-2 text-left transition-colors",
                selectedId === option.id && "border-primary bg-primary/5",
                isCompleted && option.isCorrect && "border-green-500 bg-green-50",
                isCompleted && !option.isCorrect && selectedId === option.id && "border-red-500 bg-red-50"
              )}
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
            >
              {option.text}
            </motion.button>
          ))}
        </div>

        <AnimatePresence mode="wait">
          {!isCompleted ? (
            <motion.div
              className="flex justify-end"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
            >
              <Button 
                onClick={() => {
                  if (selectedId && correctOption) {
                    onAnswer(selectedId, correctOption.id)
                  }
                }}
                disabled={!selectedId}
              >
                Check Answer
              </Button>
            </motion.div>
          ) : (
            <motion.div
              className="space-y-4"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
            >
              {content.explanation && (
                <div className="bg-muted p-4 rounded-lg">
                  {content.explanation}
                </div>
              )}
              <div className="flex justify-end">
                <Button onClick={onComplete}>Continue</Button>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
    </Card>
  )
}

================
File: [lessonId]/layout.tsx
================
// app/lessons/[lessonId]/layout.tsx

'use client'

import { LessonHeader } from './components/lesson-header'
import { cn } from '@/components/ui/utils'

interface LessonLayoutProps {
 children: React.ReactNode
}

export default function LessonLayout({ children }: LessonLayoutProps) {
 return (
   <div className={cn(
     "min-h-[100dvh] flex flex-col",
     "bg-background"
   )}>
     <LessonHeader className="flex-none sticky top-0 z-50" />
     
     <main className={cn(
       "flex-1 relative",
       "px-4 sm:px-6 lg:px-8",
       "pt-safe-offset-top pb-safe-offset-bottom"
     )}>
       {children}
     </main>
   </div>
 )
}

================
File: [lessonId]/page.tsx
================
// app/lessons/[lessonId]/page.tsx

import { ErrorBoundary } from '@/components/error-boundary'
import { LessonContainer } from './components/lesson-container'

interface PageProps {
  params: Promise<{
    lessonId: string
  }>
}

export default async function LessonPage({ params }: PageProps) {
  const { lessonId } = await params

  return (
    <ErrorBoundary>
      <LessonContainer lessonId={lessonId} />
    </ErrorBoundary>
  )
}

================
File: actions/lesson-completion.ts
================
// /features/lessons/actions/lesson-completion.ts
'use server'

import { lessonCompletionService } from '../services/lesson-completion.service'
import type { LessonCompletion } from '../types/db.types'

export async function createCompletion(lessonId: string, token: string | null): Promise<LessonCompletion> {
  return lessonCompletionService.createCompletion({ lesson_id: lessonId }, token)
}

================
File: data/exercise-content.ts
================
// pacing-lesson.ts
export const exerciseLessonContent = [
    {
      id: '1',
      type: 'info',
      title: 'What\'s the goal of these exercises?',
      body: 'These exercises are not for strengthening-- they are diagnostic tools to guide your recovery.',
      imageUrl: '/proneonelbows.png'
    },
    {
      id: '2',
      type: 'info',
      title: 'Creating The Right Environment',
      body: 'Stop any existing exercises you are currently doing for your low back.  This will help us more clearly determine which exercises are helping or hurting your condition.',
      imageUrl: '/longterm.png'
    },
    {
      id: '3',

      type: 'infoBullet',
      title: 'Understanding Your Exercise Response',
      introduction: 'Several key responses to pay attention to with the exercises:',
      bullets: [
        { text: 'Your pain may appear then gradually diminish' },
        { text: 'Your movement may improve with repetition' },
        { text: 'Your symptoms can increase or decrease' },
        { text: 'Your pain location may change or shift' }
      ],
      imageUrl: '/derangement.png'
    },
    {
      id: '4',
      type: 'infoBullet',
      title: 'What is Centralization?',
      introduction: 'Centralization is the movement of your pain to a more central location:',
      bullets: [
        { text: 'It is the best indicator of recovery' },
        { text: 'Exercises that centralize are the correct movements' },
        { text: 'Exercises that move pain away from the low back are the wrong movements' },
        { text: 'Let the exercises that centralize your pain guide you' }
      ],
      imageUrl: '/centralize.png'
    },

    // {
    //   id: '5',
    //   type: 'question',
    //   question: 'Is the pain centralizing?',
    //   options: [
    //     { id: '1', text: 'No, the symptoms are moving away from the low back.', isCorrect: true },
    //     { id: '2', text: 'No, the symptoms are staying the same.', isCorrect: false },
    //     { id: '3', text: 'Yes, the symptoms move from the back of the thigh to the low back.', isCorrect: false }
    //   ],
    //   explanation: 'Remember, centralization is the movement of your pain to a more central location. If your pain is moving away from the low back, it is worsening.',
    //   imageUrl: '/beforeafter.png'
    // },
    // {
    //   id: '6',
    //   type: 'infoBullet',
    //   title: 'What is Directional Preference?',
    //   introduction: 'It\'s the movement direction that improves or centralizes your symptoms:',
    //   bullets: [
    //     { text: 'Most common direction is extension (backward bending)' },
    //     { text: 'Up to 70% of people exhibit a directional preference' },
    //     { text: 'Using repeated movements in the same direction can help determine the correct direction' },
    //     { text: 'The exercise module ahead will help guide you to find your directional preference' }
    //   ],
    //   imageUrl: '/standflexext.png'
      
    // },
    // {
    //   id: '7',
    //   type: 'question',
    //   question: 'A person has pain in their lower back and right hip. After performing 10 repetitions of forward bends (flexion), their symptoms have spread to include their lower back, right hip, and right calf. Is flexion their directional preference?',
    //   options: [
    //     { id: '1', text: 'Yes, their symptoms are centralizing', isCorrect: false },
    //     { id: '2', text: 'No, their symptoms are moving away from the low back.', isCorrect: true },
    //     { id: '3', text: 'Not enough information to determine', isCorrect: false }
    //   ],
    //   explanation: 'The answer is no.  The patient symptoms have moved further down into the calf.  This is the opposite of centralization, and tells us that we do not want to continue in that direction.  Remember:  If symptoms move away from the spine, pain intensity increases and remains worse, and/or your range of movement decreases,  you should discontinue the movement in that direction.',
    //   imageUrl: '/beforeaftercalf.png'
    // },

    // {
    //   id: '8',
    //   type: 'question',
    //   question: 'The same person now has pain in their low back, right hip, and right calf. After performing 10 repetitions of backward bends (extension), their symptoms are now in the low back and the right hip. Is extension their directional preference?',
    //   options: [
    //     { id: '1', text: 'Yes, their symptoms are centralizing', isCorrect: true },
    //     { id: '2', text: 'No, their symptoms are moving away from the low back.', isCorrect: false },
    //     { id: '3', text: 'Not enough information to determine', isCorrect: false }
    //   ],
    //   explanation: 'The answer is yes!  The right calf no longer has any symptoms, and the pain is back to the original location of the low back and right hip.  This is a centralizing response.  They should continue with extension.',
    //   imageUrl: '/afterbeforecalf.png'
    // },
    // {
    //   id: '9',
    //   type: 'info',
    //   title: 'Last but not least...',
    //   body: 'We understand that was a lot. Feel free to scroll up and review any of the principles we went over. The next module will help guide you through a series of exercises to help you find your directional preference.',
    //   imageUrl: '/sphinx-pose.png',
    //   nextRoute: '/exercise-progression/1'
    // }
  ]

================
File: data/posture-content.ts
================
// posture-lesson.ts
export const postureLessonContent = [
    {
      id: '1',
      type: 'info',
      title: 'Understanding Posture',
      body: 'Good posture is essential for reducing strain on your body and preventing pain. In this lesson, we\'ll explore what makes good posture and how to maintain it throughout your day.',
      imageUrl: '/goodbadposture.png'
    },
    {
      id: '2',
      type: 'info',
      title: 'The Spine\'s Natural Curves',
      body: 'Your spine has natural curves that help distribute weight and absorb shock. Maintaining these curves while sitting and standing is key to good posture.',
      imageUrl: '/lumbar-good.png'
    },
    {
      id: '3',
      type: 'question',
      question: 'Which of these is a sign of poor posture?',
      options: [
        { id: '1', text: 'Rounded shoulders and forward head position', isCorrect: true },
        { id: '2', text: 'Ears aligned with shoulders when viewed from the side', isCorrect: false },
        { id: '3', text: 'Natural curve in lower back', isCorrect: false }
      ],
      explanation: 'Rounded shoulders and forward head position put extra strain on your neck and upper back muscles. This posture often develops from prolonged computer use or phone viewing.',
      imageUrl: '/posture-good.png'
    },
    {
      id: '4',
      type: 'info',
      title: 'Common Posture Mistakes',
      body: 'Many daily activities can lead to poor posture. Looking down at phones, slouching at desks, and carrying heavy bags on one shoulder are common culprits.',
      imageUrl: '/slouchposture.png'
    },
    {
      id: '5',
      type: 'question',
      question: 'What is the best way to check your standing posture?',
      options: [
        { id: '1', text: 'Stand with your back against a wall, with head, shoulders, and hips touching', isCorrect: true },
        { id: '2', text: 'Look in the mirror while standing normally', isCorrect: false },
        { id: '3', text: 'Ask someone to take a photo of you', isCorrect: false }
      ],
      explanation: 'The wall check provides consistent reference points for alignment. Your head, shoulder blades, and buttocks should touch the wall, with feet about 4 inches from the wall.',
      imageUrl: ''
    }
  ]

================
File: hooks/__tests__/use-lesson-completion.test.ts
================
// features/lessons/hooks/__tests__/use-lesson-completion.test.tsx

import { renderHook, act } from '@testing-library/react'
import { useAuth } from '@clerk/nextjs'
import { useLessonCompletion } from '../use-lesson-completion'
import { createCompletion } from '../../actions/lesson-completion'


// Mock dependencies
jest.mock('@clerk/nextjs', () => ({
  useAuth: jest.fn()
}))

jest.mock('../../actions/lesson-completion', () => ({
  createCompletion: jest.fn()
}))

describe('useLessonCompletion', () => {
  const mockLessonId = 'lesson-1'
  const mockToken = 'test-token'

  beforeEach(() => {
    jest.clearAllMocks()
    ;(useAuth as jest.Mock).mockReturnValue({
      getToken: jest.fn().mockResolvedValue(mockToken)
    })
  })

  it('should initialize with default state', () => {
    const { result } = renderHook(() => useLessonCompletion(mockLessonId))

    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toBeNull()
  })

  it('should successfully complete a lesson', async () => {
    ;(createCompletion as jest.Mock).mockResolvedValue({
      id: '123',
      lesson_id: mockLessonId,
      completed_at: new Date().toISOString()
    })

    const { result } = renderHook(() => useLessonCompletion(mockLessonId))

    await act(async () => {
      await result.current.complete()
    })

    expect(createCompletion).toHaveBeenCalledWith(mockLessonId, mockToken)
    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toBeNull()
  })

  it('should handle completion failure', async () => {
    const error = new Error('Failed to complete')
    ;(createCompletion as jest.Mock).mockRejectedValue(error)

    const { result } = renderHook(() => useLessonCompletion(mockLessonId))

    await act(async () => {
      try {
        await result.current.complete()
      } catch (e) {
        expect(e).toBe(error)
      }
    })

    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toBe(error)
  })

  it('should handle auth token failure', async () => {
    const error = new Error('Auth error')
    ;(useAuth as jest.Mock).mockReturnValue({
      getToken: jest.fn().mockRejectedValue(error)
    })

    const { result } = renderHook(() => useLessonCompletion(mockLessonId))

    await act(async () => {
      try {
        await result.current.complete()
      } catch (e) {
        expect(e).toBe(error)
      }
    })

    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toBe(error)
  })
})

================
File: hooks/use-lesson-completion.ts
================
// /features/lessons/hooks/use-lesson-completion.ts
import { useState, useCallback } from 'react'
import { useAuth } from '@clerk/nextjs'
import { createCompletion } from '../actions/lesson-completion'
import type { LessonCompletion } from '../types/db.types'

export function useLessonCompletion(lessonId: string) {
  const { getToken } = useAuth()
  const [isCompleting, setIsCompleting] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  const complete = useCallback(async () => {
    try {
      setIsCompleting(true)
      setError(null)
      const token = await getToken({ template: 'supabase' })
      await createCompletion(lessonId, token)
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Failed to complete lesson'))
      throw err
    } finally {
      setIsCompleting(false)
    }
  }, [lessonId, getToken])

  return {
    complete,
    isCompleting,
    error
  }
}

================
File: hooks/use-lesson-progress.ts
================
// features/lessons/hooks/use-lesson-progress.ts

import { useState, useCallback, useEffect } from 'react'
import { useAuth } from '@clerk/nextjs'
import { LessonProgress } from '../model/lesson-progress'
import type { Lesson, Slide } from '../types/lesson.types'
import { exerciseLessonContent } from '../data/exercise-content'
import { postureLessonContent } from '../data/posture-content'

export function useLessonProgress(lessonId?: string) {
  const { userId } = useAuth()
  const [lesson, setLesson] = useState<Lesson | null>(null)
  const [progressModel] = useState(() => new LessonProgress())
  const [loading, setLoading] = useState(false)

  // Load static lesson content based on lessonId
  useEffect(() => {
    async function loadLesson() {
      try {
        setLoading(true)
        
        // Use static content based on lessonId
        const slides = lessonId === 'exercise-lesson' 
          ? exerciseLessonContent 
          : lessonId === 'posture-lesson'
            ? postureLessonContent
            : []

        if (slides.length > 0) {
          const lessonData: Lesson = {
            id: lessonId || 'default',
            title: lessonId === 'exercise-lesson' ? 'Exercise Lesson' : 'Posture Lesson',
            slides: slides as Slide[],
            progress: 0,
            currentSlideIndex: 0,
            completedSlideIds: [],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            userId: userId || 'anonymous'
          }
          setLesson(lessonData)
        }
      } catch (error) {
        console.error('Error loading lesson:', error)
      } finally {
        setLoading(false)
      }
    }

    loadLesson()
  }, [lessonId, userId])

  const completeSlide = useCallback(async (slideId: string) => {
    if (!lesson) return

    try {
      setLoading(true)
      progressModel.completeSlide(slideId, lesson.slides.length)
      
      // Update local lesson state
      setLesson(prev => {
        if (!prev) return null
        const newCompletedSlideIds = [...prev.completedSlideIds, slideId]
        return {
          ...prev,
          completedSlideIds: newCompletedSlideIds,
          progress: progressModel.getProgress(),
          isCompleted: newCompletedSlideIds.length === lesson.slides.length
        }
      })
    } finally {
      setLoading(false)
    }
  }, [lesson, progressModel])

  return {
    lesson,
    progress: progressModel.getProgress(),
    completedSlides: new Set(lesson?.completedSlideIds || []),
    currentIndex: progressModel.getCurrentIndex(),
    loading,
    completeSlide,
    isCompleted: lesson?.completedSlideIds.length === lesson?.slides.length
  }
}

================
File: hooks/use-lesson.ts
================
// features/lessons/hooks/use-lesson.ts

import { useLessonProgress } from './use-lesson-progress'
import { useSlideInteraction } from './use-slide-interaction'
import { useViewportScroll } from './use-viewport-scroll'
import { useMemo } from 'react'

export function useLesson(lessonId?: string) {
  const {
    lesson,
    progress,
    completedSlides,
    currentIndex,
    loading,
    completeSlide
  } = useLessonProgress(lessonId)

  const {
    state: interactionState,
    selectedOption,
    isCorrect,
    hasReviewed,
    canSubmit,
    canViewExplanation,
    handleAnswer,
    showExplanationPanel,
    reset: resetInteraction
  } = useSlideInteraction()

  const {
    updateSlidePosition,
    scrollToSlide,
    activeSlideId,
    lastScrollPosition
  } = useViewportScroll()

  // Calculate visible slides based on lesson data and current index
  const visibleSlides = useMemo(() => {
    if (!lesson?.slides) return []
    // Only show current slide
    return lesson.slides.slice(0, currentIndex + 1)
  }, [lesson?.slides, currentIndex])

  return {
    // Lesson Progress
    lesson,
    visibleSlides,
    progress,
    completedSlides,
    currentIndex,
    loading,
    completeSlide,

    // Interaction State  
    interactionState,
    selectedOption,
    isCorrect,
    hasReviewed,
    canSubmit,
    canViewExplanation,
    handleAnswer,
    showExplanationPanel,
    resetInteraction,

    // Viewport/Scroll
    updateSlidePosition,
    scrollToSlide,
    activeSlideId,
    lastScrollPosition
  }
}

================
File: hooks/use-slide-interaction.ts
================
// features/lessons/hooks/use-slide-interaction.ts

import { useState, useCallback } from 'react'
import { SlideInteraction } from '../model/slide-interaction'

export function useSlideInteraction() {
  const [interactionModel] = useState(() => new SlideInteraction())

  const handleAnswer = useCallback((optionId: string, correctOptionId: string) => {
    interactionModel.selectOption(optionId)
    interactionModel.submit(correctOptionId)
  }, [interactionModel])

  const showExplanationPanel = useCallback(() => {
    interactionModel.viewExplanation()
  }, [interactionModel])

  const reset = useCallback(() => {
    interactionModel.reset()
  }, [interactionModel])

  return {
    state: interactionModel.getState(),
    selectedOption: interactionModel.getSelectedOption(),
    isCorrect: interactionModel.isAnswerCorrect(),
    hasReviewed: interactionModel.hasReviewed(),
    canSubmit: interactionModel.canSubmit(),
    canViewExplanation: interactionModel.canViewExplanation(),
    handleAnswer,
    showExplanationPanel,
    reset
  }
}

================
File: hooks/use-viewport-scroll.ts
================
import { useState, useEffect, useCallback, useRef } from 'react';

interface ViewportBounds {
  top: number;
  bottom: number;
}

interface SlidePosition {
  slideId: string;
  bounds: ViewportBounds;
  isActive: boolean;
}

export function useViewportScroll() {
  const [slidePositions, setSlidePositions] = useState<Map<string, SlidePosition>>(new Map());
  const [activeSlideId, setActiveSlideId] = useState<string | null>(null);
  const [lastScrollPosition, setLastScrollPosition] = useState<number>(0);
  const lastScrollPositionRef = useRef<number>(0);

  const updateSlidePosition = useCallback((slideId: string, bounds: ViewportBounds) => {
    setSlidePositions(prev => {
      const newPositions = new Map(prev);
      newPositions.set(slideId, { slideId, bounds, isActive: false });
      return newPositions;
    });
  }, []);

  const scrollToSlide = useCallback((index: number) => {
    const slides = document.querySelectorAll('.slide-item');
    const targetSlide = slides[index];
    
    if (!targetSlide) return;

    const slideRect = targetSlide.getBoundingClientRect();
    const scrollPosition = slideRect.top + window.scrollY - 20;

    lastScrollPositionRef.current = scrollPosition;
    setLastScrollPosition(scrollPosition);

    window.scrollTo({
      top: Math.max(0, scrollPosition),
      behavior: 'smooth'
    });

    const verifyScroll = () => {
      const currentPosition = window.scrollY;
      if (Math.abs(currentPosition - lastScrollPositionRef.current) > 2) {
        window.scrollTo(0, lastScrollPositionRef.current);
      }
    };

    setTimeout(verifyScroll, 1000);
  }, []);

  useEffect(() => {
    const handleScroll = () => {
      const scrollPosition = window.scrollY;
      setLastScrollPosition(scrollPosition);

      slidePositions.forEach((position, slideId) => {
        const isVisible =
          position.bounds.bottom >= scrollPosition &&
          position.bounds.top <= scrollPosition + window.innerHeight;

        if (isVisible && activeSlideId !== slideId) {
          setActiveSlideId(slideId);
        }
      });
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [slidePositions, activeSlideId]);

  return {
    updateSlidePosition,
    scrollToSlide,
    activeSlideId,
    lastScrollPosition,
  };
}

================
File: model/__tests__/lesson-progress.test.ts
================
// features/lessons/model/__tests__/lesson-progress.test.ts

import { LessonProgress } from '../lesson-progress'

describe('LessonProgress', () => {
  let progress: LessonProgress

  beforeEach(() => {
    // Fresh instance before each test
    progress = new LessonProgress()
  })

  describe('Lesson State', () => {
    test('should initialize with correct starting values', () => {
      expect(progress.getCurrentIndex()).toBe(0)
      expect(progress.getProgress()).toBe(0)
      expect(progress.isLessonComplete()).toBe(false)
      expect(progress.getCompletedSlides()).toHaveLength(0)
    })

    test('should track completed status correctly', () => {
      // Complete all slides in a 2-slide lesson
      progress.completeSlide('slide1', 2)
      progress.completeSlide('slide2', 2)
      
      expect(progress.isLessonComplete()).toBe(true)
      expect(progress.getProgress()).toBe(100)
    })
  })

  describe('Slide Completion', () => {
    test('should only count each slide once', () => {
      progress.completeSlide('slide1', 4)
      progress.completeSlide('slide1', 4)
      
      expect(progress.getProgress()).toBe(25) // Only counted once
    })

    test('should calculate progress correctly', () => {
      progress.completeSlide('slide1', 4)
      expect(progress.getProgress()).toBe(25)
      
      progress.completeSlide('slide2', 4)
      expect(progress.getProgress()).toBe(50)
    })
  })

  describe('Navigation', () => {
    test('should not advance beyond total slides', () => {
      expect(progress.canAdvance(1)).toBe(false)
    })

    test('should advance when possible', () => {
      expect(progress.canAdvance(2)).toBe(true)
      progress.advanceSlide(2)
      expect(progress.getCurrentIndex()).toBe(1)
    })

    test('should track current position correctly', () => {
      progress.advanceSlide(3)
      expect(progress.getCurrentIndex()).toBe(1)
      
      progress.advanceSlide(3)
      expect(progress.getCurrentIndex()).toBe(2)
    })
  })
})

================
File: model/__tests__/slide-interaction.test.ts
================
// features/lessons/model/__tests__/slide-interaction.test.ts

import { SlideInteraction } from '../slide-interaction'

describe('SlideInteraction', () => {
  let interaction: SlideInteraction

  beforeEach(() => {
    interaction = new SlideInteraction()
  })

  describe('State Management', () => {
    test('should initialize in viewing state', () => {
      expect(interaction.getState()).toBe('viewing')
      expect(interaction.getSelectedOption()).toBeNull()
      expect(interaction.isAnswerCorrect()).toBeNull()
    })

    test('should transition through states correctly', () => {
      interaction.startAnswering()
      expect(interaction.getState()).toBe('answering')

      interaction.selectOption('option1')
      interaction.submit('option1')
      expect(interaction.getState()).toBe('reviewing')
    })
  })

  describe('Answer Handling', () => {
    test('should handle correct answer', () => {
      interaction.startAnswering()
      interaction.selectOption('correct')
      interaction.submit('correct')
      
      expect(interaction.isAnswerCorrect()).toBe(true)
    })

    test('should handle incorrect answer', () => {
      interaction.startAnswering()
      interaction.selectOption('wrong')
      interaction.submit('correct')
      
      expect(interaction.isAnswerCorrect()).toBe(false)
    })
  })

  describe('Explanation Viewing', () => {
    test('should track explanation state', () => {
      expect(interaction.hasReviewed()).toBe(false)
      
      interaction.viewExplanation()
      expect(interaction.hasReviewed()).toBe(true)
      expect(interaction.getState()).toBe('explaining')
    })
  })

  describe('Reset Functionality', () => {
    test('should reset to initial answering state', () => {
      interaction.selectOption('option1')
      interaction.submit('correct')
      interaction.reset()

      expect(interaction.getState()).toBe('answering')
      expect(interaction.getSelectedOption()).toBeNull()
      expect(interaction.isAnswerCorrect()).toBeNull()
    })
  })
})

================
File: model/__tests__/viewport-state.test.ts
================
// features/lessons/model/__tests__/viewport-state.test.ts

import { ViewportState } from '../viewport-state'

describe('ViewportState', () => {
  let viewport: ViewportState

  beforeEach(() => {
    viewport = new ViewportState()
  })

  describe('Slide Position Tracking', () => {
    test('should track slide positions', () => {
      viewport.updateSlidePosition('slide1', { top: 0, bottom: 100 })
      expect(viewport.getSlideBounds('slide1')).toEqual({ top: 0, bottom: 100 })
    })

    test('should determine if slide is visible', () => {
      viewport.updateSlidePosition('slide1', { top: 50, bottom: 150 })
      
      expect(viewport.isSlideVisible('slide1', { top: 0, bottom: 100 })).toBe(true)
      expect(viewport.isSlideVisible('slide1', { top: 200, bottom: 300 })).toBe(false)
    })
  })

  describe('Active Slide Management', () => {
    test('should track active slide', () => {
      viewport.setActiveSlide('slide1')
      expect(viewport.getActiveSlideId()).toBe('slide1')
    })
  })

  describe('Scroll Position', () => {
    test('should record and retrieve scroll position', () => {
      viewport.recordScrollPosition(100)
      expect(viewport.getLastScrollPosition()).toBe(100)
    })
  })
})

================
File: model/lesson-progress.ts
================
// features/lessons/model/lesson-progress.ts

interface LessonProgressState {
    currentSlideIndex: number
    completedSlideIds: Set<string>
    progress: number
    isStarted: boolean
    isCompleted: boolean
  }
  
  export class LessonProgress {
    private state: LessonProgressState
  
    constructor(initial?: Partial<LessonProgressState>) {
      this.state = {
        currentSlideIndex: initial?.currentSlideIndex ?? 0,
        completedSlideIds: new Set(initial?.completedSlideIds),
        progress: initial?.progress ?? 0,
        isStarted: initial?.isStarted ?? false,
        isCompleted: initial?.isCompleted ?? false
      }
    }
  
    completeSlide(slideId: string, totalSlides: number): void {
      this.state.completedSlideIds.add(slideId)
      this.state.progress = (this.state.completedSlideIds.size / totalSlides) * 100
      
      // Advance to next slide if not at the end
      if (this.state.currentSlideIndex < totalSlides - 1) {
        this.state.currentSlideIndex++
      }
      
      if (this.state.progress === 100) {
        this.state.isCompleted = true
      }
    }
  
    startLesson(): void {
      if (!this.state.isStarted) {
        this.state.isStarted = true
        this.state.currentSlideIndex = 0
      }
    }
  
    advanceSlide(totalSlides: number): boolean {
      if (this.canAdvance(totalSlides)) {
        this.state.currentSlideIndex++
        return true
      }
      return false
    }
  
    canAdvance(totalSlides: number): boolean {
      return this.state.currentSlideIndex < totalSlides - 1
    }
  
    isSlideCompleted(slideId: string): boolean {
      return this.state.completedSlideIds.has(slideId)
    }
  
    getProgress(): number {
      return this.state.progress
    }
  
    getCurrentIndex(): number {
      return this.state.currentSlideIndex
    }
  
    getCompletedSlides(): string[] {
      return Array.from(this.state.completedSlideIds)
    }
  
    isLessonComplete(): boolean {
      return this.state.isCompleted
    }
  
    toJSON() {
      return {
        currentSlideIndex: this.state.currentSlideIndex,
        completedSlideIds: Array.from(this.state.completedSlideIds),
        progress: this.state.progress,
        isStarted: this.state.isStarted,
        isCompleted: this.state.isCompleted
      }
    }
  }

================
File: model/slide-interaction.ts
================
// features/lessons/model/slide-interaction.ts

export type InteractionState = 'viewing' | 'answering' | 'reviewing' | 'explaining'

interface SlideInteractionState {
 state: InteractionState
 selectedOptionId: string | null
 hasSubmitted: boolean 
 hasViewedExplanation: boolean
 isCorrect: boolean | null
}

export class SlideInteraction {
 private state: SlideInteractionState

 constructor(initial?: Partial<SlideInteractionState>) {
   this.state = {
     state: initial?.state ?? 'viewing',
     selectedOptionId: initial?.selectedOptionId ?? null,
     hasSubmitted: initial?.hasSubmitted ?? false,
     hasViewedExplanation: initial?.hasViewedExplanation ?? false,
     isCorrect: initial?.isCorrect ?? null
   }
 }

 selectOption(optionId: string): void {
   if (this.state.state === 'answering') {
     this.state.selectedOptionId = optionId
   }
 }

 submit(correctOptionId: string): void {
   if (!this.state.selectedOptionId) return

   this.state.hasSubmitted = true
   this.state.isCorrect = this.state.selectedOptionId === correctOptionId
   this.state.state = 'reviewing'
 }

 startAnswering(): void {
   this.state.state = 'answering'
 }

 viewExplanation(): void {
   this.state.state = 'explaining'
   this.state.hasViewedExplanation = true
 }

 reset(): void {
   this.state.state = 'answering'
   this.state.selectedOptionId = null
   this.state.hasSubmitted = false
   this.state.isCorrect = null
 }

 canSubmit(): boolean {
   return !!this.state.selectedOptionId && !this.state.hasSubmitted
 }

 canViewExplanation(): boolean {
   return this.state.hasSubmitted && !this.state.hasViewedExplanation
 }
 
 getState(): InteractionState {
   return this.state.state
 }

 getSelectedOption(): string | null {
   return this.state.selectedOptionId
 }

 isAnswerCorrect(): boolean | null {
   return this.state.isCorrect
 }

 hasReviewed(): boolean {
   return this.state.hasViewedExplanation
 }

 toJSON() {
   return { ...this.state }
 }
}

================
File: model/viewport-state.ts
================
// features/lessons/model/viewport-state.ts

interface ViewportBounds {
    top: number
    bottom: number
   }
   
   interface SlidePosition {
    slideId: string
    bounds: ViewportBounds
    isActive: boolean
   }
   
   export class ViewportState {
    private slidePositions: Map<string, SlidePosition>
    private activeSlideId: string | null
    private lastScrollPosition: number
   
    constructor() {
      this.slidePositions = new Map()
      this.activeSlideId = null
      this.lastScrollPosition = 0
    }
   
    updateSlidePosition(slideId: string, bounds: ViewportBounds): void {
      this.slidePositions.set(slideId, {
        slideId,
        bounds,
        isActive: false
      })
    }
   
    setActiveSlide(slideId: string): void {
      this.activeSlideId = slideId
      this.slidePositions.forEach(position => {
        position.isActive = position.slideId === slideId
      })
    }
   
    isSlideVisible(slideId: string, viewportBounds: ViewportBounds): boolean {
      const position = this.slidePositions.get(slideId)
      if (!position) return false
   
      return (
        position.bounds.bottom >= viewportBounds.top && 
        position.bounds.top <= viewportBounds.bottom
      )
    }
   
    recordScrollPosition(position: number): void {
      this.lastScrollPosition = position
    }
   
    getLastScrollPosition(): number {
      return this.lastScrollPosition
    }
   
    getActiveSlideId(): string | null {
      return this.activeSlideId
    }
   
    getSlideBounds(slideId: string): ViewportBounds | null {
      return this.slidePositions.get(slideId)?.bounds ?? null
    }
   
    toJSON() {
      return {
        positions: Array.from(this.slidePositions.entries()),
        activeSlideId: this.activeSlideId,
        lastScrollPosition: this.lastScrollPosition
      }
    }
   }

================
File: services/__tests__/lesson-completion.service.test.ts
================
// features/lessons/services/__tests__/lesson-completion.service.test.ts

import { lessonCompletionService } from '../lesson-completion.service'
import SupabaseClientSingleton from '@/lib/supabase/client-singleton'

jest.mock('@/lib/supabase/client-singleton', () => ({
 __esModule: true,
 default: {
   getInstance: jest.fn()
 }
}))

describe('LessonCompletionService', () => {
 const mockToken = 'test-token'
 const mockLessonId = 'lesson-1'
 const mockUserId = 'user-1'
 let mockSupabaseClient: any

 beforeEach(() => {
   jest.clearAllMocks()
   
   mockSupabaseClient = {
     from: jest.fn().mockReturnValue({
       insert: jest.fn().mockReturnThis(),
       select: jest.fn().mockReturnThis(),
       single: jest.fn()
     }),
     rpc: jest.fn()
   }

   ;(SupabaseClientSingleton.getInstance as jest.Mock).mockResolvedValue(mockSupabaseClient)
 })

 describe('createCompletion', () => {
   beforeEach(() => {
     mockSupabaseClient.rpc.mockResolvedValue({
       data: mockUserId,
       error: null
     })
   })

   it('should create a new completion record', async () => {
     const mockCompletion = {
       id: '123',
       lesson_id: mockLessonId,
       user_id: mockUserId,
       completed_at: new Date().toISOString()
     }

     mockSupabaseClient.from().single.mockResolvedValue({
       data: mockCompletion,
       error: null
     })

     const result = await lessonCompletionService.createCompletion(
       { lesson_id: mockLessonId }, 
       mockToken
     )
     
     expect(result).toEqual(mockCompletion)
     expect(mockSupabaseClient.from).toHaveBeenCalledWith('lesson_completions')
     expect(mockSupabaseClient.rpc).toHaveBeenCalledWith('requesting_user_id')
   })

   it('should throw error when user id not found', async () => {
     mockSupabaseClient.rpc.mockResolvedValue({
       data: null,
       error: null
     })

     await expect(
       lessonCompletionService.createCompletion(
         { lesson_id: mockLessonId }, 
         mockToken
       )
     ).rejects.toThrow('No user ID found in JWT claims')
   })
 })
})

================
File: services/__tests__/use-lesson-completion.test.ts
================
// features/lessons/hooks/__tests__/use-lesson-completion.test.ts

import { renderHook, act } from '@testing-library/react'
import { useAuth } from '@clerk/nextjs'
import { useLessonCompletion } from '../../hooks/use-lesson-completion'
import { createCompletion } from '../../actions/lesson-completion'

// Mock dependencies
jest.mock('@clerk/nextjs', () => ({
  useAuth: jest.fn()
}))

jest.mock('../../actions/lesson-completion', () => ({
  createCompletion: jest.fn()
}))

describe('useLessonCompletion', () => {
  const mockLessonId = 'lesson-1'
  const mockToken = 'test-token'

  beforeEach(() => {
    jest.clearAllMocks()
    ;(useAuth as jest.Mock).mockReturnValue({
      getToken: jest.fn().mockResolvedValue(mockToken)
    })
  })

  it('should handle successful completion', async () => {
    ;(createCompletion as jest.Mock).mockResolvedValue({
      id: '123',
      lesson_id: mockLessonId,
      completed_at: new Date().toISOString()
    })

    const { result } = renderHook(() => useLessonCompletion(mockLessonId))

    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toBeNull()

    await act(async () => {
      await result.current.complete()
    })

    expect(createCompletion).toHaveBeenCalledWith(mockLessonId, mockToken)
    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toBeNull()
  })

  it('should handle completion errors', async () => {
    const error = new Error('Failed to complete')
    ;(createCompletion as jest.Mock).mockRejectedValue(error)

    const { result } = renderHook(() => useLessonCompletion(mockLessonId))

    await act(async () => {
      try {
        await result.current.complete()
      } catch (e) {
        // Error is expected
      }
    })

    expect(result.current.isCompleting).toBe(false)
    expect(result.current.error).toEqual(error)
  })
})

================
File: services/lesson-completion.service.ts
================
// /features/lessons/services/lesson-completion.service.ts
import { BaseService } from '@/lib/supabase/services/base'
import type { LessonCompletion, CreateLessonCompletion } from '../types/db.types'

// features/lessons/services/lesson-completion.service.ts

export class LessonCompletionService extends BaseService {
    private readonly table = 'lesson_completions'
  
    async createCompletion(completion: CreateLessonCompletion, token?: string | null): Promise<LessonCompletion> {
      return this.withErrorHandling(async () => {
        const client = await this.getClient(token)
        
        const { data: claims } = await client.rpc('requesting_user_id')
        if (!claims) throw new Error('No user ID found in JWT claims')
  
        const { data, error } = await client
          .from(this.table)
          .insert({ ...completion, user_id: claims })
          .select()
          .single()
        
        if (error) throw error
        return data
      })
    }
  }
  
  export const lessonCompletionService = new LessonCompletionService()

================
File: services/lesson.service.ts
================
// features/lessons/services/lesson.service.ts

import { BaseService } from '@/lib/supabase/services/base'
import type { Lesson, CreateLesson, UpdateLesson } from '../types/lesson.types'

export class LessonService extends BaseService {
  private readonly table = 'lessons'

  async getLesson(lessonId: string, token?: string | null): Promise<Lesson | null> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
        .eq('id', lessonId)
        .maybeSingle()
      
      if (error) throw error
      return data
    })
  }

  async getLessonProgress(userId: string, lessonId: string, token?: string | null): Promise<Lesson | null> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .select('*')
        .eq('id', lessonId)
        .eq('user_id', userId)
        .maybeSingle()

      if (error) throw error
      return data
    })
  }

  async createLessonProgress(lesson: CreateLesson, token?: string | null): Promise<Lesson> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)

      // Get the user_id from the JWT claims
      const { data: claims, error: claimsError } = await client.rpc('requesting_user_id')
      if (claimsError) throw claimsError
      if (!claims) throw new Error('No user ID found in JWT claims')

      const { data, error } = await client
        .from(this.table)
        .insert({ ...lesson, user_id: claims })
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async updateLessonProgress(
    lessonId: string, 
    updates: UpdateLesson, 
    token?: string | null
  ): Promise<Lesson> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      const { data, error } = await client
        .from(this.table)
        .update({ 
          ...updates, 
          updated_at: new Date().toISOString() 
        })
        .eq('id', lessonId)
        .select()
        .single()
      
      if (error) throw error
      return data
    })
  }

  async completeSlide(
    lessonId: string,
    slideId: string,
    token?: string | null
  ): Promise<Lesson> {
    return this.withErrorHandling(async () => {
      const client = await this.getClient(token)
      
      // First get the current lesson to update completed slides
      const { data: currentLesson, error: fetchError } = await client
        .from(this.table)
        .select('*')
        .eq('id', lessonId)
        .single()

      if (fetchError) throw fetchError

      const completedSlideIds = new Set([
        ...currentLesson.completedSlideIds,
        slideId
      ])

      // Calculate new progress
      const totalSlides = currentLesson.slides.length
      const progress = (completedSlideIds.size / totalSlides) * 100

      // Update the lesson
      const { data, error } = await client
        .from(this.table)
        .update({
          completedSlideIds: Array.from(completedSlideIds),
          progress,
          updated_at: new Date().toISOString()
        })
        .eq('id', lessonId)
        .select()
        .single()

      if (error) throw error
      return data
    })
  }
}

export const lessonService = new LessonService()

================
File: types/db.types.ts
================
// /features/lessons/types/db.types.ts
export interface LessonCompletion {
    id: string
    user_id: string
    lesson_id: string
    completed_at: string
  }
  
  export type CreateLessonCompletion = Pick<LessonCompletion, 'lesson_id'>

================
File: types/lesson.types.ts
================
// features/lessons/types/lesson.types.ts

export interface BaseSlide {
    id: string
    type: SlideType
    nextRoute?: string
  }
  
  export type SlideType = 'info' | 'question' | 'infoBullet'
  
  export interface InfoSlide extends BaseSlide {
    type: 'info'
    title: string
    body: string
    imageUrl?: string
  }
  
  export interface QuestionSlide extends BaseSlide {
    type: 'question'
    question: string
    options: QuestionOption[]
    explanation?: string
    imageUrl?: string
  }
  
  export interface InfoBulletSlide extends BaseSlide {
    type: 'infoBullet'
    title: string
    introduction?: string
    bullets: BulletPoint[]
    imageUrl?: string
  }
  
  export interface QuestionOption {
    id: string
    text: string
    isCorrect: boolean
  }
  
  export interface BulletPoint {
    text: string
  }
  
  export type Slide = InfoSlide | QuestionSlide | InfoBulletSlide
  
  export interface Lesson {
    id: string
    title: string
    description?: string
    slides: Slide[]
    progress: number
    currentSlideIndex: number
    completedSlideIds: string[]
    createdAt: string
    updatedAt: string
    userId: string
  }
  
  export type CreateLesson = Omit<Lesson, 'id' | 'createdAt' | 'updatedAt'>
  export type UpdateLesson = Partial<Omit<Lesson, 'id' | 'userId' | 'createdAt' | 'updatedAt'>>



================================================================
End of Codebase
================================================================
